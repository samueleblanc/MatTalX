/*
    This is the main file of MatTalX

    By building the app (with bash build.sh) /popup-specific.js is pasted at the end of this (compiled) file

    The main purpose of this program is to take a text as input (mostly LaTeX commands), 
    to convert them into the desired symbol (UTF) and finally to display them so they can 
    be copied and sent via Messenger, Instagram, Twitter, etc.
*/

/*
    CODE STRUCTURE
    
    N.B. Every section header has the format: /// NAME /// and every subsection: * Name *

    /// TYPES ///  -> Define the interfaces, function to check for a type and type used in this file
    ‚îÇ
    ‚îÇ
    /// GLOBALS ///  -> All the global variables
    ‚îÇ
    ‚îú‚îÄ Functions (as const)
    ‚îú‚îÄ Dictionaries
    ‚îú‚îÄ HTMLElements
    ‚îú‚îÄ Other
    ‚îÇ
    /// FUNCTIONS ///  -> All the functions
    ‚îÇ
    ‚îú‚îÄ Front-end
    ‚îú‚îÄ Suggestion box (or completion)
    ‚îú‚îÄ Parsers
    ‚îÇ   ‚îú‚îÄ For input
    ‚îÇ   ‚îî‚îÄ For parameters
    ‚îú‚îÄ Convert text
    ‚îÇ   ‚îú‚îÄ Main functions
    ‚îÇ   ‚îî‚îÄ Used by main functions
    ‚îú‚îÄ Check mistakes
    ‚îú‚îÄ Matrix document class
    ‚îú‚îÄ Automatic spacing
    ‚îî‚îÄ Main
*/


/**************************************************************************************/


/// TYPES ///

// Used for most object
interface obj {
    [key: string]: string;
};

type fct = ((arg: string[], initialCommand: string, forFrac?: boolean) => string | string[]);  // For objwF (object with functions)

// Used for MATHDICTIONARY, where some commands return function
interface objwF {
    [key: string]: string | fct;
};

// Used by the parser
interface objLA {
    [key: number]: any[];  // object with loose array
};

interface objA {
    [key: string]: any  // object with any type
}

function Str(a: any): string {
    // Type checking
    if (typeof a === "string") {
        return a;
    } else {
        throw "Parameter is not a string"
    };
};

function Fct(a: any): Function {
    // Type checking
    if (typeof a === "function") {
        return a;
    } else {
        throw "Parameter is not a function"
    };
};

// Used by the parser
interface Token {
    command: string;  // stores the command
    mathmode: boolean;  // true if inside $ $, $$ $$, or \[ \]
    depth: number;  // is used to know if the symbol is an argument or not
    /*
        depth structure:
            - parseInput: \0{\1{\2{\3{...}}}}
            - parseSetting: \0[1]{2}
    */
};


/**************************************************************************************/


/// GLOBALS ///

/** Functions (as const) **/

const mathbb = (arg: string[], initialCommand: string): string => {
    // mathbb stands for math blackboard-bold
    // This function converts the list of characters to the corresponding blackboard-bold character
    const symbols: obj = {
        "A" : "\u{1D538}",
        "B" : "\u{1D539}",
        "C" : "\u2102",
        "D" : "\u{1D53B}",
        "E" : "\u{1D53C}",
        "F" : "\u{1D53D}",
        "G" : "\u{1D53E}",
        "H" : "\u210D",
        "I" : "\u{1D540}",
        "J" : "\u{1D541}",
        "K" : "\u{1D542}",
        "L" : "\u{1D543}",
        "M" : "\u{1D544}",
        "N" : "\u2115",
        "O" : "\u{1D546}",
        "P" : "\u2119",
        "Q" : "\u211A",
        "R" : "\u211D",
        "S" : "\u{1D54A}",
        "T" : "\u{1D54B}",
        "U" : "\u{1D54C}",
        "V" : "\u{1D54D}",
        "W" : "\u{1D54E}",
        "X" : "\u{1D54F}",
        "Y" : "\u{1D550}",
        "Z" : "\u2124",
        "a" : "\u{1D552}",
        "b" : "\u{1D553}",
        "c" : "\u{1D554}",
        "d" : "\u{1D555}",
        "e" : "\u{1D556}",
        "f" : "\u{1D557}",
        "g" : "\u{1D558}",
        "h" : "\u{1D559}",
        "i" : "\u{1D55A}",
        "j" : "\u{1D55B}",
        "k" : "\u{1D55C}",
        "l" : "\u{1D55D}",
        "m" : "\u{1D55E}",
        "n" : "\u{1D55F}",
        "o" : "\u{1D560}",
        "p" : "\u{1D561}",
        "q" : "\u{1D562}",
        "r" : "\u{1D563}",
        "s" : "\u{1D564}",
        "t" : "\u{1D565}",
        "u" : "\u{1D566}",
        "v" : "\u{1D567}",
        "w" : "\u{1D568}",
        "x" : "\u{1D569}",
        "y" : "\u{1D56A}",
        "z" : "\u{1D56B}",

        "ùê¥" : "\u{1D538}",
        "ùêµ" : "\u{1D539}",
        "ùê∂" : "\u2102",
        "ùê∑" : "\u{1D53B}",
        "ùê∏" : "\u{1D53C}",
        "ùêπ" : "\u{1D53D}",
        "ùê∫" : "\u{1D53E}",
        "ùêª" : "\u210D",
        "ùêº" : "\u{1D540}",
        "ùêΩ" : "\u{1D541}",
        "ùêæ" : "\u{1D542}",
        "ùêø" : "\u{1D543}",
        "ùëÄ" : "\u{1D544}",
        "ùëÅ" : "\u2115",
        "ùëÇ" : "\u{1D546}",
        "ùëÉ" : "\u2119",
        "ùëÑ" : "\u211A",
        "ùëÖ" : "\u211D",
        "ùëÜ" : "\u{1D54A}",
        "ùëá" : "\u{1D54B}",
        "ùëà" : "\u{1D54C}",
        "ùëâ" : "\u{1D54D}",
        "ùëä" : "\u{1D54E}",
        "ùëã" : "\u{1D54F}",
        "ùëå" : "\u{1D550}",
        "ùëç" : "\u2124",
        "ùëé" : "\u{1D552}",
        "ùëè" : "\u{1D553}",
        "ùëê" : "\u{1D554}",
        "ùëë" : "\u{1D555}",
        "ùëí" : "\u{1D556}",
        "ùëì" : "\u{1D557}",
        "ùëî" : "\u{1D558}",
        "‚Ñé" : "\u{1D559}",
        "ùëñ" : "\u{1D55A}",
        "ùëó" : "\u{1D55B}",
        "ùëò" : "\u{1D55C}",
        "ùëô" : "\u{1D55D}",
        "ùëö" : "\u{1D55E}",
        "ùëõ" : "\u{1D55F}",
        "ùëú" : "\u{1D560}",
        "ùëù" : "\u{1D561}",
        "ùëû" : "\u{1D562}",
        "ùëü" : "\u{1D563}",
        "ùë†" : "\u{1D564}",
        "ùë°" : "\u{1D565}",
        "ùë¢" : "\u{1D566}",
        "ùë£" : "\u{1D567}",
        "ùë§" : "\u{1D568}",
        "ùë•" : "\u{1D569}",
        "ùë¶" : "\u{1D56A}",
        "ùëß" : "\u{1D56B}",
        
        "ùõæ" : "\u213D",
        "ùõ§" : "\u213E",
        "ùõ±" : "\u213F",
        "ùúã" : "\u213C",
        "ùõ¥" : "\u2140",
        "Œ£" : "\u2140",
        "Œ†" : "\u213F",
        "œÄ" : "\u213C",
        "Œ≥" : "\u213D",
        "Œì" : "\u213E",

        "0" : "\u{1D7D8}",
        "1" : "\u{1D7D9}",
        "2" : "\u{1D7DA}",
        "3" : "\u{1D7DB}",
        "4" : "\u{1D7DC}",
        "5" : "\u{1D7DD}",
        "6" : "\u{1D7DE}",
        "7" : "\u{1D7DF}",
        "8" : "\u{1D7E0}",
        "9" : "\u{1D7E1}",

        "(" : "‚¶Ö",
        "{" : "‚¶É",
        "[" : "‚ü¶",
        "]" : "‚üß",
        "}" : "‚¶Ñ",
        ")" : "‚¶Ü",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathbf = (arg: string[], initialCommand: string): string => {
    // mathbf stands for math bold font
    // This function converts the list of characters to the corresponding bold font character
    const symbols: obj = {
        "A" : "\u{1D468}",
        "a" : "\u{1D482}",
        "B" : "\u{1D469}",
        "b" : "\u{1D483}",
        "C" : "\u{1D46A}",
        "c" : "\u{1D484}",
        "D" : "\u{1D46B}",
        "d" : "\u{1D485}",
        "E" : "\u{1D46C}",
        "e" : "\u{1D486}",
        "F" : "\u{1D46D}",
        "f" : "\u{1D487}",
        "G" : "\u{1D46E}",
        "g" : "\u{1D488}",
        "H" : "\u{1D46F}",
        "h" : "\u{1D489}",
        "I" : "\u{1D470}",
        "i" : "\u{1D48A}",
        "J" : "\u{1D471}",
        "j" : "\u{1D48B}",
        "K" : "\u{1D472}",
        "k" : "\u{1D48C}",
        "L" : "\u{1D473}",
        "l" : "\u{1D48D}",
        "M" : "\u{1D474}",
        "m" : "\u{1D48E}",
        "N" : "\u{1D475}",
        "n" : "\u{1D48F}",
        "O" : "\u{1D476}",
        "o" : "\u{1D490}",
        "P" : "\u{1D477}",
        "p" : "\u{1D491}",
        "Q" : "\u{1D478}",
        "q" : "\u{1D492}",
        "R" : "\u{1D479}",
        "r" : "\u{1D493}",
        "S" : "\u{1D47A}",
        "s" : "\u{1D494}",
        "T" : "\u{1D47B}",
        "t" : "\u{1D495}",
        "U" : "\u{1D47C}",
        "u" : "\u{1D496}",
        "V" : "\u{1D47D}",
        "v" : "\u{1D497}",
        "W" : "\u{1D47E}",
        "w" : "\u{1D498}",
        "X" : "\u{1D47F}",
        "x" : "\u{1D499}",
        "Y" : "\u{1D480}",
        "y" : "\u{1D49A}",
        "Z" : "\u{1D481}",
        "z" : "\u{1D49B}",

        "ùê¥" : "\u{1D468}",
        "ùëé" : "\u{1D482}",
        "ùêµ" : "\u{1D469}",
        "ùëè" : "\u{1D483}",
        "ùê∂" : "\u{1D46A}",
        "ùëê" : "\u{1D484}",
        "ùê∑" : "\u{1D46B}",
        "ùëë" : "\u{1D485}",
        "ùê∏" : "\u{1D46C}",
        "ùëí" : "\u{1D486}",
        "ùêπ" : "\u{1D46D}",
        "ùëì" : "\u{1D487}",
        "ùê∫" : "\u{1D46E}",
        "ùëî" : "\u{1D488}",
        "ùêª" : "\u{1D46F}",
        "‚Ñé" : "\u{1D489}",
        "ùêº" : "\u{1D470}",
        "ùëñ" : "\u{1D48A}",
        "ùêΩ" : "\u{1D471}",
        "ùëó" : "\u{1D48B}",
        "ùêæ" : "\u{1D472}",
        "ùëò" : "\u{1D48C}",
        "ùêø" : "\u{1D473}",
        "ùëô" : "\u{1D48D}",
        "ùëÄ" : "\u{1D474}",
        "ùëö" : "\u{1D48E}",
        "ùëÅ" : "\u{1D475}",
        "ùëõ" : "\u{1D48F}",
        "ùëÇ" : "\u{1D476}",
        "ùëú" : "\u{1D490}",
        "ùëÉ" : "\u{1D477}",
        "ùëù" : "\u{1D491}",
        "ùëÑ" : "\u{1D478}",
        "ùëû" : "\u{1D492}",
        "ùëÖ" : "\u{1D479}",
        "ùëü" : "\u{1D493}",
        "ùëÜ" : "\u{1D47A}",
        "ùë†" : "\u{1D494}",
        "ùëá" : "\u{1D47B}",
        "ùë°" : "\u{1D495}",
        "ùëà" : "\u{1D47C}",
        "ùë¢" : "\u{1D496}",
        "ùëâ" : "\u{1D47D}",
        "ùë£" : "\u{1D497}",
        "ùëä" : "\u{1D47E}",
        "ùë§" : "\u{1D498}",
        "ùëã" : "\u{1D47F}",
        "ùë•" : "\u{1D499}",
        "ùëå" : "\u{1D480}",
        "ùë¶" : "\u{1D49A}",
        "ùëç" : "\u{1D481}",
        "ùëß" : "\u{1D49B}",

        "0" : "\u{1D7CE}",
        "1" : "\u{1D7CF}",
        "2" : "\u{1D7D0}",
        "3" : "\u{1D7D1}",
        "4" : "\u{1D7D2}",
        "5" : "\u{1D7D3}",
        "6" : "\u{1D7D4}",
        "7" : "\u{1D7D5}",
        "8" : "\u{1D7D6}",
        "9" : "\u{1D7D7}",

        "‚àÇ" : "\u{1D789}",

	    // Greek
        "ùõ¢" : "\u{1D71C}",
        "ùõº" : "\u{1D736}",
        "ùõ£" : "\u{1D71D}",
        "ùõΩ" : "\u{1D737}",
        "ùõ§" : "\u{1D71E}",
        "ùõæ" : "\u{1D738}",
        "Œî" : "\u{1D6AB}",
        "ùõ•" : "\u{1D71F}",
        "ùõø" : "\u{1D739}",
        "ùõ¶" : "\u{1D720}",
        "œµ" : "\u{1D6DC}",
        "Œµ" : "\u{1D6C6}",
        "ùõß" : "\u{1D721}",
        "ùúÅ" : "\u{1D73B}",
        "ùõ®" : "\u{1D722}",
        "ùúÇ" : "\u{1D73C}",
        "Œò" : "\u{1D6BD}",
        "ùúÉ" : "\u{1D73D}",
        "ùúó" : "\u{1D751}",
        "ùõ™" : "\u{1D724}",
        "ùúÑ" : "\u{1D73E}",
        "ùõ´" : "\u{1D725}",
        "ùúÖ" : "\u{1D73F}",
        "ùúò" : "\u{1D752}",
        "ùõ¨" : "\u{1D726}",
        "ùúÜ" : "\u{1D740}",
        "ùõ≠" : "\u{1D727}",
        "ùúá" : "\u{1D741}",
        "ùõÆ" : "\u{1D728}",
        "ùúà" : "\u{1D742}",
        "Œû" : "\u{1D6B5}",
        "ùúâ" : "\u{1D743}",
        "ùõ∞" : "\u{1D72A}",
        "ùúä" : "\u{1D744}",
        "ùõ±" : "\u{1D72B}",
        "ùúã" : "\u{1D745}",
        "ùúõ" : "\u{1D755}",
        "ùõ≤" : "\u{1D72C}",
        "ùúå" : "\u{1D746}",
        "ùúö" : "\u{1D754}",
        "ùõ¥" : "\u{1D72E}",
        "ùúé" : "\u{1D748}",
        "ùúç" : "\u{1D747}",
        "ùõµ" : "\u{1D72F}",
        "ùúè" : "\u{1D749}",
        "ùõ∂" : "\u{1D730}",
        "ùúê" : "\u{1D74A}",
        "Œ¶" : "\u{1D6BD}",
        "ùúô" : "\u{1D753}",
        "ùúë" : "\u{1D74B}",
        "ùõ∏" : "\u{1D732}",
        "ùúí" : "\u{1D74C}",
        "ùõπ" : "\u{1D733}",
        "ùúì" : "\u{1D74D}",
        "‚Ñ¶" : "\u{1D6C0}",
        "ùúî" : "\u{1D74E}",

        "Œë" : "\u{1D756}",
        "Œ±" : "\u{1D770}",
        "Œí" : "\u{1D757}",
        "Œ≤" : "\u{1D771}",
        "Œì" : "\u{1D758}",
        "Œ≥" : "\u{1D772}",
        "Œ¥" : "\u{1D6C5}",
        "Œï" : "\u{1D75A}",
        "Œñ" : "\u{1D75B}",
        "Œ∂" : "\u{1D775}",
        "Œó" : "\u{1D75C}",
        "Œ∑" : "\u{1D776}",
        "Œ∏" : "\u{1D6C9}",
        "œë" : "\u{1D6DD}",
        "Œô" : "\u{1D75E}",
        "Œπ" : "\u{1D6CA}",
        "Œö" : "\u{1D75F}",
        "Œ∫" : "\u{1D779}",
        "œ∞" : "\u{1D78C}",
        "Œõ" : "\u{1D760}",
        "Œª" : "\u{1D77A}",
        "Œú" : "\u{1D761}",
        "Œº" : "\u{1D77B}",
        "Œù" : "\u{1D762}",
        "ŒΩ" : "\u{1D77C}",
        "Œæ" : "\u{1D77D}",
        "Œü" : "\u{1D764}",
        "Œø" : "\u{1D77E}",
        "Œ†" : "\u{1D765}",
        "œÄ" : "\u{1D77F}",
        "œñ" : "\u{1D78F}",
        "Œ°" : "\u{1D766}",
        "œÅ" : "\u{1D780}",
        "œ±" : "\u{1D78E}",
        "Œ£" : "\u{1D768}",
        "œÉ" : "\u{1D782}",
        "œÇ" : "\u{1D781}",
        "Œ§" : "\u{1D769}",
        "œÑ" : "\u{1D783}",
        "Œ•" : "\u{1D76A}",
        "œÖ" : "\u{1D784}",
        "œï" : "\u{1D78D}",
        "œÜ" : "\u{1D785}",
        "Œß" : "\u{1D76C}",
        "œá" : "\u{1D786}",
        "Œ®" : "\u{1D76D}",
        "œà" : "\u{1D787}",
        "Œ©" : "\u{1D76E}",
        "œâ" : "\u{1D788}",

        // mathcal
        "ùíú" : "\u{1D4D0}",
        "ùí∂" : "\u{1D4EA}",
        "‚Ñ¨" : "\u{1D4D1}",
        "ùí∑" : "\u{1D4EB}",
        "ùíû" : "\u{1D4D2}",
        "ùí∏" : "\u{1D4EC}",
        "ùíü" : "\u{1D4D3}",
        "ùíπ" : "\u{1D4ED}",
        "‚Ñ∞" : "\u{1D4D4}",
        "‚ÑØ" : "\u{1D4EE}",
        "‚Ñ±" : "\u{1D4D5}",
        "ùíª" : "\u{1D4EF}",
        "ùí¢" : "\u{1D4D6}",
        "‚Ñä" : "\u{1D4F0}",
        "‚Ñã" : "\u{1D4D7}",
        "ùíΩ" : "\u{1D4F1}",
        "‚Ñê" : "\u{1D4D8}",
        "ùíæ" : "\u{1D4F2}",
        "ùí•" : "\u{1D4D9}",
        "ùíø" : "\u{1D4F3}",
        "ùí¶" : "\u{1D4DA}",
        "ùìÄ" : "\u{1D4F4}",
        "‚Ñí" : "\u{1D4DB}",
        "ùìÅ" : "\u{1D4F5}",
        "‚Ñ≥" : "\u{1D4DC}",
        "ùìÇ" : "\u{1D4F6}",
        "ùí©" : "\u{1D4DD}",
        "ùìÉ" : "\u{1D4F7}",
        "ùí™" : "\u{1D4DE}",
        "‚Ñ¥" : "\u{1D4F8}",
        "ùí´" : "\u{1D4DF}",
        "ùìÖ" : "\u{1D4F9}",
        "ùí¨" : "\u{1D4E0}",
        "ùìÜ" : "\u{1D4FA}",
        "‚Ñõ" : "\u{1D4E1}",
        "ùìá" : "\u{1D4FB}",
        "ùíÆ" : "\u{1D4E2}",
        "ùìà" : "\u{1D4FC}",
        "ùíØ" : "\u{1D4E3}",
        "ùìâ" : "\u{1D4FD}",
        "ùí∞" : "\u{1D4E4}",
        "ùìä" : "\u{1D4FE}",
        "ùí±" : "\u{1D4E5}",
        "ùìã" : "\u{1D4FF}",
        "ùí≤" : "\u{1D4E6}",
        "ùìå" : "\u{1D500}",
        "ùí≥" : "\u{1D4E7}",
        "ùìç" : "\u{1D501}",
        "ùí¥" : "\u{1D4E8}",
        "ùìé" : "\u{1D502}",
        "ùíµ" : "\u{1D4E9}",
        "ùìè" : "\u{1D503}",

        // mathfrak
        "ùîÑ" : "\u{1D56C}",
        "ùîû" : "\u{1D586}",
        "ùîÖ" : "\u{1D56D}",
        "ùîü" : "\u{1D587}",
        "‚Ñ≠" : "\u{1D56E}",
        "ùî†" : "\u{1D588}",
        "ùîá" : "\u{1D56F}",
        "ùî°" : "\u{1D589}",
        "ùîà" : "\u{1D570}",
        "ùî¢" : "\u{1D58A}",
        "ùîâ" : "\u{1D571}",
        "ùî£" : "\u{1D58B}",
        "ùîä" : "\u{1D572}",
        "ùî§" : "\u{1D58C}",
        "‚Ñå" : "\u{1D573}",
        "ùî•" : "\u{1D58D}",
        "‚Ñë" : "\u{1D574}",
        "ùî¶" : "\u{1D58E}",
        "ùîç" : "\u{1D575}",
        "ùîß" : "\u{1D58F}",
        "ùîé" : "\u{1D576}",
        "ùî®" : "\u{1D590}",
        "ùîè" : "\u{1D577}",
        "ùî©" : "\u{1D591}",
        "ùîê" : "\u{1D578}",
        "ùî™" : "\u{1D592}",
        "ùîë" : "\u{1D579}",
        "ùî´" : "\u{1D593}",
        "ùîí" : "\u{1D57A}",
        "ùî¨" : "\u{1D594}",
        "ùîì" : "\u{1D57B}",
        "ùî≠" : "\u{1D595}",
        "ùîî" : "\u{1D57C}",
        "ùîÆ" : "\u{1D596}",
        "‚Ñú" : "\u{1D57D}",
        "ùîØ" : "\u{1D597}",
        "ùîñ" : "\u{1D57E}",
        "ùî∞" : "\u{1D598}",
        "ùîó" : "\u{1D57F}",
        "ùî±" : "\u{1D599}",
        "ùîò" : "\u{1D580}",
        "ùî≤" : "\u{1D59A}",
        "ùîô" : "\u{1D581}",
        "ùî≥" : "\u{1D59B}",
        "ùîö" : "\u{1D582}",
        "ùî¥" : "\u{1D59C}",
        "ùîõ" : "\u{1D583}",
        "ùîµ" : "\u{1D59D}",
        "ùîú" : "\u{1D584}",
        "ùî∂" : "\u{1D59E}",
        "‚Ñ®" : "\u{1D585}",
        "ùî∑" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathcal = (arg: string[], initialCommand: string): string => {
    // mathcal stands for math calligraphic
    // This function converts the list of characters to the corresponding calligraphic character
    const symbols: obj = {
        "A" : "\u{1D49C}",
        "a" : "\u{1D4B6}",
        "B" : "\u212C",
        "b" : "\u{1D4B7}",
        "C" : "\u{1D49E}",
        "c" : "\u{1D4B8}",
        "D" : "\u{1D49F}",
        "d" : "\u{1D4B9}",
        "E" : "\u2130",
        "e" : "\u212F",
        "F" : "\u2131",
        "f" : "\u{1D4BB}",
        "G" : "\u{1D4A2}",
        "g" : "\u210A",
        "H" : "\u210B",
        "h" : "\u{1D4BD}",
        "I" : "\u2110",
        "i" : "\u{1D4BE}",
        "J" : "\u{1D4A5}",
        "j" : "\u{1D4BF}",
        "K" : "\u{1D4A6}",
        "k" : "\u{1D4C0}",
        "L" : "\u2112",
        "l" : "\u{1D4C1}",
        "M" : "\u2133",
        "m" : "\u{1D4C2}",
        "N" : "\u{1D4A9}",
        "n" : "\u{1D4C3}",
        "O" : "\u{1D4AA}",
        "o" : "\u2134",
        "P" : "\u{1D4AB}",
        "p" : "\u{1D4C5}",
        "Q" : "\u{1D4AC}",
        "q" : "\u{1D4C6}",
        "R" : "\u211B",
        "r" : "\u{1D4C7}",
        "S" : "\u{1D4AE}",
        "s" : "\u{1D4C8}",
        "T" : "\u{1D4AF}",
        "t" : "\u{1D4C9}",
        "U" : "\u{1D4B0}",
        "u" : "\u{1D4CA}",
        "V" : "\u{1D4B1}",
        "v" : "\u{1D4CB}",
        "W" : "\u{1D4B2}",
        "w" : "\u{1D4CC}",
        "X" : "\u{1D4B3}",
        "x" : "\u{1D4CD}",
        "Y" : "\u{1D4B4}",
        "y" : "\u{1D4CE}",
        "Z" : "\u{1D4B5}",
        "z" : "\u{1D4CF}",

        "ùê¥" : "\u{1D49C}",
        "ùëé" : "\u{1D4B6}",
        "ùêµ" : "\u212C",
        "ùëè" : "\u{1D4B7}",
        "ùê∂" : "\u{1D49E}",
        "ùëê" : "\u{1D4B8}",
        "ùê∑" : "\u{1D49F}",
        "ùëë" : "\u{1D4B9}",
        "ùê∏" : "\u2130",
        "ùëí" : "\u212F",
        "ùêπ" : "\u2131",
        "ùëì" : "\u{1D4BB}",
        "ùê∫" : "\u{1D4A2}",
        "ùëî" : "\u210A",
        "ùêª" : "\u210B",
        "‚Ñé" : "\u{1D4BD}",
        "ùêº" : "\u2110",
        "ùëñ" : "\u{1D4BE}",
        "ùêΩ" : "\u{1D4A5}",
        "ùëó" : "\u{1D4BF}",
        "ùêæ" : "\u{1D4A6}",
        "ùëò" : "\u{1D4C0}",
        "ùêø" : "\u2112",
        "ùëô" : "\u{1D4C1}",
        "ùëÄ" : "\u2133",
        "ùëö" : "\u{1D4C2}",
        "ùëÅ" : "\u{1D4A9}",
        "ùëõ" : "\u{1D4C3}",
        "ùëÇ" : "\u{1D4AA}",
        "ùëú" : "\u2134",
        "ùëÉ" : "\u{1D4AB}",
        "ùëù" : "\u{1D4C5}",
        "ùëÑ" : "\u{1D4AC}",
        "ùëû" : "\u{1D4C6}",
        "ùëÖ" : "\u211B",
        "ùëü" : "\u{1D4C7}",
        "ùëÜ" : "\u{1D4AE}",
        "ùë†" : "\u{1D4C8}",
        "ùëá" : "\u{1D4AF}",
        "ùë°" : "\u{1D4C9}",
        "ùëà" : "\u{1D4B0}",
        "ùë¢" : "\u{1D4CA}",
        "ùëâ" : "\u{1D4B1}",
        "ùë£" : "\u{1D4CB}",
        "ùëä" : "\u{1D4B2}",
        "ùë§" : "\u{1D4CC}",
        "ùëã" : "\u{1D4B3}",
        "ùë•" : "\u{1D4CD}",
        "ùëå" : "\u{1D4B4}",
        "ùë¶" : "\u{1D4CE}",
        "ùëç" : "\u{1D4B5}",
        "ùëß" : "\u{1D4CF}",

        "ùë®" : "\u{1D4D0}",
        "ùíÇ" : "\u{1D4EA}",
        "ùë©" : "\u{1D4D1}",
        "ùíÉ" : "\u{1D4EB}",
        "ùë™" : "\u{1D4D2}",
        "ùíÑ" : "\u{1D4EC}",
        "ùë´" : "\u{1D4D3}",
        "ùíÖ" : "\u{1D4ED}",
        "ùë¨" : "\u{1D4D4}",
        "ùíÜ" : "\u{1D4EE}",
        "ùë≠" : "\u{1D4D5}",
        "ùíá" : "\u{1D4EF}",
        "ùëÆ" : "\u{1D4D6}",
        "ùíà" : "\u{1D4F0}",
        "ùëØ" : "\u{1D4D7}",
        "ùíâ" : "\u{1D4F1}",
        "ùë∞" : "\u{1D4D8}",
        "ùíä" : "\u{1D4F2}",
        "ùë±" : "\u{1D4D9}",
        "ùíã" : "\u{1D4F3}",
        "ùë≤" : "\u{1D4DA}",
        "ùíå" : "\u{1D4F4}",
        "ùë≥" : "\u{1D4DB}",
        "ùíç" : "\u{1D4F5}",
        "ùë¥" : "\u{1D4DC}",
        "ùíé" : "\u{1D4F6}",
        "ùëµ" : "\u{1D4DD}",
        "ùíè" : "\u{1D4F7}",
        "ùë∂" : "\u{1D4DE}",
        "ùíê" : "\u{1D4F8}",
        "ùë∑" : "\u{1D4DF}",
        "ùíë" : "\u{1D4F9}",
        "ùë∏" : "\u{1D4E0}",
        "ùíí" : "\u{1D4FA}",
        "ùëπ" : "\u{1D4E1}",
        "ùíì" : "\u{1D4FB}",
        "ùë∫" : "\u{1D4E2}",
        "ùíî" : "\u{1D4FC}",
        "ùëª" : "\u{1D4E3}",
        "ùíï" : "\u{1D4FD}",
        "ùëº" : "\u{1D4E4}",
        "ùíñ" : "\u{1D4FE}",
        "ùëΩ" : "\u{1D4E5}",
        "ùíó" : "\u{1D4FF}",
        "ùëæ" : "\u{1D4E6}",
        "ùíò" : "\u{1D500}",
        "ùëø" : "\u{1D4E7}",
        "ùíô" : "\u{1D501}",
        "ùíÄ" : "\u{1D4E8}",
        "ùíö" : "\u{1D502}",
        "ùíÅ" : "\u{1D4E9}",
        "ùíõ" : "\u{1D503}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathfrak = (arg: string[], initialCommand: string): string => {
    // mathfrak stands for math fraktur
    // This function converts the list of characters to the corresponding fraktur character
    const symbols: obj = {
        "A" : "\u{1D504}",
        "a" : "\u{1D51E}",
        "B" : "\u{1D505}",
        "b" : "\u{1D51F}",
        "C" : "\u212D",
        "c" : "\u{1D520}",
        "D" : "\u{1D507}",
        "d" : "\u{1D521}",
        "E" : "\u{1D508}",
        "e" : "\u{1D522}",
        "F" : "\u{1D509}",
        "f" : "\u{1D523}",
        "G" : "\u{1D50A}",
        "g" : "\u{1D524}",
        "H" : "\u210C",
        "h" : "\u{1D525}",
        "I" : "\u2111",
        "i" : "\u{1D526}",
        "J" : "\u{1D50D}",
        "j" : "\u{1D527}",
        "K" : "\u{1D50E}",
        "k" : "\u{1D528}",
        "L" : "\u{1D50F}",
        "l" : "\u{1D529}",
        "M" : "\u{1D510}",
        "m" : "\u{1D52A}",
        "N" : "\u{1D511}",
        "n" : "\u{1D52B}",
        "O" : "\u{1D512}",
        "o" : "\u{1D52C}",
        "P" : "\u{1D513}",
        "p" : "\u{1D52D}",
        "Q" : "\u{1D514}",
        "q" : "\u{1D52E}",
        "R" : "\u211C",
        "r" : "\u{1D52F}",
        "S" : "\u{1D516}",
        "s" : "\u{1D530}",
        "T" : "\u{1D517}",
        "t" : "\u{1D531}",
        "U" : "\u{1D518}",
        "u" : "\u{1D532}",
        "V" : "\u{1D519}",
        "v" : "\u{1D533}",
        "W" : "\u{1D51A}",
        "w" : "\u{1D534}",
        "X" : "\u{1D51B}",
        "x" : "\u{1D535}",
        "Y" : "\u{1D51C}",
        "y" : "\u{1D536}",
        "Z" : "\u2128",
        "z" : "\u{1D537}",

        "ùê¥" : "\u{1D504}",
        "ùëé" : "\u{1D51E}",
        "ùêµ" : "\u{1D505}",
        "ùëè" : "\u{1D51F}",
        "ùê∂" : "\u212D",
        "ùëê" : "\u{1D520}",
        "ùê∑" : "\u{1D507}",
        "ùëë" : "\u{1D521}",
        "ùê∏" : "\u{1D508}",
        "ùëí" : "\u{1D522}",
        "ùêπ" : "\u{1D509}",
        "ùëì" : "\u{1D523}",
        "ùê∫" : "\u{1D50A}",
        "ùëî" : "\u{1D524}",
        "ùêª" : "\u210C",
        "‚Ñé" : "\u{1D525}",
        "ùêº" : "\u2111",
        "ùëñ" : "\u{1D526}",
        "ùêΩ" : "\u{1D50D}",
        "ùëó" : "\u{1D527}",
        "ùêæ" : "\u{1D50E}",
        "ùëò" : "\u{1D528}",
        "ùêø" : "\u{1D50F}",
        "ùëô" : "\u{1D529}",
        "ùëÄ" : "\u{1D510}",
        "ùëö" : "\u{1D52A}",
        "ùëÅ" : "\u{1D511}",
        "ùëõ" : "\u{1D52B}",
        "ùëÇ" : "\u{1D512}",
        "ùëú" : "\u{1D52C}",
        "ùëÉ" : "\u{1D513}",
        "ùëù" : "\u{1D52D}",
        "ùëÑ" : "\u{1D514}",
        "ùëû" : "\u{1D52E}",
        "ùëÖ" : "\u211C",
        "ùëü" : "\u{1D52F}",
        "ùëÜ" : "\u{1D516}",
        "ùë†" : "\u{1D530}",
        "ùëá" : "\u{1D517}",
        "ùë°" : "\u{1D531}",
        "ùëà" : "\u{1D518}",
        "ùë¢" : "\u{1D532}",
        "ùëâ" : "\u{1D519}",
        "ùë£" : "\u{1D533}",
        "ùëä" : "\u{1D51A}",
        "ùë§" : "\u{1D534}",
        "ùëã" : "\u{1D51B}",
        "ùë•" : "\u{1D535}",
        "ùëå" : "\u{1D51C}",
        "ùë¶" : "\u{1D536}",
        "ùëç" : "\u2128",
        "ùëß" : "\u{1D537}",

        "ùë®" : "\u{1D56C}",
        "ùíÇ" : "\u{1D586}",
        "ùë©" : "\u{1D56D}",
        "ùíÉ" : "\u{1D587}",
        "ùë™" : "\u{1D56E}",
        "ùíÑ" : "\u{1D588}",
        "ùë´" : "\u{1D56F}",
        "ùíÖ" : "\u{1D589}",
        "ùë¨" : "\u{1D570}",
        "ùíÜ" : "\u{1D58A}",
        "ùë≠" : "\u{1D571}",
        "ùíá" : "\u{1D58B}",
        "ùëÆ" : "\u{1D572}",
        "ùíà" : "\u{1D58C}",
        "ùëØ" : "\u{1D573}",
        "ùíâ" : "\u{1D58D}",
        "ùë∞" : "\u{1D574}",
        "ùíä" : "\u{1D58E}",
        "ùë±" : "\u{1D575}",
        "ùíã" : "\u{1D58F}",
        "ùë≤" : "\u{1D576}",
        "ùíå" : "\u{1D590}",
        "ùë≥" : "\u{1D577}",
        "ùíç" : "\u{1D591}",
        "ùë¥" : "\u{1D578}",
        "ùíé" : "\u{1D592}",
        "ùëµ" : "\u{1D579}",
        "ùíè" : "\u{1D593}",
        "ùë∂" : "\u{1D57A}",
        "ùíê" : "\u{1D594}",
        "ùë∑" : "\u{1D57B}",
        "ùíë" : "\u{1D595}",
        "ùë∏" : "\u{1D57C}",
        "ùíí" : "\u{1D596}",
        "ùëπ" : "\u{1D57D}",
        "ùíì" : "\u{1D597}",
        "ùë∫" : "\u{1D57E}",
        "ùíî" : "\u{1D598}",
        "ùëª" : "\u{1D57F}",
        "ùíï" : "\u{1D599}",
        "ùëº" : "\u{1D580}",
        "ùíñ" : "\u{1D59A}",
        "ùëΩ" : "\u{1D581}",
        "ùíó" : "\u{1D59B}",
        "ùëæ" : "\u{1D582}",
        "ùíò" : "\u{1D59C}",
        "ùëø" : "\u{1D583}",
        "ùíô" : "\u{1D59D}",
        "ùíÄ" : "\u{1D584}",
        "ùíö" : "\u{1D59E}",
        "ùíÅ" : "\u{1D585}",
        "ùíõ" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const superscript = (arg: string[], initialCommand: string, forFrac=false): string => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg, SUPERSCRIPT, initialCommand, !forFrac);
    if ((output.indexOf("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") === -1) || (forFrac)) {
        return output;
    } else {
        return "^(" + arg.join("") + ")";
    };
};

const subscript = (arg: string[], initialCommand: string, forFrac=false): string => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg, SUBSCRIPT, initialCommand, !forFrac);
    if ((output.indexOf("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") === -1) || (forFrac)) {
        return output;
    } else {
        return "_(" + arg.join("") + ")";
    };
};

const textbf = (arg: string[], initialCommand: string): string => {
    // textbf stands for text bold font
    // This function converts the list of characters to the corresponding (text) bold font character
	const symbols: obj = {
        "A" : "\u{1D5D4}",
        "a" : "\u{1D5EE}",
        "B" : "\u{1D5D5}",
        "b" : "\u{1D5EF}",
        "C" : "\u{1D5D6}",
        "c" : "\u{1D5F0}",
        "D" : "\u{1D5D7}",
        "d" : "\u{1D5F1}",
        "E" : "\u{1D5D8}",
        "e" : "\u{1D5F2}",
        "F" : "\u{1D5D9}",
        "f" : "\u{1D5F3}",
        "G" : "\u{1D5DA}",
        "g" : "\u{1D5F4}",
        "H" : "\u{1D5DB}",
        "h" : "\u{1D5F5}",
        "I" : "\u{1D5DC}",
        "i" : "\u{1D5F6}",
        "J" : "\u{1D5DD}",
        "j" : "\u{1D5F7}",
        "K" : "\u{1D5DE}",
        "k" : "\u{1D5F8}",
        "L" : "\u{1D5DF}",
        "l" : "\u{1D5F9}",
        "M" : "\u{1D5E0}",
        "m" : "\u{1D5FA}",
        "N" : "\u{1D5E1}",
        "n" : "\u{1D5FB}",
        "O" : "\u{1D5E2}",
        "o" : "\u{1D5FC}",
        "P" : "\u{1D5E3}",
        "p" : "\u{1D5FD}",
        "Q" : "\u{1D5E4}",
        "q" : "\u{1D5FE}",
        "R" : "\u{1D5E5}",
        "r" : "\u{1D5FF}",
        "S" : "\u{1D5E6}",
        "s" : "\u{1D600}",
        "T" : "\u{1D5E7}",
        "t" : "\u{1D601}",
        "U" : "\u{1D5E8}",
        "u" : "\u{1D602}",
        "V" : "\u{1D5E9}",
        "v" : "\u{1D603}",
        "W" : "\u{1D5EA}",
        "w" : "\u{1D604}",
        "X" : "\u{1D5EB}",
        "x" : "\u{1D605}",
        "Y" : "\u{1D5EC}",
        "y" : "\u{1D606}",
        "Z" : "\u{1D5ED}",
        "z" : "\u{1D607}",

        "ùê¥" : "\u{1D5D4}",
        "ùëé" : "\u{1D5EE}",
        "ùêµ" : "\u{1D5D5}",
        "ùëè" : "\u{1D5EF}",
        "ùê∂" : "\u{1D5D6}",
        "ùëê" : "\u{1D5F0}",
        "ùê∑" : "\u{1D5D7}",
        "ùëë" : "\u{1D5F1}",
        "ùê∏" : "\u{1D5D8}",
        "ùëí" : "\u{1D5F2}",
        "ùêπ" : "\u{1D5D9}",
        "ùëì" : "\u{1D5F3}",
        "ùê∫" : "\u{1D5DA}",
        "ùëî" : "\u{1D5F4}",
        "ùêª" : "\u{1D5DB}",
        "‚Ñé" : "\u{1D5F5}",
        "ùêº" : "\u{1D5DC}",
        "ùëñ" : "\u{1D5F6}",
        "ùêΩ" : "\u{1D5DD}",
        "ùëó" : "\u{1D5F7}",
        "ùêæ" : "\u{1D5DE}",
        "ùëò" : "\u{1D5F8}",
        "ùêø" : "\u{1D5DF}",
        "ùëô" : "\u{1D5F9}",
        "ùëÄ" : "\u{1D5E0}",
        "ùëö" : "\u{1D5FA}",
        "ùëÅ" : "\u{1D5E1}",
        "ùëõ" : "\u{1D5FB}",
        "ùëÇ" : "\u{1D5E2}",
        "ùëú" : "\u{1D5FC}",
        "ùëÉ" : "\u{1D5E3}",
        "ùëù" : "\u{1D5FD}",
        "ùëÑ" : "\u{1D5E4}",
        "ùëû" : "\u{1D5FE}",
        "ùëÖ" : "\u{1D5E5}",
        "ùëü" : "\u{1D5FF}",
        "ùëÜ" : "\u{1D5E6}",
        "ùë†" : "\u{1D600}",
        "ùëá" : "\u{1D5E7}",
        "ùë°" : "\u{1D601}",
        "ùëà" : "\u{1D5E8}",
        "ùë¢" : "\u{1D602}",
        "ùëâ" : "\u{1D5E9}",
        "ùë£" : "\u{1D603}",
        "ùëä" : "\u{1D5EA}",
        "ùë§" : "\u{1D604}",
        "ùëã" : "\u{1D5EB}",
        "ùë•" : "\u{1D605}",
        "ùëå" : "\u{1D5EC}",
        "ùë¶" : "\u{1D606}",
        "ùëç" : "\u{1D5ED}",
        "ùëß" : "\u{1D607}",

        "ùòà" : "\u{1D63C}",
        "ùò¢" : "\u{1D656}",
        "ùòâ" : "\u{1D63D}",
        "ùò£" : "\u{1D657}",
        "ùòä" : "\u{1D63E}",
        "ùò§" : "\u{1D658}",
        "ùòã" : "\u{1D63F}",
        "ùò•" : "\u{1D659}",
        "ùòå" : "\u{1D640}",
        "ùò¶" : "\u{1D65A}",
        "ùòç" : "\u{1D641}",
        "ùòß" : "\u{1D65B}",
        "ùòé" : "\u{1D642}",
        "ùò®" : "\u{1D65C}",
        "ùòè" : "\u{1D643}",
        "ùò©" : "\u{1D65D}",
        "ùòê" : "\u{1D644}",
        "ùò™" : "\u{1D65E}",
        "ùòë" : "\u{1D645}",
        "ùò´" : "\u{1D65F}",
        "ùòí" : "\u{1D646}",
        "ùò¨" : "\u{1D660}",
        "ùòì" : "\u{1D647}",
        "ùò≠" : "\u{1D661}",
        "ùòî" : "\u{1D648}",
        "ùòÆ" : "\u{1D662}",
        "ùòï" : "\u{1D649}",
        "ùòØ" : "\u{1D663}",
        "ùòñ" : "\u{1D64A}",
        "ùò∞" : "\u{1D664}",
        "ùòó" : "\u{1D64B}",
        "ùò±" : "\u{1D665}",
        "ùòò" : "\u{1D64C}",
        "ùò≤" : "\u{1D666}",
        "ùòô" : "\u{1D64D}",
        "ùò≥" : "\u{1D667}",
        "ùòö" : "\u{1D64E}",
        "ùò¥" : "\u{1D668}",
        "ùòõ" : "\u{1D64F}",
        "ùòµ" : "\u{1D669}",
        "ùòú" : "\u{1D650}",
        "ùò∂" : "\u{1D66A}",
        "ùòù" : "\u{1D651}",
        "ùò∑" : "\u{1D66B}",
        "ùòû" : "\u{1D652}",
        "ùò∏" : "\u{1D66C}",
        "ùòü" : "\u{1D653}",
        "ùòπ" : "\u{1D66D}",
        "ùò†" : "\u{1D654}",
        "ùò∫" : "\u{1D66E}",
        "ùò°" : "\u{1D655}",
        "ùòª" : "\u{1D66F}",

        "0" : "\u{1D7EC}",
        "1" : "\u{1D7ED}",
        "2" : "\u{1D7EE}",
        "3" : "\u{1D7EF}",
        "4" : "\u{1D7F0}",
        "5" : "\u{1D7F1}",
        "6" : "\u{1D7F2}",
        "7" : "\u{1D7F3}",
        "8" : "\u{1D7F4}",
        "9" : "\u{1D7F5}",

        // These symbols don't exist in textbf, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
		" " : "\u2710"
	};
	return replaceLetters(arg, symbols, initialCommand);
};

const textit = (arg: string[], initialCommand: string): string => {
    // textit stands for text italic
    // This function converts the list of characters to the corresponding italic character
    const symbols: obj = {
        "A" : "\u{1D608}",
        "a" : "\u{1D622}",
        "B" : "\u{1D609}",
        "b" : "\u{1D623}",
        "C" : "\u{1D60A}",
        "c" : "\u{1D624}",
        "D" : "\u{1D60B}",
        "d" : "\u{1D625}",
        "E" : "\u{1D60C}",
        "e" : "\u{1D626}",
        "F" : "\u{1D60D}",
        "f" : "\u{1D627}",
        "G" : "\u{1D60E}",
        "g" : "\u{1D628}",
        "H" : "\u{1D60F}",
        "h" : "\u{1D629}",
        "I" : "\u{1D610}",
        "i" : "\u{1D62A}",
        "J" : "\u{1D611}",
        "j" : "\u{1D62B}",
        "K" : "\u{1D612}",
        "k" : "\u{1D62C}",
        "L" : "\u{1D613}",
        "l" : "\u{1D62D}",
        "M" : "\u{1D614}",
        "m" : "\u{1D62E}",
        "N" : "\u{1D615}",
        "n" : "\u{1D62F}",
        "O" : "\u{1D616}",
        "o" : "\u{1D630}",
        "P" : "\u{1D617}",
        "p" : "\u{1D631}",
        "Q" : "\u{1D618}",
        "q" : "\u{1D632}",
        "R" : "\u{1D619}",
        "r" : "\u{1D633}",
        "S" : "\u{1D61A}",
        "s" : "\u{1D634}",
        "T" : "\u{1D61B}",
        "t" : "\u{1D635}",
        "U" : "\u{1D61C}",
        "u" : "\u{1D636}",
        "V" : "\u{1D61D}",
        "v" : "\u{1D637}",
        "W" : "\u{1D61E}",
        "w" : "\u{1D638}",
        "X" : "\u{1D61F}",
        "x" : "\u{1D639}",
        "Y" : "\u{1D620}",
        "y" : "\u{1D63A}",
        "Z" : "\u{1D621}",
        "z" : "\u{1D63B}",

        "ùê¥" : "\u{1D608}",
        "ùëé" : "\u{1D622}",
        "ùêµ" : "\u{1D609}",
        "ùëè" : "\u{1D623}",
        "ùê∂" : "\u{1D60A}",
        "ùëê" : "\u{1D624}",
        "ùê∑" : "\u{1D60B}",
        "ùëë" : "\u{1D625}",
        "ùê∏" : "\u{1D60C}",
        "ùëí" : "\u{1D626}",
        "ùêπ" : "\u{1D60D}",
        "ùëì" : "\u{1D627}",
        "ùê∫" : "\u{1D60E}",
        "ùëî" : "\u{1D628}",
        "ùêª" : "\u{1D60F}",
        "‚Ñé" : "\u{1D629}",
        "ùêº" : "\u{1D610}",
        "ùëñ" : "\u{1D62A}",
        "ùêΩ" : "\u{1D611}",
        "ùëó" : "\u{1D62B}",
        "ùêæ" : "\u{1D612}",
        "ùëò" : "\u{1D62C}",
        "ùêø" : "\u{1D613}",
        "ùëô" : "\u{1D62D}",
        "ùëÄ" : "\u{1D614}",
        "ùëö" : "\u{1D62E}",
        "ùëÅ" : "\u{1D615}",
        "ùëõ" : "\u{1D62F}",
        "ùëÇ" : "\u{1D616}",
        "ùëú" : "\u{1D630}",
        "ùëÉ" : "\u{1D617}",
        "ùëù" : "\u{1D631}",
        "ùëÑ" : "\u{1D618}",
        "ùëû" : "\u{1D632}",
        "ùëÖ" : "\u{1D619}",
        "ùëü" : "\u{1D633}",
        "ùëÜ" : "\u{1D61A}",
        "ùë†" : "\u{1D634}",
        "ùëá" : "\u{1D61B}",
        "ùë°" : "\u{1D635}",
        "ùëà" : "\u{1D61C}",
        "ùë¢" : "\u{1D636}",
        "ùëâ" : "\u{1D61D}",
        "ùë£" : "\u{1D637}",
        "ùëä" : "\u{1D61E}",
        "ùë§" : "\u{1D638}",
        "ùëã" : "\u{1D61F}",
        "ùë•" : "\u{1D639}",
        "ùëå" : "\u{1D620}",
        "ùë¶" : "\u{1D63A}",
        "ùëç" : "\u{1D621}",
        "ùëß" : "\u{1D63B}",

        "ùóî" : "\u{1D63C}",
        "ùóÆ" : "\u{1D656}",
        "ùóï" : "\u{1D63D}",
        "ùóØ" : "\u{1D657}",
        "ùóñ" : "\u{1D63E}",
        "ùó∞" : "\u{1D658}",
        "ùóó" : "\u{1D63F}",
        "ùó±" : "\u{1D659}",
        "ùóò" : "\u{1D640}",
        "ùó≤" : "\u{1D65A}",
        "ùóô" : "\u{1D641}",
        "ùó≥" : "\u{1D65B}",
        "ùóö" : "\u{1D642}",
        "ùó¥" : "\u{1D65C}",
        "ùóõ" : "\u{1D643}",
        "ùóµ" : "\u{1D65D}",
        "ùóú" : "\u{1D644}",
        "ùó∂" : "\u{1D65E}",
        "ùóù" : "\u{1D645}",
        "ùó∑" : "\u{1D65F}",
        "ùóû" : "\u{1D646}",
        "ùó∏" : "\u{1D660}",
        "ùóü" : "\u{1D647}",
        "ùóπ" : "\u{1D661}",
        "ùó†" : "\u{1D648}",
        "ùó∫" : "\u{1D662}",
        "ùó°" : "\u{1D649}",
        "ùóª" : "\u{1D663}",
        "ùó¢" : "\u{1D64A}",
        "ùóº" : "\u{1D664}",
        "ùó£" : "\u{1D64B}",
        "ùóΩ" : "\u{1D665}",
        "ùó§" : "\u{1D64C}",
        "ùóæ" : "\u{1D666}",
        "ùó•" : "\u{1D64D}",
        "ùóø" : "\u{1D667}",
        "ùó¶" : "\u{1D64E}",
        "ùòÄ" : "\u{1D668}",
        "ùóß" : "\u{1D64F}",
        "ùòÅ" : "\u{1D669}",
        "ùó®" : "\u{1D650}",
        "ùòÇ" : "\u{1D66A}",
        "ùó©" : "\u{1D651}",
        "ùòÉ" : "\u{1D66B}",
        "ùó™" : "\u{1D652}",
        "ùòÑ" : "\u{1D66C}",
        "ùó´" : "\u{1D653}",
        "ùòÖ" : "\u{1D66D}",
        "ùó¨" : "\u{1D654}",
        "ùòÜ" : "\u{1D66E}",
        "ùó≠" : "\u{1D655}",
        "ùòá" : "\u{1D66F}",

        "ùü¨" : "ùü¨",
        "ùü≠" : "ùü≠",
        "ùüÆ" : "ùüÆ",
        "ùüØ" : "ùüØ",
        "ùü∞" : "ùü∞",
        "ùü±" : "ùü±",
        "ùü≤" : "ùü≤",
        "ùü≥" : "ùü≥",
        "ùü¥" : "ùü¥",
        "ùüµ" : "ùüµ",

        // These symbols don't exist in textit, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",
        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "\u2710" : "\u2710",
        " " : "\u2710"
	};
	return replaceLetters(arg, symbols, initialCommand);
};

const texttt = (arg: string[], initialCommand: string): string => {
    // texttt stands for text typewriter
    // This function converts the list of characters to the corresponding typewriter character
    const symbols: obj = {
        "A" : "\u{1D670}",
        "a" : "\u{1D68A}",
        "B" : "\u{1D671}",
        "b" : "\u{1D68B}",
        "C" : "\u{1D672}",
        "c" : "\u{1D68C}",
        "D" : "\u{1D673}",
        "d" : "\u{1D68D}",
        "E" : "\u{1D674}",
        "e" : "\u{1D68E}",
        "F" : "\u{1D675}",
        "f" : "\u{1D68F}",
        "G" : "\u{1D676}",
        "g" : "\u{1D690}",
        "H" : "\u{1D677}",
        "h" : "\u{1D691}",
        "I" : "\u{1D678}",
        "i" : "\u{1D692}",
        "J" : "\u{1D679}",
        "j" : "\u{1D693}",
        "K" : "\u{1D67A}",
        "k" : "\u{1D694}",
        "L" : "\u{1D67B}",
        "l" : "\u{1D695}",
        "M" : "\u{1D67C}",
        "m" : "\u{1D696}",
        "N" : "\u{1D67D}",
        "n" : "\u{1D697}",
        "O" : "\u{1D67E}",
        "o" : "\u{1D698}",
        "P" : "\u{1D67F}",
        "p" : "\u{1D699}",
        "Q" : "\u{1D680}",
        "q" : "\u{1D69A}",
        "R" : "\u{1D681}",
        "r" : "\u{1D69B}",
        "S" : "\u{1D682}",
        "s" : "\u{1D69C}",
        "T" : "\u{1D683}",
        "t" : "\u{1D69D}",
        "U" : "\u{1D684}",
        "u" : "\u{1D69E}",
        "V" : "\u{1D685}",
        "v" : "\u{1D69F}",
        "W" : "\u{1D686}",
        "w" : "\u{1D6A0}",
        "X" : "\u{1D687}",
        "x" : "\u{1D6A1}",
        "Y" : "\u{1D688}",
        "y" : "\u{1D6A2}",
        "Z" : "\u{1D689}",
        "z" : "\u{1D6A3}",

        "ùê¥" : "\u{1D670}",
        "ùëé" : "\u{1D68A}",
        "ùêµ" : "\u{1D671}",
        "ùëè" : "\u{1D68B}",
        "ùê∂" : "\u{1D672}",
        "ùëê" : "\u{1D68C}",
        "ùê∑" : "\u{1D673}",
        "ùëë" : "\u{1D68D}",
        "ùê∏" : "\u{1D674}",
        "ùëí" : "\u{1D68E}",
        "ùêπ" : "\u{1D675}",
        "ùëì" : "\u{1D68F}",
        "ùê∫" : "\u{1D676}",
        "ùëî" : "\u{1D690}",
        "ùêª" : "\u{1D677}",
        "‚Ñé" : "\u{1D691}",
        "ùêº" : "\u{1D678}",
        "ùëñ" : "\u{1D692}",
        "ùêΩ" : "\u{1D679}",
        "ùëó" : "\u{1D693}",
        "ùêæ" : "\u{1D67A}",
        "ùëò" : "\u{1D694}",
        "ùêø" : "\u{1D67B}",
        "ùëô" : "\u{1D695}",
        "ùëÄ" : "\u{1D67C}",
        "ùëö" : "\u{1D696}",
        "ùëÅ" : "\u{1D67D}",
        "ùëõ" : "\u{1D697}",
        "ùëÇ" : "\u{1D67E}",
        "ùëú" : "\u{1D698}",
        "ùëÉ" : "\u{1D67F}",
        "ùëù" : "\u{1D699}",
        "ùëÑ" : "\u{1D680}",
        "ùëû" : "\u{1D69A}",
        "ùëÖ" : "\u{1D681}",
        "ùëü" : "\u{1D69B}",
        "ùëÜ" : "\u{1D682}",
        "ùë†" : "\u{1D69C}",
        "ùëá" : "\u{1D683}",
        "ùë°" : "\u{1D69D}",
        "ùëà" : "\u{1D684}",
        "ùë¢" : "\u{1D69E}",
        "ùëâ" : "\u{1D685}",
        "ùë£" : "\u{1D69F}",
        "ùëä" : "\u{1D686}",
        "ùë§" : "\u{1D6A0}",
        "ùëã" : "\u{1D687}",
        "ùë•" : "\u{1D6A1}",
        "ùëå" : "\u{1D688}",
        "ùë¶" : "\u{1D6A2}",
        "ùëç" : "\u{1D689}",
        "ùëß" : "\u{1D6A3}",

        "0" : "\u{1D7F6}",
        "1" : "\u{1D7F7}",
        "2" : "\u{1D7F8}",
        "3" : "\u{1D7F9}",
        "4" : "\u{1D7FA}",
        "5" : "\u{1D7FB}",
        "6" : "\u{1D7FC}",
        "7" : "\u{1D7FD}",
        "8" : "\u{1D7FE}",
        "9" : "\u{1D7FF}",

        // These symbols don't exist in texttt, but don't output errors
        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        " " : "\u2710"
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const text = (arg: string[], initialCommand: string): string => {
    // This function doesn't change the output (i.e. "abc" -> "abc")
    const symbols: obj = {
        "A" : "A",
        "√Ä" : "√Ä",
        "√†" : "√†",
        "a" : "a",
        "B" : "B",
        "b" : "b",
        "C" : "C",
        "√á" : "√á",
        "c" : "c",
        "√ß" : "√ß",
        "D" : "D",
        "d" : "d",
        "E" : "E",
        "√â" : "√â",
        "√à" : "√à",
        "√ä" : "√ä",
        "√ã" : "√ã",
        "e" : "e",
        "√©" : "√©",
        "√®" : "√®",
        "√™" : "√™",
        "√´" : "√´",
        "F" : "F",
        "f" : "f",
        "G" : "G",
        "g" : "g",
        "H" : "H",
        "h" : "h",
        "I" : "I",
        "i" : "i",
        "J" : "J",
        "j" : "j",
        "K" : "K",
        "k" : "k",
        "L" : "L",
        "l" : "l",
        "M" : "M",
        "m" : "m",
        "N" : "N",
        "n" : "n",
        "O" : "O",
        "√î" : "√î",
        "o" : "o",
        "√¥" : "√¥",
        "P" : "P",
        "p" : "p",
        "Q" : "Q",
        "q" : "q",
        "R" : "R",
        "r" : "r",
        "S" : "S",
        "s" : "s",
        "T" : "T",
        "t" : "t",
        "U" : "U",
        "u" : "u",
        "√ô" : "√ô",
        "√π" : "√π",
        "V" : "V",
        "v" : "v",
        "W" : "W",
        "w" : "w",
        "X" : "X",
        "x" : "x",
        "Y" : "Y",
        "y" : "y",
        "Z" : "Z",
        "z" : "z",

        "ùê¥" : "A",
        "ùëé" : "a",
        "ùêµ" : "B",
        "ùëè" : "b",
        "ùê∂" : "C",
        "ùëê" : "c",
        "ùê∑" : "D",
        "ùëë" : "d",
        "ùê∏" : "E",
        "ùëí" : "e",
        "ùêπ" : "F",
        "ùëì" : "f",
        "ùê∫" : "G",
        "ùëî" : "g",
        "ùêª" : "H",
        "‚Ñé" : "h",
        "ùêº" : "I",
        "ùëñ" : "i",
        "ùêΩ" : "J",
        "ùëó" : "j",
        "ùêæ" : "K",
        "ùëò" : "k",
        "ùêø" : "L",
        "ùëô" : "l",
        "ùëÄ" : "M",
        "ùëö" : "m",
        "ùëÅ" : "N",
        "ùëõ" : "n",
        "ùëÇ" : "O",
        "ùëú" : "o",
        "ùëÉ" : "P",
        "ùëù" : "p",
        "ùëÑ" : "Q",
        "ùëû" : "q",
        "ùëÖ" : "R",
        "ùëü" : "r",
        "ùëÜ" : "S",
        "ùë†" : "s",
        "ùëá" : "T",
        "ùë°" : "t",
        "ùëà" : "U",
        "ùë¢" : "u",
        "ùëâ" : "V",
        "ùë£" : "v",
        "ùëä" : "W",
        "ùë§" : "w",
        "ùëã" : "X",
        "ùë•" : "x",
        "ùëå" : "Y",
        "ùë¶" : "y",
        "ùëç" : "Z",
        "ùëß" : "z",

        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        " " : "\u2710"
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const hspace = (arg: string[], initialCommand: string): string => {
    // hspace stands for horizontal space
    // Adds the number of space specified in 'arg'
    let spaces: string = "";
    const num: string = arg.join("");
    try {
        let n: number = parseInt(num);
        for (let i=0; i<n; i++) {
            spaces += "\u2710";
        };
    } catch {
        spaces = mistakes(initialCommand + "{" + num + "}", undefined, "argument must be a number");
    }
    return spaces;
};

const vskip = (arg: string[], initialCommand: string): string => {
    // vskip stands for vertical skip
    // Adds the number of linebreaks specified in 'arg'
    let skips = "";
    const num = arg.join("");
    try {
        let n: number = parseInt(num);
        for (let i=0; i<n; i++) {
            skips += "\u000A";
        };
    } catch {
        skips = mistakes(initialCommand + "{" + num + "}", undefined, "argument must be a number");
    }
    return skips;
};

const sqrt = (arg: string[], initialCommand: string): any => {
    // sqrt stands for square root
    const numStart: number = initialCommand.indexOf("[");
    const numEnd: number = initialCommand.indexOf("]");
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]{x}", undefined, "‚Åø‚àöùë•");
            return addSymbol(undefined);
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output: string = "";
    switch (rootNum) {
        // There's already a unicode symbol for square root, cube root and 4th root
        // If rootNum is different than those, the symbol is built
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(Fct(MATHDICTIONARY["^"])(rootNum.toString().split(""), initialCommand)) + "\u221A";
    };
    if (arg.length >= 2) {
        output += "(" + addSymbolArray(arg, initialCommand + "{" + arg.join("") + "}") + ")";
    } else {
        output += addSymbolArray(arg, initialCommand + "{" + arg.join("") + "}");
    };
    return output;
};


const sqrtNoArg = (arg: string[], initialCommand: string): any => {
    // Compared with sqrt, this function only takes the root as parameter, not the argument
    // For instance the 'cube root of two' would be in sqrt, but simply the 'cube root' would be parsed here 
    if (arg !== undefined) {
        mistakes(initialCommand + " does not take in arguments and should take the form \\sqrt[n]*", undefined, "‚Åø‚àö  (use \\sqrt[n]{x} to get ‚Åø‚àöùë•)");
        return addSymbol(undefined);
    };
    const numStart: number = initialCommand.indexOf("[");
    const numEnd: number = initialCommand.indexOf("]");
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]*", undefined, "‚Åø‚àö");
            return addSymbol(undefined);
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output = "";
    switch (rootNum) {
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(Fct(MATHDICTIONARY["^"])(rootNum.toString().split(""), initialCommand)) + "\u221A";
        };
    return output;
};

const frac = (arg: string[], initialCommand: string) => {
    // Used to make a fraction
    // If a character doesn't exist in superscript or subscript, it outputs the fraction in the format f(x)/g(x)
    let output: string = "";
    let nume: string[] = [];
    let deno: string[] = [];
    let numerator: boolean = true;
    let i: number;
    for (i=0; i<arg.length; i++) {
        if (numerator) {
            if (arg[i] === "}") {
                numerator = false;
            } else {
                nume.push(arg[i]);
            };
        } else {
            if (arg[i] === "{") {
                if (arg[i - 1] === "}") {
                    output += addSymbol(Fct(MATHDICTIONARY["^"])(nume, initialCommand, true)) + "\u2215";
                } else {
                    deno.push(arg[i]);
                };
            } else {
                deno.push(arg[i]);
            };
        };
    };
    output += addSymbol(Fct(MATHDICTIONARY["_"])(deno, initialCommand, true));
    if (output.indexOf("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") === -1) {
        return output;
    } else {
        if (arg.join("").includes("\u2710")) {
            const spaces = arg.filter(c => {return c.includes("\u2710")});
            for (let i in spaces) {
                mistakes(initialCommand + "{" + arg.join("") + "}", undefined, spaces[i]);
            };
        };
        output = "";
        numerator = true;
        nume = [];
        deno = [];
        for (i=0; i<arg.length; i++) {
            if (numerator) {
                if (arg[i] === "}") {
                    numerator = false;
                } else {
                    nume.push(arg[i]);
                };
            } else {
                if (arg[i] === "{") {
                    if (arg[i - 1] === "}") {
                        output += "(" + addSymbolArray(nume, "\\frac{" + arg.join("") + "}") + "/";
                    } else {
                        deno.push(arg[i]);
                    };
                } else {
                    deno.push(arg[i]);
                };
            };
        };
        output += addSymbolArray(deno, "\\frac{" + arg.join("") + "}") + ")";
        return output;
    };
};

const singleCharFrac = (arg: string[], initialCommand: string): string => {
    // Some fractions already exists as unicode symbols they can be accessed via this function
    let noSpaceArg: string = arg.join("").replace(/ /g, "");
    const fractions: obj = {
        "1}{2" : "\u00BD",
        "1}{7" : "‚Öê",
        "1}{9" : "‚Öë",
        "1}{10" : "‚Öí",
        "1}{3"  :"‚Öì",
        "2}{3" : "‚Öî",
        "1}{5" : "‚Öï",
        "2}{5" : "‚Öñ",
        "3}{5" : "‚Öó",
        "4}{5" : "‚Öò",
        "1}{6" : "‚Öô",
        "5}{6" : "‚Öö",
        "1}{8" : "‚Öõ",
        "3}{8" : "‚Öú",
        "5}{8" : "‚Öù",
        "7}{8" : "‚Öû",
        "a}{c" : "\u2100",
        "a}{s" : "\u2101",
        "c}{o" : "\u2105",
        "c}{u" : "\u2106"
    };
    let output = fractions[noSpaceArg];
    return (output !== undefined) ? output : frac(arg, initialCommand);
};

const combineSymbols = (arg: string | string[], initialCommand: string, symbol: string, forTwo: undefined | string): string[] => {
    // Appends a 'combining symbol' to a regular symbol to create a new one (e.g. 'e' + '¬¥' -> √©)
    // N.B. "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}"  ->  error symbol
    let textComb: string[] = [];
    if ((arg.length === 2) && (forTwo !== undefined)) {
        textComb.push(arg[0] + forTwo + arg[1]);
        mistakes(initialCommand + "{\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}" + arg[1] + "}", arg[0], "Argument doesn't exist");
        mistakes(initialCommand + "{" + arg[0] + "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}}", arg[1], "Argument doesn't exist");
    } else {
        let err: string[] = [];
        let i: number;
        for (i=0; i<arg.length; i++) {
            if (arg[i] !== undefined) {
                textComb.push(arg[i] + symbol);
                err.push(arg[i]);
            } else {
                textComb.push("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}");
                err.push("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}");
            };
        };
        if (err.includes("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}")) {
            mistakes(initialCommand + "{" + err.join("") + "}", undefined, "Argument doesn't exist")
        };
    };
    return textComb;
};

// These functions call combineSymbols with a predetermined symbol

const overline = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0305", undefined)};

const underline = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0332", undefined)};

const vec = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u20D7", undefined)};

const hvec = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u20D1", undefined)};

const overfrown = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0361", "\u0361")};

const oversmile = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u035D", "\u035D")};

const undersmile = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u035C", "\u035C")};

const hat = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0302", undefined)};

const not = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0338", undefined)};

const tilde = (arg: string | string[], initialCommand: string): string[] => {if ((arg == "\u27F6") || (arg == "\u2192")) {return ["\u2972"]} else {return combineSymbols(arg, initialCommand, "\u0303", "\u0360")}};

const dot = (arg: string | string[], initialCommand: string): string[] => {if ((arg == "=") || (arg == "\u003D")) {return ["\u2250"]} else if (arg == "\u2261") {return ["\u2A67"]} else {return combineSymbols(arg, initialCommand, "\u0307", undefined)}};

const ddot = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0308", undefined)};

const underarrow = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0362", "\u0362")};

const underharpoon = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u20EC", undefined)};

const acute = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0301", undefined)};

const grave = (arg: string[], initialCommand: string): string[] => {return combineSymbols(arg, initialCommand, "\u0300", undefined)};

const above = (arg: string[], initialCommand: string): string => {
    // Returns the symbol to be put above the preceding character in the input text
    if (arg.length > 1) {
        return mistakes(initialCommand + "{" + arg.join("") + "}", undefined, "Only one argument accepted");
    };
    mistakes(initialCommand + "{" + arg.join("") + "}", ABOVE[arg[0]], (arg[0] !== undefined) ? arg[0] : "Argument doesn't exist");
    return ABOVE[arg[0]];
};

const below = (arg: string[], initialCommand: string): string => {
    // Returns the symbol to be put below the preceding character in the input text
    if (arg.length > 1) {
        return mistakes(initialCommand + "{" + arg.join("") + "}", undefined, "Only one argument accepted");
    };
    mistakes(initialCommand + "{" + arg.join("") + "}", BELOW[arg[0]], (arg[0] !== undefined) ? arg[0] : "Argument doesn't exist");
    return BELOW[arg[0]];
};


//-----------------------------------------------------//


/** Dictionaries **/

// mathDictionary is the main obj for converting commands into symbols
const MATHDICTIONARY: objwF = {
    // Math operators
    "\\times" : "\u00D7",
    "\\rtimes" : "\u22CA",
    "\\ltimes" : "\u22C9",
    "\\div" : "\u00F7",
    "\\longdiv" : "\u27CC",
    "\\int" : "\u222B",
    "\\iint" : "\u222C",
    "\\iiint" : "\u222D",
    "\\iiiint" : "\u2A0C",
    "\\oint" : "\u222E",
    "\\oiint" : "\u222F",
    "\\oiiint" : "\u2230",
    "\\intclockwise" : "\u2231",
    "\\ointclockwise" : "\u2232",
    "\\ointctrclockwise" : "\u2233",
    "\\sqint" : "\u2A16",
    "\\fint" : "\u2A0F",
    "\\cupint" : "\u2A1A",
    "\\capint" : "\u2A19",
    "\\overbarint" : "\u2A1B",
    "\\underbarint" : "\u2A1C",
    "\\cupplus" : "\u228E",
    "\\timesint" : "\u2A18",
    "\\ast" : "\u2217",
    "\\star" : "\u22C6",
    "\\partial" : "\u2202",
    "\\nabla" : "\u2207",
    "\\sqrt2" : "\u221A",
    "\\sqrt3" : "\u221B",
    "\\sqrt4" : "\u221C",
    "\\circ" : "\u2218",
    "\\sum" : "\u2211",
    "\\osum" : "\u2A0A",
    "\\sumint" : "\u2A0B",
    "\\prod" : "\u220F",
    "\\cdot" : "\u00B7",
    "\\cdotp" : "\u22C5",
    "\\middot" : "\u2E31",
    "\\pm" : "\u00B1",
    "\\mp" : "\u2213",
    "\\emptyset" : "\u2205",
    "\\sin" : "sin",
    "\\cos" : "cos",
    "\\tan" : "tan",
    "\\arcsin" : "arcsin",
    "\\arccos" : "arccos",
    "\\arctan" : "arctan",
    "\\cot" : "cot",
    "\\csc" : "csc",
    "\\sec" : "sec",
    "\\arccot" : "arccot",
    "\\arccsc" : "arccsc",
    "\\arcsec" : "arcsec",
    "\\*" : "*",
    "\\log" : "log",
    "\\ln" : "ln",
    "\\lim" : "lim",
    "\\cup" : "\u222A",
    "\\Cup" : "\u22D3",
    "\\sqcup" : "\u2294",
    "\\sqCup" : "\u2A4F",
    "\\cap" : "\u2229",
    "\\Cap" : "\u22D2",
    "\\sqcap" : "\u2293",
    "\\sqCap" : "\u2A4E",
    "\\uplus" : "\u228E",
    "\\def" : "\u225D",
    "\\vee" : "\u2228",
    "\\doublevee" : "\u2A56",
    "\\wedge" : "\u2227",
    "\\doublewedge" : "\u2A55",
    "\\curlyvee" : "\u22CE",
    "\\curlywedge" : "\u22CF",
    "\\diamond" : "\u22C4",
    "\\wr" : "\u2240",
    "\\oplus" : "\u2295",
    "\\ominus" : "\u2296",
    "\\otimes" : "\u2297",
    "\\oslash" : "\u2298",
    "\\odot" : "\u2299",
    "\\obullet" : "\u29BF",
    "\\ocirc" : "\u29BE",
    "\\operp" : "\u29B9",
    "\\oparallel" : "\u29B7",
    "\\oast" : "\u229B",
    "\\oeq" : "\u229C",
    "\\opluslhrim" : "\u2A2D",
    "\\oplusrhrim" : "\u2A2E",
    "\\otimeslhrim" : "\u2A34",
    "\\otimesrhrim" : "\u2A35",
    "\\boxplus" : "\u229E",
    "\\boxminus" : "\u229F",
    "\\boxtimes" : "\u22A0",
    "\\boxdot" : "\u22A1",
    "\\amalg" : "\u2210",
    "\\tprime" : "\u2034",
    "\\lthree" : "\u22CB",
    "\\rthree" : "\u22CC",
    "\\pitchfork" : "\u22D4",
    "\\topfork" : "\u2ADA",
    "\\invamp" : "\u214B",
    "\\originalof" : "\u22B6",
    "\\imageof" : "\u22B7",
    "\\multimap" : "\u22B8",
    "\\leftmultimap" : "\u27DC",
    "\\uptack" : "\u27DF",
    "\\xor" : "\u22BB",
    "\\nand" : "\u22BC",
    "\\nor" : "\u22BD",
    "\\divideontimes" : "\u22C7",
    "\\smashtimes" : "\u2A33",
    "\\fracline" : "\u2215",  // Better suited for superscript over subscript

    // Relations
    "\\forall" : "\u2200",
    "\\exists" : "\u2203",
    "\\nexists" : "\u2204",
    "\\land" : "\u2227",
    "\\lor" : "\u2228",
    "\\sqland" : "\u27CE",
    "\\sqlor" : "\u27CF",
    "\\in" : "\u2208",
    "\\notin" : "\u2209",
    "\\ni" : "\u220B",
    "\\subset" : "\u2282",
    "\\nsubset" : "\u2284",
    "\\subseteq" : "\u2286",
    "\\nsubseteq" : "\u2288",
    "\\supset" : "\u2283",
    "\\nsupset" : "\u2285",
    "\\supseteq" : "\u2287",
    "\\nsupseteq" : "\u2289",
    "\\sqsubset" : "\u228F",
    "\\sqsupset" : "\u2290",
    "\\sqsubseteq" : "\u2291",
    "\\sqsupseteq" : "\u2292",
    "\\Subset" : "\u22D0",
    "\\Supset" : "\u22D1",
    "\\subsetplus" : "\u2ABF",
    "\\supsetplus" : "\u2AC0",
    "\\osubset" : "\u27C3",
    "\\osupset" : "\u27C4",
    "\\setminus" : "\u2216",
    "\\cong" : "\u2245",
    "\\ncong" : "\u2247",
    "\\propto" : "\u221D",
    "\\equiv" : "\u2261",
    "\\dotequiv" : "\u2A67",
    "\\superequiv" : "\u2263",
    "\\tbond" : "\u2261",
    "\\qbond" : "\u2263",
    "\\doteq" : "\u2250",
    "\\eqdot" : "\u2A66",
    "\\neq" : "\u2260",
    "\\approx" : "\u2248",
    "\\sim" : "\u223C",
    "\\simeq" : "\u224C",
    "\\nsim" : "\u2241",
    "\\nless" : "\u226E",
    "\\ngtr" : "\u226F",
    "\\leq" : "\u2264",
    "\\leqslant" : "\u2A7D",
    "\\geq" : "\u2265",
    "\\geqslant" : "\u2A7E",
    "\\nleq" : "\u2270",
    "\\ngeq" : "\u2271",
    "\\lneq" : "\u2A87",
    "\\lneqq" : "\u2268",
    "\\gneq" : "\u2A88",
    "\\gneqq" : "\u2269",
    "\\lnapprox" : "\u2A89",
    "\\gnapprox" : "\u2A8A",
    "\\lnsim" : "\u22E6",
    "\\gnsim" : "\u22E7",
    "\\ll" : "\u226A",
    "\\lll" : "\u22D8",
    "\\gg" : "\u226B",
    "\\ggg" : "\u22D9",
    "\\prec" : "\u227A",
    "\\succ" : "\u227B",
    "\\nprec" : "\u2280",
    "\\nsucc" : "\u2281",
    "\\preceq" : "\u227C",
    "\\succeq" : "\u227D",
    "\\precneqq" : "\u2AB5",
    "\\succneqq" : "\u2AB6",
    "\\precnapprox" : "\u2AB9",
    "\\succnapprox" : "\u2ABA",
    "\\precnsim" : "\u22E8",
    "\\succnsim" : "\u22E9",
    "\\perp" : "\u27C2",
    "\\Perp" : "\u2AEB",
    "\\parallel" : "\u2225",
    "\\nparallel" : "\u2226",
    "\\vvvert" : "\u2AF4",
    "\\nvvvert" : "\u2AF5",
    "\\mid" : "|",
    "\\nmid" : "\u2224",
    "\\asymp" : "\u224D",
    "\\neg" : "\u00AC",
    "\\bowtie" : "\u2A1D",
    "\\vdash" : "\u22A2",
    "\\nvdash" : "\u22AC",
    "\\dashv" : "\u22A3",
    "\\vDash" : "\u22A8",
    "\\Dashv" : "\u2AE4",
    "\\nvDash" : "\u22AD",
    "\\Vdash" : "\u22A9",
    "\\dashV" : "\u2AE3",
    "\\nVdash" : "\u22AE",
    "\\VDash" : "\u22AB",
    "\\DashV" : "\u2AE5",
    "\\nVDash" : "\u22AF",
    "\\triangleleft" : "\u22B2",
    "\\ntriangleleft" : "\u22EA",
    "\\triangleright" : "\u22B3",
    "\\ntriangleright" : "\u22EB",
    "\\ntrianglelefteq" : "\u22EC",
    "\\ntrianglerighteq" : "\u22ED",
    "\\triangleq" : "\u225C",
    "\\equest" : "\u225F",
    "\\lquest" : "\u2A7B",
    "\\rquest" : "\u2A7C",
    "\\mquest" : "\u225E",
    "\\vdots" : "\u22EE",
    "\\cdots" : "\u22EF",
    "\\udots" : "\u22F0",
    "\\ddots" : "\u22F1",
    "\\ldots" : "\u2026",
    "\\top" : "\u22A4",
    "\\bot" : "\u22A5",
    "\\between" : "\u226C",
    "\\therefore" : "\u2234",
    "\\because" : "\u2235",
    "\\squaredots" : "\u2237",
    "\\dotminus" : "\u2238",
    "\\ratio" : "\u2236",  // Same as ":", except with "$chem"

    // Arrows
    "\\Rightarrow" : "\u21D2",
    "\\Leftarrow" : "\u21D0",
    "\\nLeftarrow" : "\u21CD",
    "\\nRightarrow" : "\u21CF",
    "\\nLeftrightarrow" : "\u21CE",
    "\\Uparrow" : "\u21D1",
    "\\Downarrow" : "\u21D3",
    "\\Updownarrow" : "\u21D5",
    "\\rightarrow" : "\u2192",
    "\\longrightarrow" : "\u27F6",
    "\\leftarrow" : "\u2190",
    "\\longleftarrow" : "\u27F5",
    "\\leftrightarrow" : "\u2194",
    "\\nleftrightarrow" : "\u21AE",
    "\\uparrow" : "\u2191",
    "\\downarrow" : "\u2193",
    "\\updownarrow" : "\u2195",
    "\\nleftarrow" : "\u219A",
    "\\nrightarrow" : "\u219B",
    "\\Longleftarrow" : "\u27F8",
    "\\implies" : "\u27F9",
    "\\Longrightarrow" : "\u27F9",
    "\\Leftrightarrow" : "\u21D4",
    "\\iff" : "\u27FA",
    "\\mapsto" : "\u27FC",
    "\\rightleftharpoons" : "\u21CC",
    "\\leftrightharpoons" : "\u21CB",
    "\\rightharpoonup" : "\u21C0",
    "\\rightharpoondown" : "\u21C1",
    "\\leftharpoonup" : "\u21BC",
    "\\leftharpoondown" : "\u21BD",
    "\\upharpoonleft" : "\u21BF",
    "\\upharpoonright" : "\u21BE",
    "\\downharpoonleft" : "\u21C3",
    "\\downharpoonright" : "\u21C2", 
    "\\hookleftarrow" : "\u21A9",
    "\\hookrightarrow" : "\u21AA",
    "\\nearrow" : "\u2197",
    "\\searrow" : "\u2198",
    "\\swarrow" : "\u2199",
    "\\nwarrow" : "\u2196",
    "\\Nearrow" : "\u21D7",
    "\\Searrow" : "\u21D8",
    "\\Swarrow" : "\u21D9",
    "\\Nwarrow" : "\u21D6",
    "\\twoheadleftarrow" : "\u219E",
    "\\twoheadrightarrow" : "\u21A0",
    "\\twoheaduparrow" : "\u219F",
    "\\twoheaddownarrow" : "\u21A1",
    "\\Lsh" : "\u21B0",
    "\\Rsh" : "\u21B1",
    "\\leftleftarrows" : "\u21C7",
    "\\rightrightarrows" : "\u21C9",
    "\\rightrightrightarrows" : "\u21F6",
    "\\upuparrows" : "\u21C8",
    "\\downdownarrows" : "\u21CA",
    "\\leftrightarrows" : "\u21C6",
    "\\rightleftarrows" : "\u21C4",
    "\\Lleftarrow" : "\u21DA",
    "\\Rrightarrow" : "\u21DB",
    "\\Uuparrow" : "\u290A",
    "\\Ddownarrow" : "\u290B",
    "\\leftarrowtail" : "\u21A2",
    "\\rightarrowtail" : "\u21A3",
    "\\leftsquigarrow" : "\u21DC",
    "\\rightsquigarrow" : "\u21DD",
    "\\leftrightsquigarrow" : "\u21AD",
    "\\longrightsquiglearrow" : "\u27FF",
    "\\looparrowleft" : "\u21AB",
    "\\looparrowright" : "\u21AC",
    "\\circlearrowleft" : "\u21BA",
    "\\circlearrowright" : "\u21BB",
    "\\curvearrowleft" : "\u21B6",
    "\\curvearrowright" : "\u21B7",
    "\\leftdasharrow" : "\u21E0",
    "\\rightdasharrow" : "\u21E2",
    "\\updasharrow" : "\u21E1",
    "\\downdasharrow" : "\u21E3",
    "\\tildeabovearrow" : "\u2972",
    "\\tildebelowarrow" : "\u2974",
    "\\equalabovearrow" : "\u2971",

    // Hebrew alphabet
    "\\aleph" : "\u2135",
    "\\beth" : "\u2136",
    "\\gimel" : "\u2137",
    "\\dalet" : "\u2138",

    // Convert text
    "\\mathbb" : mathbb,
    "\\mathbf" : mathbf,
    "\\mathcal" : mathcal,
    "\\mathfrak" : mathfrak,
    "^" : superscript,
    "_" : subscript,
    "\\text" : text,
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,

    // Spaces
    "\\hspace" : hspace,
    "\\vskip" : vskip,

    // Square root and fractions
    "\\sqrt" : sqrt,
    "\\sqrt*" : sqrtNoArg,
    "\\frac" : frac,
    "\\frac*" : singleCharFrac,

    // Combining symbols
    "\\overline" : overline,
    "\\underline" : underline,
    "\\underarrow" : underarrow,
    "\\underharpoon" : underharpoon,
    "\\overfrown" : overfrown,
    "\\oversmile" : oversmile,
    "\\undersmile" : undersmile,
    "\\hat" : hat,
    "\\not" : not,
    "\\tilde" : tilde,
    "\\vec" : vec,
    "\\hvec" : hvec,
    "\\dot" : dot,
    "\\ddot" : ddot,
    "\\acute" : acute,
    "\\grave" : grave,

    "\\above" : above,
    "\\below" : below,

    // Chess
    "\\wking" : "\u2654",
    "\\wqueen" : "\u2655",
    "\\wrook" : "\u2656",
    "\\wbishop" : "\u2657",
    "\\wknight" :"\u2658",
    "\\wpawn" : "\u2659",
    "\\bking" : "\u265A",
    "\\bqueen" : "\u265B",
    "\\brook" : "\u265C",
    "\\bbishop" : "\u265D",
    "\\bknight" :"\u265E",
    "\\bpawn" : "\u265F",

    // Card games
    "\\bspade" : "\u2660",
    "\\wheart" : "\u2661",
    "\\wdiamond" : "\u2662",
    "\\bclub" : "\u2663",
    "\\wspade" : "\u2664",
    "\\bheart" : "\u2665",
    "\\bdiamond" : "\u2666",
    "\\wclub" : "\u2667",

    // Money
    "\\dollar" : "\u0024",
    "\\cent" : "\u00A2",
    "\\pound" : "\u00A3",
    "\\yen" : "\u00A5",
    "\\franc" : "\u20A3",
    "\\euro" : "\u20AC",
    "\\peso" : "\u20B1",
    "\\bitcoin" : "\u20BF",
    "\\austral" : "\u20B3",
    "\\ruble" : "\u20BD",
    "\\hryvnia" : "\u20B4",
    "\\rupee" : "\u20B9",
    "\\lira" : "\u20AA",
    "\\tlira" : "\u20A9",
    "\\won" : "\u20A9",
    "\\baht" : "\u0E3F",

    "\\^" : "^",
    "\\_" : "_",

    // Matrix
    "\\id1" : "[1]",
    "\\id2" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u23A4 \u000A \u23A3 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id3" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id4" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 0 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\idn" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u22EF \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 \u22EF \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 \u2710 \u22EE \u2710 \u2710 \u22EE \u2710 \u2710 \u22F1 \u2710 \u2710 \u22EE \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 \u22EF \u2710 1 \u2710 \u23A6",
    
    // To build your own
    "\\mlceil" : "\u23A1",
    "\\mrceil" : "\u23A4",
    "\\mlmid" : "\u23A2",
    "\\mrmid" : "\u23A5",
    "\\mlfloor" : "\u23A3",
    "\\mrfloor" : "\u23A6",

    // Music
    "\\flat" : "\u{1D12C}",
    "\\natural" : "\u{1D12E}",
    "\\sharp" : "\u{1D130}",
    "\\eightnote" : "\u{1D160}",
    "\\sixteenthnote" : "\u{1D161}",
    "\\halfnote" : "\u{1D15E}",
    "\\quarternote" : "\u{1D15F}",
    "\\fullnote" : "\u{1D15D}",
    "\\doublenote" : "\u266B",
    "\\trebleclef" : "\u{1D11E}",
    
    // Box drawing
    "\\boxh" : "\u2500",
    "\\boxbfh" : "\u2501",
    "\\boxH" : "\u2550",
    "\\boxv" : "\u2502",
    "\\boxbfv" : "\u2503",
    "\\boxV" : "\u2551",
    "\\boxdr" : "\u250C",
    "\\boxbfdr" : "\u250F",
    "\\boxDR" : "\u2554",
    "\\boxdl" : "\u2510",
    "\\boxbfdl" : "\u2513",
    "\\boxDL" : "\u2557",
    "\\boxur" : "\u2514",
    "\\boxbfur" : "\u2517",
    "\\boxUR" : "\u255A",
    "\\boxul" : "\u2518",
    "\\boxbful" : "\u251B",
    "\\boxUL" : "\u255D",
    "\\boxvr" : "\u251C",
    "\\boxbfvr" : "\u2523",
    "\\boxVR" : "\u2560",
    "\\boxvl" : "\u2524",
    "\\boxbfvl" : "\u252B",
    "\\boxVL" : "\u2563",
    "\\boxdh" : "\u252C",
    "\\boxbfdh" : "\u2533",
    "\\boxDH" : "\u2566",
    "\\boxuh" : "\u2534",
    "\\boxbfuh" : "\u253B",
    "\\boxUH" : "\u2569",
    "\\boxvh" : "\u253C",
    "\\boxbfvh" : "\u254B",
    "\\boxVH" : "\u256C",

    // Other symbols
    "\\LaTeX" : "ùêø·¥¨ùëá·¥áùëã",
    "\\TeX" : "ùëá·¥áùëã",
    "\\MatTalX" : "ùëÄ·¥Ä·¥õùëá·¥Ä üùëã",
    "\\CaMuS" : "ùê∂·¥¨ùëÄ·¥úùëÜ",  // http://camus.math.usherbrooke.ca/index.html
    "\\infty" : "\u221E",
    "\\iinfin" : "\u29DC",
    "\\tieinfty" : "\u29DD",
    "\\nvinfty" : "\u29DE",
    "\\acidfree" : "\u267E",
    "\\radioactive" : "\u2622",
    "\\biohazard" : "\u2623",
    "\\atom" : "\u269B",
    "\\angle" : "\u2220",
    "\\measuredangle" : "\u2221",
    "\\sphericalangle" : "\u2222",
    "\\rightangle" : "\u299C",
    "\\hbar" : "\u210F",
    "\\ell" : "\u2113",
    "\\dagger" : "\u2020",
    "\\ddagger" : "\u2021",
    "\\hermitian" : "\u22B9",
    "\\qc" : "\u269C",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\wp" : "\u2118",
    "\\laplace" : "\u2112",
    "\\bloch" : "\u212C",
    "\\im" : "\u2111",
    "\\fourier" : "\u2131",
    "\\angstrom" : "\u212B",
    "\\emdash" : "\u2014",
    "\\bullet" : "\u2219",
    "\\bigbullet" : "\u25CF",
    "\\langle" : "\u27E8",
    "\\rangle" : "\u27E9",
    "\\llangle" : "\u27EA",
    "\\rrangle" : "\u27EB",
    "\\lceil" : "\u2308",
    "\\rceil" : "\u2309",
    "\\lfloor" : "\u230A",
    "\\rfloor" : "\u230B",
    "\\lBrace" : "\u2983",
    "\\rBrace" : "\u2984",
    "\\%" : "%",
    "\\{" : "{",
    "\\}" : "}",
    "\\(" : "(",
    "\\)" : ")",
    "\\backslash" : "\\",
    "\\llbracket" : "\u27E6",
    "\\rrbracket" : "\u27E7",
    "\\llparenthesis" : "\u2985",
    "\\rrparenthesis" : "\u2986",
    "\\frown" : "\u2322",
    "\\smile" : "\u2323",
    "\\qed" : "\u220E",
    "\\blacksquare" : "\u25A0",
    "\\square" : "\u25A1",
    "\\lightning" : "\u21AF",
    "\\male" : "\u2642",
    "\\female" : "\u2640",
    "\\Hermaphrodite" : "\u26A5",
    "\\neuter" : "\u26B2",
    "\\malemale" : "\u26A3",
    "\\femalefemale" : "\u26A2",
    "\\femalemale" : "\u26A4",
    "\\" : "\\",
    "\\:" : "\u2710",  // Space (internally represented with \u2710 (‚úê), but switched to a real space before output)
    "\\;" : "\u2710\u2710",  // Double space
    "\\quad" : "\u2710\u2710\u2710",
    "\\qquad" : "\u2710\u2710\u2710\u2710",
    "\\colon" : "\u003A",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009"
};

// Standard dict for greek letters
const STDGREEK: obj = {
    "\\Alpha" : "\u{1D6E2}",
    "\\alpha" : "\u{1D6FC}",
    "\\Beta" : "\u{1D6E3}",
    "\\beta" : "\u{1D6FD}",
    "\\Gamma" : "\u{1D6E4}",
    "\\gamma" : "\u{1D6FE}",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u{1D6FF}",
    "\\Epsilon" : "\u{1D6E6}",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u{1D6E7}",
    "\\zeta" : "\u{1D701}",
    "\\Eta" : "\u{1D6E8}",
    "\\eta" : "\u{1D702}",
    "\\Theta" : "\u0398",
    "\\theta" : "\u{1D703}",
    "\\vartheta" : "\u{1D717}",
    "\\Iota" : "\u{1D6EA}",
    "\\iota" : "\u{1D704}",
    "\\Kappa" : "\u{1D6EB}",
    "\\kappa" : "\u{1D705}",
    "\\varkappa" : "\u{1D718}",
    "\\Lambda" : "\u{1D6EC}",
    "\\lambda" : "\u{1D706}",
    "\\Mu" : "\u{1D6ED}",
    "\\mu" : "\u{1D707}",
    "\\Nu" : "\u{1D6EE}",
    "\\nu" : "\u{1D708}",
    "\\Xi" : "\u039E",
    "\\xi" : "\u{1D709}",
    "\\Omicron" : "\u{1D6F0}",
    "\\omicron" : "\u{1D70A}",
    "\\Pi" : "\u{1D6F1}",
    "\\pi" : "\u{1D70B}",
    "\\varpi" : "\u{1D71B}",
    "\\Rho" : "\u{1D6F2}",
    "\\rho" : "\u{1D70C}",
    "\\varrho" : "\u{1D71A}",
    "\\Sigma" : "\u{1D6F4}",
    "\\sigma" : "\u{1D70E}",
    "\\varsigma" : "\u{1D70D}",
    "\\Tau" : "\u{1D6F5}",
    "\\tau" : "\u{1D70F}",
    "\\Upsilon" : "\u{1D6F6}",
    "\\upsilon" : "\u{1D710}",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u{1D719}",
    "\\varphi" : "\u{1D711}",
    "\\Chi" : "\u{1D6F8}",
    "\\chi" : "\u{1D712}",
    "\\Psi" : "\u{1D6F9}",
    "\\psi" : "\u{1D713}",
    "\\Omega" : "\u2126",
    "\\omega" : "\u{1D714}"
};

// Greek letters if the user wants basic UTF-8 characters (nostyle)
const NOSTYLEGREEK: obj = {
    "\\Alpha" : "\u0391",
    "\\alpha" : "\u03B1",
    "\\Beta" : "\u0392",
    "\\beta" : "\u03B2",
    "\\Gamma" : "\u0393",
    "\\gamma" : "\u03B3",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u03B4",
    "\\Epsilon" : "\u0395",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u0396",
    "\\zeta" : "\u03B6",
    "\\Eta" : "\u0397",
    "\\eta" : "\u03B7",
    "\\Theta" : "\u0398",
    "\\theta" : "\u03B8",
    "\\vartheta" : "\u03D1",
    "\\Iota" : "\u0399",
    "\\iota" : "\u03B9",
    "\\Kappa" : "\u039A",
    "\\kappa" : "\u03BA",
    "\\varkappa" : "\u03F0",
    "\\Lambda" : "\u039B",
    "\\lambda" : "\u03BB",
    "\\Mu" : "\u039C",
    "\\mu" : "\u03BC",
    "\\Nu" : "\u039D",
    "\\nu" : "\u03BD",
    "\\Xi" : "\u039E",
    "\\xi" : "\u03BE",
    "\\Omicron" : "\u039F",
    "\\omicron" : "\u03BF",
    "\\Pi" : "\u03A0",
    "\\pi" : "\u03C0",
    "\\varpi" : "\u03D6",
    "\\Rho" : "\u03A1",
    "\\rho" : "\u03C1",
    "\\varrho" : "\u03F1",
    "\\Sigma" : "\u03A3",
    "\\sigma" : "\u03C3",
    "\\varsigma" : "\u03C2",
    "\\Tau" : "\u03A4",
    "\\tau" : "\u03C4",
    "\\Upsilon" : "\u03A5",
    "\\upsilon" : "\u03C5",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u03D5",
    "\\varphi" : "\u03C6",
    "\\Chi" : "\u03A7",
    "\\chi" : "\u03C7",
    "\\Psi" : "\u03A8",
    "\\psi" : "\u03C8",
    "\\Omega" : "\u03A9",
    "\\omega" : "\u03C9"
};

// Commmands that can be called from outside mathmode
const TEXTCOMMANDS: objwF = {
    "\\^" : "^",
    "\\_" : "_",
    "\\LaTeX" : "ùêø·¥¨ùëá·¥áùëã",
    "\\TeX" : "ùëá·¥áùëã",
    "\\MatTalX" : "ùëÄ·¥Ä·¥õùëá·¥Ä üùëã",
    "\\CaMuS" : "ùê∂·¥¨ùëÄ·¥úùëÜ",  // http://camus.math.usherbrooke.ca/index.html
    "\\textbullet" : "\u2022",
    "\\%" : "%",
    "\\#" : "#",
    "\\{" : "{",
    "\\}" : "}",
    "\\backslash" : "\\",
    "\\textbackslash" : "\\",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009",
    "\\text" : text,
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,
    "\\hspace" : hspace,
    "\\vskip" : vskip
};

// Regular dict used to convert characters that are not a command
// Automatically convert text into a mathematical font
// N.B. For outside mathmode
const LETTERSMATH: obj = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "¬∞" : "¬∞",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "$" : "$",
    "*" : "*",
    "@" : "@",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "\u003C",
    ">" : "\u003E",
    "^" : "^",
    "_" : "_",
    "%" : "%",
    "#" : "#",
    "~" : "~",
    "¬¨" : "¬¨",
    ":" : "\u2236",
    ";" : ";",
    "‚Ä¶" : "‚Ä¶",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "\u{1D434}",
    "a" : "\u{1D44E}",
    "B" : "\u{1D435}",
    "b" : "\u{1D44F}",
    "C" : "\u{1D436}",
    "c" : "\u{1D450}",
    "D" : "\u{1D437}",
    "d" : "\u{1D451}",
    "E" : "\u{1D438}",
    "e" : "\u{1D452}",
    "F" : "\u{1D439}",
    "f" : "\u{1D453}",
    "G" : "\u{1D43A}",
    "g" : "\u{1D454}",
    "H" : "\u{1D43B}",
    "h" : "\u210E",
    "I" : "\u{1D43C}",
    "i" : "\u{1D456}",
    "J" : "\u{1D43D}",
    "j" : "\u{1D457}",
    "K" : "\u{1D43E}",
    "k" : "\u{1D458}",
    "L" : "\u{1D43F}",
    "l" : "\u{1D459}",
    "M" : "\u{1D440}",
    "m" : "\u{1D45A}",
    "N" : "\u{1D441}",
    "n" : "\u{1D45B}",
    "O" : "\u{1D442}",
    "o" : "\u{1D45C}",
    "P" : "\u{1D443}",
    "p" : "\u{1D45D}",
    "Q" : "\u{1D444}",
    "q" : "\u{1D45E}",
    "R" : "\u{1D445}",
    "r" : "\u{1D45F}",
    "S" : "\u{1D446}",
    "s" : "\u{1D460}",
    "T" : "\u{1D447}",
    "t" : "\u{1D461}",
    "U" : "\u{1D448}",
    "u" : "\u{1D462}",
    "V" : "\u{1D449}",
    "v" : "\u{1D463}",
    "W" : "\u{1D44A}",
    "w" : "\u{1D464}",
    "X" : "\u{1D44B}",
    "x" : "\u{1D465}",
    "Y" : "\u{1D44C}",
    "y" : "\u{1D466}",
    "Z" : "\u{1D44D}",
    "z" : "\u{1D467}",
    "\u2710" : " ",
    " " : " "
};

// Obj used to convert characters that are not a command if the user doesn't want styled characters (mathematical font)
// N.B. For outside mathmode
const LETTERSNOFONT: obj = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "¬∞" : "¬∞",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "\u003C",
    ">" : "\u003E",
    "^" : "^",
    "_" : "_",
    "%" : "%",
    "$" : "$",
    "*" : "*",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "¬¨" : "¬¨",
    ":" : ":",  // Same as "\colon", use "\ratio" instead to get the same as without "$chem"
    ";" : ";",
    "‚Ä¶" : "‚Ä¶",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "√Ä" : "√Ä",
    "a" : "a",
    "√†" : "√†",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "√á" : "√á",
    "c" : "c",
    "√ß" : "√ß",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "√â" : "√â",
    "√à" : "√à",
    "e" : "e",
    "√©" : "√©",
    "√®" : "√®",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "i" : "i",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "o" : "o",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "√ô" : "√ô",
    "√π" : "√π",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    "\u2710" : " ",
    " " : " "
};

// Obj with characters and their corresponding symbol that can be combined and put above another symbol
const ABOVE: obj = {
    "." : "\u0307",
    ":" : "\u0308",
    "\u2236" : "\u0308",
    "-" : "\u0305",
    "‚àí" : "\u0305",
    "`" : "\u0300",
    "¬¥" : "\u0301",
    "^" : "\u0302",
    "=" : "\u033F",
    "‚àº" : "\u0303",
    "‚àû" : "\u1AB2", // Only works on certain website/apps
    "‚àò" : "\u030A",
    "¬∞" : "\u030A",
    "a" : "\u0363",
    "ùëé" : "\u0363",
    "b" : "\u1DE8",
    "ùëè" : "\u1DE8",
    "c" : "\u0368",
    "ùëê" : "\u0368",
    "d" : "\u0369",
    "ùëë" : "\u0369",
    "e" : "\u0364",
    "ùëí" : "\u0364",
    "f" : "\u1DEB",
    "ùëì" : "\u1DEB",
    "h" : "\u036A",
    "‚Ñé" : "\u036A",
    "i" : "\u0365",
    "ùëñ" : "\u0365",
    "k" : "\u1DDC",  // Only works on certain website/apps
    "ùëò" : "\u1DDC",
    "m" : "\u036B",
    "ùëö" : "\u036B",
    "N" : "\u1DE1",
    "ùëÅ" : "\u1DE1",
    "n" : "\u1DE0",  // Only works on certain website/apps
    "ùëõ" : "\u1DE0",
    "o" : "\u0366",
    "ùëú" : "\u0366",
    "p" : "\u1DEE",
    "ùëù" : "\u1DEE",
    "R" : "\u1DE2",
    "ùëÖ" : "\u1DE2",
    "r" : "\u036C",
    "ùëü" : "\u036C",
    "t" : "\u036D",
    "ùë°" : "\u036D",
    "u" : "\u0367",
    "ùë¢" : "\u0367",
    "v" : "\u036E",
    "ùë£" : "\u036E",
    "x" : "\u036F",
    "ùë•" : "\u036F",

    "ùõº" : "\u1DE7",
    "ùõΩ" : "\u1DE9",

    "‚Üº" : "\u20D0",
    "‚áÄ" : "\u20D1",
    "‚Üî" : "\u20E1",
    "‚Ü∂" : "\u20D4",
    "‚Ü∑" : "\u20D5",
    "‚Üê" : "\u20D6",
    "‚Üí" : "\u20D7",
    "‚Üì" : "\u1AB3",
    "‚à¥" : "\u1AB4",
    "‚ãØ" : "\u20DB",
    "‚Ä¶" : "\u20DB",
    "\u2710" : " ",
    " " : " "
};

// Obj with characters and their corresponding symbol that can be combined and put below another symbol
const BELOW: obj = {
    "." : "\u0323",
    ":" : "\u0324",
    "\u2236" : "\u0324",
    "-" : "\u0332",
    "‚àí" : "\u0332",
    "=" : "\u0333",
    "m" : "\u1AC0",
    "ùëö" : "\u1AC0",
    "x" : "\u0353",
    "ùë•" : "\u0353",
    "w" : "\u1ABF",
    "ùë§" : "\u1ABF",
    "‚ÜΩ" : "\u20ED",
    "‚áÅ" : "\u20EC",
    "‚Üê" : "\u20EE",
    "‚Üí" : "\u20EF",
    "‚Üî" : "\u034D",
    "\u2710" : " ",
    " " : " "
};

// Superscript is used (by the superscript function) to convert characters to the corresponding superscript character
const SUPERSCRIPT: obj = {
    "0" : "\u2070",
    "1" : "\u00B9",
    "2" : "\u00B2",
    "3" : "\u00B3",
    "4" : "\u2074",
    "5" : "\u2075",
    "6" : "\u2076",
    "7" : "\u2077",
    "8" : "\u2078",
    "9" : "\u2079",

    "+" : "\u207A",
    "-" : "\u207B",
    "\u2212" : "\u207B",
    "=" : "\u207C",
    "(" : "\u207D",
    ")" : "\u207E",
    "\\" : "·ê†",
    "/" : "·êü",
    "." : "·êß",
    "," : "\u02D2",

    "A" : "·¥¨",
    "a" : "·µÉ",
    "B" : "·¥Æ",
    "b" : "·µá",
    "C" : "·∂ú",
    "c" : "·∂ú",
    "D" : "·¥∞",
    "d" : "·µà",
    "E" : "·¥±",
    "e" : "·µâ",
    "f" : "·∂†",
    "G" : "·¥≥",
    "g" : "·µç",
    "H" : "·¥¥",
    "h" : " ∞",
    "I" : "·¥µ",
    "i" : "‚Å±",
    "J" : "·¥∂",
    "j" : " ≤",
    "K" : "·¥∑",
    "k" : "·µè",
    "L" : "·¥∏",
    "l" : "À°",
    "M" : "·¥π",
    "m" : "·µê",
    "N" : "·¥∫",
    "n" : "‚Åø",
    "O" : "·¥º",
    "o" : "·µí",
    "P" : "·¥æ",
    "p" : "·µñ",
    "R" : "·¥ø",
    "r" : " ≥",
    "S" : "À¢",
    "s" : "À¢",
    "T" : "·µÄ",
    "t" : "·µó",
    "U" : "·µÅ",
    "u" : "·µò",
    "V" : "‚±Ω",
    "v" : "·µõ",
    "W" : "·µÇ",
    "w" : " ∑",
    "X" : "À£",
    "x" : "À£",
    "y" : " ∏",
    "Z" : "·∂ª",
    "z" : "·∂ª",

    "ùê¥" : "·¥¨",
    "ùëé" : "·µÉ",
    "ùêµ" : "·¥Æ",
    "ùëè" : "·µá",
    "ùê∂" : "·∂ú",
    "ùëê" : "·∂ú",
    "ùê∑" : "·¥∞",
    "ùëë" : "·µà",
    "ùê∏" : "·¥±",
    "ùëí" : "·µâ",
    "ùëì" : "·∂†",
    "ùê∫" : "·¥≥",
    "ùëî" : "·µç",
    "ùêª" : "·¥¥",
    "‚Ñé" : " ∞",
    "ùêº" : "·¥µ",
    "ùëñ" : "‚Å±",
    "ùêΩ" : "·¥∂",
    "ùëó" : " ≤",
    "ùêæ" : "·¥∑",
    "ùëò" : "·µè",
    "ùêø" : "·¥∏",
    "ùëô" : "À°",
    "ùëÄ" : "·¥π",
    "ùëö" : "·µê",
    "ùëÅ" : "·¥∫",
    "ùëõ" : "‚Åø",
    "ùëÇ" : "·¥º",
    "ùëú" : "·µí",
    "ùëÉ" : "·¥æ",
    "ùëù" : "·µñ",
    "ùëÖ" : "·¥ø",
    "ùëü" : " ≥",
    "ùëÜ" : "À¢",
    "ùë†" : "À¢",
    "ùëá" : "·µÄ",
    "ùë°" : "·µó",
    "ùëà" : "·µÅ",
    "ùë¢" : "·µò",
    "ùëâ" : "‚±Ω",
    "ùë£" : "·µõ",
    "ùëä" : "·µÇ",
    "ùë§" : " ∑",
    "ùëã" : "À£",
    "ùë•" : "À£",
    "ùë¶" : " ∏",
    "ùëç" : "·∂ª",
    "ùëß" : "·∂ª",

    "ùõΩ" : "\u1D5D",
    "ùõ§" : "·£ò",
    "ùõæ" : "\u1D5E",
    "Œî" : "·êû",
    "Œ¥" : "\u1D5F",
    "œµ" : "·µã",
    "Œõ" : "·£î",
    "ùúÉ" : "\u1DBF",
    "ùúÑ" : "·∂•",
    "ùúà" : "·∂π",
    "œÉ" : "·£ô",
    "ùúô" : "·∂≤",
    "ùúë" : "\u1D60",
    "ùúå" : "·£ñ",
    "ùúí" : "\u1D61",
    "Œ≤" : "\u1D5D",
    "Œì" : "·£ò",
    "Œ≥" : "\u1D5E",
    "ùõ•" : "·êû",
    "ùõø" : "\u1D5F",
    "ùõ¨" : "·£î",
    "Œ∏" : "\u1DBF",
    "Œπ" : "·∂•",
    "ŒΩ" : "·∂π",
    "ùúé" : "·£ô",
    "œï" : "·∂≤",
    "œÜ" : "\u1D60",
    "œÅ" : "·£ñ",
    "œá" : "\u1D61",

    "‚à´" : "·∂¥",
    "‚â†" : "·ôæ",
    "‚àò" : "¬∞",
    "$" : "·ôö",
    "‚àû" : "\u2710\u1AB2\u2710",  // Only works on certain website/apps
    "‚àÖ" : "\u{1D1A9}",
    "*" : "*",

    "\u2710" : "\u2710",
    " " : " "
};

// Subscript is used (by the subscript function) to convert characters to the corresponding subscript character
const SUBSCRIPT = {
    "0" : "\u2080",
    "1" : "\u2081",
    "2" : "\u2082",
    "3" : "\u2083",
    "4" : "\u2084",
    "5" : "\u2085",
    "6" : "\u2086",
    "7" : "\u2087",
    "8" : "\u2088",
    "9" : "\u2089",

    "+" : "\u208A",
    "-" : "\u208B",
    "\u2212" : "\u208B",
    "=" : "\u208C",
    "(" : "\u208D",
    ")" : "\u208E",
    "," : "\u2710\u0326\u2710",
    "." : "\u2710\u0323\u2710",

    "a" : "\u2090",
    "e" : "\u2091",
    "h" : "\u2095",
    "i" : "\u1D62",
    "j" : "‚±º",
    "k" : "\u2096",
    "l" : "\u2097",
    "m" : "\u2098",
    "n" : "\u2099",
    "O" : "\u2092",
    "o" : "\u2092",
    "p" : "\u209A",
    "r" : "·µ£",
    "S" : "\u209B",
    "s" : "\u209B",
    "t" : "\u209C",
    "u" : "·µ§",
    "V" : "·µ•",
    "v" : "·µ•",
    "X" : "\u2093",
    "x" : "\u2093",

    "ùëé" : "\u2090",
    "ùëí" : "\u2091",
    "‚Ñé" : "\u2095",
    "ùëñ" : "\u1D62",
    "ùëó" : "‚±º",
    "ùëò" : "\u2096",
    "ùëô" : "\u2097",
    "ùëö" : "\u2098",
    "ùëõ" : "\u2099",
    "ùëÇ" : "\u2092",
    "ùëú" : "\u2092",
    "ùëù" : "\u209A",
    "ùëü" : "·µ£",
    "ùëÜ" : "\u209B",
    "ùë†" : "\u209B",
    "ùë°" : "\u209C",
    "ùë¢" : "·µ§",
    "ùëâ" : "·µ•",
    "ùë£" : "·µ•",
    "ùëã" : "\u2093",
    "ùë•" : "\u2093",

    "ùõΩ" : "\u1D66",
    "ùõæ" : "\u1D67",
    "ùúå" : "\u1D68",
    "ùúë" : "\u1D69",
    "ùúô" : "\u1D69",
    "ùúí" : "\u1D6A",
    "Œ≤" : "\u1D66",
    "Œ≥" : "\u1D67",
    "œÅ" : "\u1D68",
    "œÜ" : "\u1D69",
    "œï" : "\u1D69",
    "œá" : "\u1D6A",

    "‚Üí" : "\u2710\u2710\u0362\u2710\u2710",
    "‚àû" : "\u2710\u035A\u2710",

    "\u2710" : "\u2710",
    " " : " "
};


//-----------------------------------------------------//


/** HTMLElements **/

// Submit button ('Convert' is what's seen by the users)
const submit: HTMLButtonElement = <HTMLButtonElement>document.getElementById("convert");
submit.onclick = function() {main()};

// Copy button
const copyButton: HTMLButtonElement = <HTMLButtonElement>document.getElementById("copy");
copyButton.onclick = function() {copyTextOut()};

// Clear button
const resetButton: HTMLButtonElement = <HTMLButtonElement>document.getElementById("reset");
resetButton.onclick = function() {clear()};

const suggestionsBtn: HTMLButtonElement = <HTMLButtonElement>document.getElementById("suggestionsBtn");
suggestionsBtn.onclick = function() {getSuggestion()};

// Remove spaces button
const spacesButton: HTMLInputElement = <HTMLInputElement>document.getElementById("adjust");

// Originally hidden
// Can be accessed with a keyboard shortcut (Alt+S or Alt+C on chrome or firefox respectively) or by clicking the button (android)
const suggestionsPopup: HTMLTableElement = <HTMLTableElement>document.getElementById("suggestions");

// First and second text box
const textIn: HTMLTextAreaElement = <HTMLTextAreaElement>document.getElementById("text_in");
const textOut: HTMLTextAreaElement = <HTMLTextAreaElement>document.getElementById("text_out");

const mistakesBox: HTMLElement = <HTMLElement>document.getElementById("mistakes");

const parametersBtn: HTMLInputElement = <HTMLInputElement>document.getElementById("parametersBtn");
const parametersBox: HTMLElement = <HTMLElement>document.getElementById("parametersBox");
const parametersText: HTMLTextAreaElement = <HTMLTextAreaElement>document.getElementById("parametersText");


//-----------------------------------------------------//

/** Other **/

// Used is the subsection 'Suggestion box (or completion)' to recognize on which word is the cursor
const wordsDelimiters: string[] = [" ", "", "\u000A", "\\", "^", "_", "(", ")", "[", "]", "{", "}", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"];
const wordsDelimitersWOB: string[] = [" ", "", "\u000A", "^", "_", "(", ")", "[", "]", "{", "}", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"]; // Without backslash

// Used in adjustSpacesCommon to chose which symbols to surround with spaces (if touched by a specific symbol like '=')
const characters: string = "A√Ä√ÇBC√áDE√â√à√ã√äFGHIJKLMNO√îPQRSTU√ôVWXYZa√†√¢bc√ßde√©√®√™√´fghijklmno√¥pqrstu√πvwxyz0123456789"+
                   "ùê¥ùêµùê∂ùê∑ùê∏ùêπùê∫ùêªùêºùêΩùêæùêøùëÄùëÅùëÇùëÉùëÑùëÖùëÜùëáùëàùëâùëäùëãùëåùëçùëéùëèùëêùëëùëíùëìùëî‚Ñéùëñùëóùëòùëôùëöùëõùëúùëùùëûùëüùë†ùë°ùë¢ùë£ùë§ùë•ùë¶ùëß"+
                   "ùî∏ùîπ‚ÑÇùîªùîºùîΩùîæ‚ÑçùïÄùïÅùïÇùïÉùïÑ‚ÑïùïÜ‚Ñô‚Ñö‚Ñùùïäùïãùïåùïçùïéùïèùïê‚Ñ§ùïíùïìùïîùïïùïñùïóùïòùïôùïöùïõùïúùïùùïûùïüùï†ùï°ùï¢ùï£ùï§ùï•ùï¶ùïßùï®ùï©ùï™ùï´ùüòùüôùüöùüõùüúùüùùüûùüüùü†ùü°"+
                   "ùë®ùë©ùë™ùë´ùë¨ùë≠ùëÆùëØùë∞ùë±ùë≤ùë≥ùë¥ùëµùë∂ùë∑ùë∏ùëπùë∫ùëªùëºùëΩùëæùëøùíÄùíÅùíÇùíÉùíÑùíÖùíÜùíáùíàùíâùíäùíãùíåùíçùíéùíèùíêùíëùííùíìùíîùíïùíñùíóùíòùíôùíöùíõ"+
                   "ùíú‚Ñ¨ùíûùíü‚Ñ∞‚Ñ±ùí¢‚Ñã‚Ñêùí•ùí¶‚Ñí‚Ñ≥ùí©ùí™ùí´ùí¨‚ÑõùíÆùíØùí∞ùí±ùí≤ùí≥ùí¥ùíµùí∂ùí∑ùí∏ùíπ‚ÑØùíª‚ÑäùíΩùíæùíøùìÄùìÅùìÇùìÉ‚Ñ¥ùìÖùìÜùìáùìàùìâùìäùìãùìåùìçùìéùìè"+
                   "ùîÑùîÖ‚Ñ≠ùîáùîàùîâùîä‚Ñå‚Ñëùîçùîéùîèùîêùîëùîíùîìùîî‚Ñúùîñùîóùîòùîôùîöùîõùîú‚Ñ®ùîûùîüùî†ùî°ùî¢ùî£ùî§ùî•ùî¶ùîßùî®ùî©ùî™ùî´ùî¨ùî≠ùîÆùîØùî∞ùî±ùî≤ùî≥ùî¥ùîµùî∂ùî∑"+
                   "ùï¨ùï≠ùïÆùïØùï∞ùï±ùï≤ùï≥ùï¥ùïµùï∂ùï∑ùï∏ùïπùï∫ùïªùïºùïΩùïæùïøùñÄùñÅùñÇùñÉùñÑùñÖùñÜùñáùñàùñâùñäùñãùñåùñçùñéùñèùñêùñëùñíùñìùñîùñïùññùñóùñòùñôùñöùñõùñúùñùùñûùñü"+
                   "ùìêùìëùìíùììùìîùìïùìñùìóùìòùìôùìöùìõùìúùìùùìûùìüùì†ùì°ùì¢ùì£ùì§ùì•ùì¶ùìßùì®ùì©ùì™ùì´ùì¨ùì≠ùìÆùìØùì∞ùì±ùì≤ùì≥ùì¥ùìµùì∂ùì∑ùì∏ùìπùì∫ùìªùìºùìΩùìæùìøùîÄùîÅùîÇùîÉ"+
                   "ùóîùóïùóñùóóùóòùóôùóöùóõùóúùóùùóûùóüùó†ùó°ùó¢ùó£ùó§ùó•ùó¶ùóßùó®ùó©ùó™ùó´ùó¨ùó≠ùóÆùóØùó∞ùó±ùó≤ùó≥ùó¥ùóµùó∂ùó∑ùó∏ùóπùó∫ùóªùóºùóΩùóæùóøùòÄùòÅùòÇùòÉùòÑùòÖùòÜùòáùü¨ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≥ùü¥ùüµ"+
                   "ùòàùòâùòäùòãùòåùòçùòéùòèùòêùòëùòíùòìùòîùòïùòñùòóùòòùòôùòöùòõùòúùòùùòûùòüùò†ùò°ùò¢ùò£ùò§ùò•ùò¶ùòßùò®ùò©ùò™ùò´ùò¨ùò≠ùòÆùòØùò∞ùò±ùò≤ùò≥ùò¥ùòµùò∂ùò∑ùò∏ùòπùò∫ùòª"+
                   "ùô∞ùô±ùô≤ùô≥ùô¥ùôµùô∂ùô∑ùô∏ùôπùô∫ùôªùôºùôΩùôæùôøùöÄùöÅùöÇùöÉùöÑùöÖùöÜùöáùöàùöâùöäùöãùöåùöçùöéùöèùöêùöëùöíùöìùöîùöïùöñùöóùöòùöôùööùöõùöúùöùùöûùöüùö†ùö°ùö¢ùö£ùü∂ùü∑ùü∏ùüπùü∫ùüªùüºùüΩùüæùüø"+
                   "ùòºùòΩùòæùòøùôÄùôÅùôÇùôÉùôÑùôÖùôÜùôáùôàùôâùôäùôãùôåùôçùôéùôèùôêùôëùôíùôìùôîùôïùôñùôóùôòùôôùôöùôõùôúùôùùôûùôüùô†ùô°ùô¢ùô£ùô§ùô•ùô¶ùôßùô®ùô©ùô™ùô´ùô¨ùô≠ùôÆùôØ"+
                   "ùõ¢ùõºùõ£ùõΩùõ§ùõæŒîùõ•ùõøùõ¶œµŒµùõßùúÅùõ®ùúÇŒòùúÉùúóùõ™ùúÑùõ´ùúÖùúòùõ¨ùúÜùõ≠ùúáùõÆùúàŒ¶ùúôùúëŒûùúâùõ∞ùúäùõ±ùúãùúõùõ≤ùúåœ±ùõ¥ùúéùúçùõµùúèùõ∂ùúêùõ∏ùúíùõπùúì‚Ñ¶ùúî"+
                   "ùúúùú∂ùúùùú∑ùúûùú∏ùö´ùúüùúπùú†ùõúùõÜùú°ùúªùú¢ùúºùöΩùúΩùùëùú§ùúæùú•ùúøùùíùú¶ùùÄùúßùùÅùú®ùùÇùöΩùùìùùãùöµùùÉùú™ùùÑùú´ùùÖùùïùú¨ùùÜùõ†ùúÆùõîùùáùúØùùâùú∞ùùäùú≤ùùåùú≥ùùçùõÄùùé"+ 
                   "ŒëŒ±ŒíŒ≤ŒìŒ≥Œ¥ŒñŒ∂ŒóŒ∑Œ∏œëŒôŒπŒöŒ∫œ∞ŒõŒªŒúŒºŒùŒΩŒæŒüŒøŒ†œÄœñŒ°œÅœ±Œ£œÉœÇŒ§œÑŒ•œÖœïœÜŒßœáŒ®œàŒ©œâ" + 
                   "ùùñùù∞ùùóùù±ùùòùù≤ùõÖùùõùùµùùúùù∂ùõâùõùùùûùõäùùüùùπùûåùù†ùù∫ùù°ùùªùù¢ùùºùùΩùù§ùùæùù•ùùøùûèùù¶ùûÄùûéùù®ùûÇùûÅùù©ùûÉùù™ùûÑùûçùûÖùù¨ùûÜùù≠ùûáùùÆùûà" +
                   "‚Ñæ‚ÑΩ‚Ñø‚Ñº‚ÖÄ";

// Every undefined commands
let errorsList: string = "";


/**************************************************************************************/


/// FUNCTIONS ///

/** Front-end **/

function copyTextIn(): void {
    // Copy first box (input) to clipboard
    navigator.clipboard.writeText(textIn.value);
};

function copyTextOut(): void {
    // Copy second box (output) to clipboard
    if (textOut.disabled === false) {
        navigator.clipboard.writeText(textOut.value);
        copyButton.value = "Copied!";
        setTimeout(() => {
            copyButton.value = "Copy text";
        }, 2500)  // Returns to initial copyButton
    };
};

function clear(): void {
    // Clears everything
    copyButton.value = "Copy text";
    mistakesBox.textContent = "";
    textOut.disabled = true;
    suggestionsPopup.style.display = "none";
    suggestionsPopup.textContent = "";
};


//-----------------------------------------------------//


/** Suggestion box (or completion) **/

function closeSuggestions() {
    // Close and empties the suggestion popup
    suggestionsPopup.style.display = "none";
    suggestionsPopup.textContent = "";
};

function getSuggestion(): void {
    if (suggestionsPopup.style.display !== "inline-block") { 
        suggestionsPopup.textContent = "";
        let word = findWord(textIn.value, textIn.value.length - 1);
        suggestionsPopup.style.display = "inline-block";
        suggestions(word);
    } else {
        closeSuggestions();
    };
};

function findWord(text: string, cursorPosition: number, addedLetter=""): string {
    // Finds the word that is touched by the cursor
    let t: string[];
    if (addedLetter.length === 1) {  // ie a letter
        t = text.split("");
        t[cursorPosition] += addedLetter;
        text = t.join("");
    } else if (addedLetter === "Backspace") {
        t = text.split("");
        t[cursorPosition] = "";
        text = t.join("");
        cursorPosition -= 1;
    };
    let word: string = "";
    while (!(wordsDelimiters.includes(text.charAt(cursorPosition + 1)))) {
        cursorPosition += 1;
    };
    while (!(wordsDelimitersWOB.includes(text.charAt(cursorPosition)))) {
        if (text.charAt(cursorPosition) === "\\") {
            word = text.charAt(cursorPosition) + word;
            break;
        } else {
            word = text.charAt(cursorPosition) + word;
            cursorPosition -= 1;
        }
    };
    return word;
};

function suggestions(command: string): void {
    // Outputs list of other commands that are similar to the one currently being written
    if (command === "") {
        closeSuggestions();
    } else if (command[0] !== "\\") {
        let row: HTMLTableRowElement = suggestionsPopup.insertRow(-1);
        let cell: HTMLTableCellElement = row.insertCell(0);
        cell.textContent = "The first character of the command must be a backslash (\\). Superscript starts with ^ and subscript with _";
    } else {
        const commandList: objwF = {...MATHDICTIONARY, ...STDGREEK};
        command = command.substring(1, command.length);  // Erases the backslash so that, for instance, \arrow will also show \rightarrow, etc.
        let keys: string;
        for (keys in commandList) {
            // Puts commands in button form, so they can be clicked on to replace the command being written
            if (keys.toLowerCase().indexOf(command.toLowerCase()) !== -1) {
                let row: HTMLTableRowElement = suggestionsPopup.insertRow(-1);
                let cell: HTMLTableCellElement = row.insertCell(0);
                let btn: HTMLButtonElement = document.createElement("button");
                btn.value = showCommand(keys);
                btn.textContent = toReplaceCommand(keys);
                btn.style.width = "145px";  // Would be cleaner with something like 'fit-content', but is way to slow
                btn.style.height = "17px";
                const btnBackColor: string = getComputedStyle(document.body).backgroundColor;
                const btnFontColor: string = (btnBackColor === "rgb(255, 255, 255)") ? "black" : "whitesmoke"; 
                btn.style.backgroundColor = btnBackColor;
                btn.style.border = "1px solid " + btnBackColor;
                btn.style.color = btnFontColor;
                btn.style.borderRadius = "3px";
                btn.type = "button";
                btn.addEventListener("click", () => {
                    textIn.value = semiAutoCompletion(textIn.value, textIn.selectionEnd, btn.value);
                    closeSuggestions();
                    textIn.focus();
                });
                // Shows what the command ouputs on mouseover, return to normal on mouseout
                btn.addEventListener("mouseover", () => {
                    let x: string = Str(btn.textContent);
                    btn.textContent = btn.value;
                    btn.value = x;
                });
                btn.addEventListener("mouseout", () => {
                    let x: string = Str(btn.textContent);
                    btn.textContent = btn.value;
                    btn.value = x;
                });
                cell.appendChild(btn);
            };
        };
    };
};

function semiAutoCompletion(textIn: string, cursorPosition: number, command: string): string {
    // Replace the command being written by the selected suggestion
    let textOut: string = textIn;
    // Find end of word
    while (!(wordsDelimiters.includes(textIn.charAt(cursorPosition)))) {
        cursorPosition += 1;
    };
    // Deletes word
    while (textIn.charAt(cursorPosition - 1) !== "\\") {
        textOut = textOut.substring(0, cursorPosition - 1) + textOut.substring(cursorPosition);
        cursorPosition -= 1;
    };
    // Replace by selected suggestion
    textOut = textOut.substring(0, cursorPosition - 1) + command + textOut.substring(cursorPosition);
    return textOut;
};

function showCommand(key: string): string {
    // Used in suggestions
    // Changes what's seen when the user hovers on a command in the suggestion popup
    const commandList: objwF = {...MATHDICTIONARY, ...STDGREEK};
    if (typeof commandList[key] === "function") {
        if (key === "\\sqrt") {
            return "\\sqrt[n]{x} \u2192 ‚Åø‚àöùë•";
        } else if (key === "\\sqrt*") {
            return "\\sqrt[n]* \u2192 ‚Åø‚àö";
        } else if (key === "\\frac") {
            return "\\frac{1}{2} \u2192 ¬π‚àï‚ÇÇ";
        } else if (key === "\\frac*") {
            return "\\frac*{1}{2} \u2192 ¬Ω";
        } else if ((key === "\\above") || (key === "\\below") || (key === "\\hspace") || (key === "\\vskip")) {
            return key + "{}";
        } else if ((key === "_") || (key === "^")) {
            return "x" + key + "{a1} \u2192 ùë•" + Fct(commandList[key])(["a", "1"], commandList[key]);
        } else {
            return key + "{abc} \u2192 " + Fct(commandList[key])(["a", "b", "c"], commandList[key]);
        };
    } else {
        if (key === "\\:") {
            return "1 space";
        } else if ((key === "\\;") || ((key === "\\quad") || (key === "\\qquad"))) {
            return Str(commandList[key]).length + " spaces";
        } else if ((key === "\\id2") || (key === "\\id3") || (key === "\\id4") || (key === "\\idn")) {
            const M: obj = {
                "\\id2": "‚é° 1 0 ‚é§\u000A‚é£ 0 1 ‚é¶",
                "\\id3" : "‚é° 1 0 0 ‚é§\u000A‚é¢ 0 1 0 ‚é•\u000A‚é£ 0 0 1 ‚é¶",
                "\\id4" : "‚é° 1 0 0 0 ‚é§\u000A‚é¢ 0 1 0 0 ‚é•\u000A‚é¢ 0 0 1 0 ‚é•\u000A‚é£ 0 0 0 1 ‚é¶",
                "\\idn" : "‚é° 1 0 ‚ãØ 0 ‚é§\u000A‚é¢ 0 1 ‚ãØ 0 ‚é•\u000A‚é¢  ‚ãÆ  ‚ãÆ  ‚ã±  ‚ãÆ ‚é•\u000A‚é£ 0 0 ‚ãØ 1 ‚é¶"
            }
            return M[key];
        } else {
            return Str(commandList[key])
        };
    };
};

function toReplaceCommand(key: string): string {
    // Used in suggestions
    // Changes what the user sees when the suggestion popup is opened
    const commandList: objwF = {...MATHDICTIONARY, ...STDGREEK};
    if (typeof commandList[key] === "function") {
        if (key === "\\sqrt") {
            return "\\sqrt[]{}";
        } else if (key === "\\sqrt*") {
            return "\\sqrt[]*";
        } else if (key === "\\frac") {
            return "\\frac{}{}";
        } else if (key === "\\frac*") {
            return "\\frac*{}{}";
        } else {
            return key + "{}";
        };
    } else {
        return key
    };
};

//-----------------------------------------------------//

/** Parsers **/

// For input

function parseInput(fullText: string): [Token[], number, string] {
    // Loops on letters and convert the input into characters
    let mm: boolean = false;  // mathmode
    let d: number = 0;  // depth
    let trigger: boolean = false;  // true if a command has begun (e.g. input: '\' -> true)
    let temporaryBox: string[] = [];  // Stores characters that are in command (e.g. \int -> ['\', 'i', 'n', 't'])
    let outputBox: Token[] = [];
    let mathmodeStarter: string = "";  // ex: if mathmode is started with $$, then "$$" will be mathmodeStarter
    const parentheses: string[] = ["(", ")"];
    const brackets: string[] = ["[", "]"];
    const commandStoppers: string[] = [" ", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"];  // parentheses and brackets also stops commands (most of the time)
    
    let t: Token;

    let i: number;
    for (i=0; i<fullText.length; i++) {
        if (mm) {
            if (trigger) {
                if ((fullText[i] === "\\") || (fullText[i] === "^") || (fullText[i] === "_")) {
                    if (fullText[i-1] === "\\") {
                        t = {command: "\\" + fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                        temporaryBox = [];
                        trigger = false;
                    } else {
                        t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                        outputBox.push(t);
                        temporaryBox = [fullText[i]];
                    };
                } else if (commandStoppers.includes(fullText[i]) || parentheses.includes(fullText[i])) {
                    if (fullText[i-1] === "\\") {
                        t = {command: fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                    } else {
                        t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                        outputBox.push(t);
                        t = {command: fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                    };
                    temporaryBox = [];
                    trigger = false;
                } else if (brackets.includes(fullText[i])) {
                    if (temporaryBox.join("").slice(0,5) === "\\sqrt") {
                        temporaryBox.push(fullText[i]);
                    } else {
                        if (fullText[i-1] === "\\") {
                            if (fullText[i] === "]") {
                                if (mathmodeStarter === "\\[") {
                                    t = {command: "\\\\", mathmode: mm, depth: d};
                                    outputBox.push(t);
                                    mathmodeStarter = "";
                                    mm = false;
                                } else {
                                    t = {command: temporaryBox.join("") + fullText[i], mathmode: mm, depth: d};
                                    outputBox.push(t);
                                };
                            } else {
                                t = {command: fullText[i], mathmode: mm, depth: d};
                                outputBox.push(t);
                            };
                        } else {
                            t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                            outputBox.push(t);
                            t = {command: fullText[i], mathmode: mm, depth: d};
                            outputBox.push(t);
                        };
                        temporaryBox = [];
                        trigger = false;
                    };
                } else if (fullText[i] === "{") {
                    if (temporaryBox.join("").slice(0,5) === "\\frac") {
                        temporaryBox.push("{");
                        d += 1;
                    } else {
                        if (fullText[i-1] === "\\") {
                            t = {command: temporaryBox.join("") + fullText[i], mathmode: mm, depth: d};
                            outputBox.push(t);
                            temporaryBox = [];
                            trigger = false;
                        } else {
                            t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                            outputBox.push(t);
                            temporaryBox = [];
                            trigger = false;
                            d += 1;
                        };
                    };
                } else if (fullText[i] === "}") {
                    if (temporaryBox.join("").slice(0,5) === "\\frac") {
                        if (temporaryBox.includes("}")) {
                            t = {command: temporaryBox.join("").slice(0,temporaryBox.indexOf("{")), mathmode: mm, depth: d-1};
                            outputBox.push(t);
                            t = {command: temporaryBox.join("").slice(temporaryBox.indexOf("{")), mathmode: mm, depth: d};
                            outputBox.push(t);
                            temporaryBox = [];
                            trigger = false;
                        } else {
                            temporaryBox.push(fullText[i]);
                        };
                        d -= 1;
                    } else {
                        if (fullText[i-1] === "\\") {
                            t = {command: fullText[i], mathmode: mm, depth: d};
                            outputBox.push(t);
                        } else {
                            t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                            outputBox.push(t);
                            t = {command: fullText[i], mathmode: mm, depth: d};
                            outputBox.push(t);
                        };
                        temporaryBox = [];
                        trigger = false;
                    };
                } else if (fullText[i] === "$") {
                    if (fullText[i-1] === "\\") {
                        t = {command: temporaryBox.join("") + fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                    } else {
                        t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                        outputBox.push(t);
                        if (mathmodeStarter === "$") {
                            mathmodeStarter = "";
                            mm = false;
                        } else if (mathmodeStarter === "$$") {
                            if (fullText[i-1] === "$") {
                                t = {command: "\\\\", mathmode: mm, depth: d};
                                outputBox.push(t);
                                mathmodeStarter = "";
                                mm = false;
                            } else if (fullText[i+1] === "$") {
                                continue;
                            } else {
                                t = {command: fullText[i], mathmode: mm, depth: d};
                                outputBox.push(t);
                            };
                        } else {
                            t = {command: fullText[i], mathmode: mm, depth: d};
                            outputBox.push(t);
                        };
                    };
                    temporaryBox = [];
                    trigger = false;
                } else {
                    temporaryBox.push(fullText[i]);
                };
            } else {
                if ((fullText[i] === "\\") || (fullText[i] === "^") || (fullText[i] === "_")) {
                    temporaryBox.push(fullText[i]);
                    trigger = true;
                } else if (fullText[i] === "$") {
                    if (mathmodeStarter === "$") {
                        if (fullText[i-1] === "$") {
                            t = {command: "\\\\", mathmode: mm, depth: d};
                            outputBox.push(t);
                            mathmodeStarter = "$$";
                        } else {
                            mathmodeStarter = "";
                            mm = false;
                        };
                    } else if (mathmodeStarter === "$$") {
                        if (fullText[i-1] === "$") {
                            t = {command: "\\\\", mathmode: mm, depth: d};
                            outputBox.push(t);
                            mathmodeStarter = "";
                            mm = false;
                        } else if (fullText[i+1] === "$") {
                            continue;
                        } else {
                            t = {command: fullText[i], mathmode: mm, depth: d};
                            outputBox.push(t);
                        };
                    } else {
                        t = {command: fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                    };
                } else if (fullText[i] === "}") {
                    d -= 1;
                } else {
                    t = {command: fullText[i], mathmode: mm, depth: d};
                    outputBox.push(t);
                };
            };
        } else {
            if (trigger) {
                if (fullText[i] === "[") {
                    if (fullText[i-1] === "\\") {
                        t = {command: "\\\\", mathmode: mm, depth: d};
                        outputBox.push(t);
                        temporaryBox = [];
                        mathmodeStarter = "\\[";
                        mm = true;
                    } else {
                        t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                        outputBox.push(t);
                        t = {command: fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                    };
                    trigger = false;
                } else if (fullText[i] === "$") {
                    if (fullText[i-1] === "\\") {
                        t = {command: fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                    } else {
                        t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                        outputBox.push(t);
                        t = {command: fullText[i], mathmode: mm, depth: d};
                        outputBox.push(t);
                    };
                    temporaryBox = [];
                    trigger = false;
                } else if (commandStoppers.includes(fullText[i]) || parentheses.includes(fullText[i]) || (fullText[i] === "]")) {
                    t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                    outputBox.push(t);
                    temporaryBox = [fullText[i]];
                    trigger = false;
                } else if (fullText[i] === "{") {
                    if (fullText[i-1] === "\\") {
                        t = {command: temporaryBox.join("") + fullText[i], mathmode: mm, depth: d};
                    } else {
                        t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                        d += 1;
                    };
                    outputBox.push(t);
                    temporaryBox = [];
                    trigger = false;
                } else if (fullText[i] === "}") {
                    if (fullText[i-1] === "\\") {
                        t = {command: temporaryBox.join("") + fullText[i], mathmode: mm, depth: d};
                    } else {
                        t = {command: temporaryBox.join(""), mathmode: mm, depth: d};
                        d -= 1;
                    };
                    outputBox.push(t);
                    temporaryBox = [];
                    trigger = false;
                } else {
                    temporaryBox.push(fullText[i]);
                };
            } else {
                if (fullText[i] === "$") {
                    mathmodeStarter = fullText[i];
                    mm = true;
                } else if (fullText[i] === "\\") {
                    temporaryBox.push(fullText[i]);
                    trigger = true;
                } else if (fullText[i] === "}") {
                    d -= 1;
                } else {
                    t = {command: fullText[i], mathmode: mm, depth: d};
                    outputBox.push(t);
                };
            };
        };
    };
    return [outputBox, d, mathmodeStarter];
};


// For parameters

function parseSettings(fullText: string): [Token[], number] {
    fullText = removeComments(fullText);
    
    let d: number = 0;
    let temporaryBox: string[] = [];
    let outputBox: Token[] = [];
    let trigger: boolean = false;

    let t: Token;

    let i: number;
    for (i=0; i<fullText.length; i++) {
        if (trigger) {
            if (fullText[i] === "[") {
                t = {command: temporaryBox.join(""), mathmode: false, depth: d};
                outputBox.push(t);
                temporaryBox = [];
                d = 1;
            } else if (fullText[i] === "]") {
                t = {command: temporaryBox.join(""), mathmode: false, depth: d};
                outputBox.push(t);
                temporaryBox = [];
                d = 0;
            } else if (fullText[i] === "{") {
                if (temporaryBox.join("").slice(0,13) === "\\renewcommand") {
                    if (d >= 2) {
                        temporaryBox.push(fullText[i]);
                        d += 1;
                    } else {
                        if (temporaryBox.indexOf("%") === temporaryBox.length-1) {
                            temporaryBox.push("%");
                        } else {
                            temporaryBox.push(fullText[i]);
                        };
                        d = 2;
                    };
                } else {
                    t = {command: temporaryBox.join(""), mathmode: false, depth: d};
                    outputBox.push(t);
                    temporaryBox = [];
                    d = 2;
                };
            } else if (fullText[i] === "}") {
                if (temporaryBox.join("").slice(0,13) === "\\renewcommand") {
                    if (temporaryBox.indexOf("%") === -1) {
                        if (fullText[i-1] === "\\") {
                            temporaryBox[temporaryBox.length-1] += fullText[i];
                        } else {
                            temporaryBox.push("%");  // Used to separate the two command (\renewcommand{1}{2})
                            // '%' is used because it's impossible at this point to have a '%' not preceded by a '\'
                            d -= 1;
                        };
                    } else {
                        if (d === 2) {
                            t = {command: "\\renewcommand", mathmode: false, depth: 0};
                            outputBox.push(t);
                            t = {command: temporaryBox.join("").slice(14), mathmode: false, depth: d};
                            outputBox.push(t);
                            temporaryBox = [];
                            trigger = false;
                            d = 0;
                        } else {
                            temporaryBox.push(fullText[i]);
                            d -= 1;
                        };
                    };
                } else {
                    t = {command: temporaryBox.join(""), mathmode: false, depth: d};
                    outputBox.push(t);
                    temporaryBox = [];
                    trigger = false;
                    d = 0;
                };
            } else {
                temporaryBox.push(fullText[i]);
            };
        } else {
            if (fullText[i] === "\\") {
                temporaryBox.push(fullText[i]);
                trigger = true;
            } else {
                t = {command: fullText[i], mathmode: false, depth: d};
                outputBox.push(t);
            };
        };
    };
    return [outputBox, d];
};

function removeComments(fullText: string): string {
    // Used in parseSetting to get rid of comments before parsing
    let arrText: string[] = fullText.split("\n");
    let textNoComments: string[] = [];

    let i: number, j: number;
    for (i=0; i<arrText.length; i++) {
        for (j=0; j<arrText[i].length; j++) {
            if ((arrText[i][j] === "%") && (arrText[i][j-1] !== "\\")) {
                break;
            } else {
                textNoComments.push(arrText[i][j]);
            };
        };
    };

    return textNoComments.join("");
};


//-----------------------------------------------------//

/** Convert text **/

// Main functions

function output(fullText: string, dict: objwF): string {
    const [commands, lastDepth, mathmodeOpener] = parseInput(fullText);
    if (lastDepth !== 0) {
        return mistakes("Missing curly bracket '{', '}'", undefined);
    } else if (mathmodeOpener !== "") {
        const mathmodeCloser = (mathmodeOpener === "\\[") ? "\\]" : mathmodeOpener;
        return mistakes("Math mode was not closed", undefined, " Missing '" + mathmodeCloser + "' ");
    } else {
        let stack: any[] = [];
        let out: string = "";

        stack.push([commands[0].command]);

        let i: number, j: number;
        for (i=1; i<commands.length; i++) {
            if (commands[i-1].depth === commands[i].depth) {
                if (commands[i].depth === 0) {
                    out += convert(stack[0], null, dict, commands[i].mathmode);
                    stack = [[commands[i].command]];
                } else {
                    stack[stack.length-1].push(commands[i].command);
                };
            } else if (commands[i-1].depth < commands[i].depth) {
                stack.push([commands[i].command]);
            } else {  // if commands[i-1] > commands[i].depth
                let arg: string[];  // TODO: check types
                let com: string;
                arg = stack.pop();
                for (j=0; j<commands[i].depth-commands[i-1].depth; j++) {
                    com = stack.pop()
                    arg = [convert(com, arg, dict, commands[i].mathmode)];
                };
                stack[stack.length-1].push(arg);
            };
        };
        out += convert(stack.join(""), null, dict, commands[commands.length-1].mathmode);  // TODO: Verify is mathmode is always right
        return out;
    };
};

function convert(command: string, arg: string[] | null, dict: objwF, mathmode: boolean): string {
    let s: string = "";
    if (mathmode) {
        if (arg === null) {
            s += Str(dict[command]);
        } else {
            s += Fct(dict[command])(arg, command, false);
        };
    } else {
        const outofMath: objwF = {...LETTERSNOFONT, ...TEXTCOMMANDS};
        if (arg === null) {
            s += Str(outofMath[command]);
        } else {
            s += Fct(outofMath[command])(arg, command, false);
        };
    };
    return s;
};

function getSettings(fullText: string): [obj, string[], obj, string] {
    // return: [plainTextConverter, [packages], renewCommand, documentclass]

    /*
        List of all possible options

        \documentclass[style, nostyle]{text, mathmode, chem}
        \documentclass{matrix}

        \usepackage{}   ->  Packages are in the packages directory

        \renewcommand{}{}
    */

    // TODO: Will obviously have to rewrite this as the number of document classes and options grow

    let [settings, lastDepth] = parseSettings(fullText);
    const docClasses: string[] = ["text", "mathmode", "chem", "matrix"];
    
    let i: number;
    if (lastDepth !== 0) {
        mistakes("Unbalanced brackets in parameters. Missing", undefined, '{", "}", "[", or "]');
        return [LETTERSMATH, [], {}, "text"];
    } else {
        let docClassNum: number = 0
        let documentClass: string = "";
        let packages: string[] = [];
        let renewCommand: obj = {};
        let plainTextConverter: obj = LETTERSMATH;  // Default
        let doc: boolean = false;
        let usepack: boolean = false;
        let renewcom: boolean = false;
        for (i=0; i<settings.length; i++) {
            if (settings[i].depth === 0) {
                if (settings[i].command === "\\documentclass") {
                    doc = true;
                    usepack = false;
                    renewcom = false;
                    docClassNum += 1;
                } else if (settings[i].command === "\\usepackage") {
                    doc = false;
                    usepack = true;
                    renewcom = false;
                } else if (settings[i].command === "\\renewcommand") {
                    doc = false;
                    usepack = false;
                    renewcom = true;
                } else if ((settings[i].command === " ") || (settings[i].command === "\n") || (settings[i].command === "")) {
                    doc = false;
                    usepack = false;
                    renewcom = false;
                } else {
                    mistakes(settings[i].command + '" is not a command \n Accepted commands are: "\\documentclass", "\\usepackage", "\\renewcommand', undefined);
                };
            } else if (settings[i].depth === 1) {
                if (doc) {
                    if (settings[i].command === "style") {
                        plainTextConverter = LETTERSMATH;
                    } else if (settings[i].command === "nostyle") {
                        plainTextConverter = LETTERSNOFONT;
                    } else {
                        mistakes("\\documentclass[" + settings[i].command + "]{}", undefined, settings[i].command + "\n Accepted options are: style, nostyle");
                    };
                } else {
                    mistakes(settings[i].command, undefined, "Options are only available for document classes. Try \\documentclass[" + settings[i].command + "]{}");
                };
            } else {  // settings[i].depth === 2
                if (doc) {
                    documentClass = settings[i].command;
                } else if (usepack) {
                    packages.push(settings[i].command);
                } else if (renewcom) {
                    let twoCommands: string[] = settings[i].command.split("%%");
                    renewCommand[twoCommands[0]] = twoCommands[1];
                };
            };
        };
        if (docClassNum > 1) {
            mistakes("Only 1 'documentclass' is permitted, not " + docClassNum, undefined);
        } else if (docClassNum === 0) {
            mistakes('Missing a \\documentclass"\n Accepted document classes are: "' + docClasses.join('", "'), undefined);
        };
        return [plainTextConverter, packages, renewCommand, documentClass];
    };
};

function makeDict(plainTextConverter: obj, packages: string[], renewCommand: obj): objwF {
    let dict: objwF = {...MATHDICTIONARY, ...plainTextConverter, ...renewCommand};
    const acceptedPackages: string[] = ["std", "quickletter", "quickgreek", "frenchtext", "chem"];
    let i: number;
    for (i=0; i<packages.length; i++) {
        if (acceptedPackages.includes(packages[i])) {
            fetch("packages/" + packages[i] + ".json").then(file => file.json()).then(
                json => {
                    for (let key in Object.keys(json)) {
                        dict[key] = MATHDICTIONARY[json[key]];
                    };
                }
            );
        } else {
            mistakes('\\usepackage{' + packages[i] + '}', undefined, packages[i] + '"\n' +
            'Accepted packages are: "' + acceptedPackages.join('", "'));  // TODO: Only output once
        };
    };
    return dict;
};


// Used by main functions

function replaceLetters(letters: string[], dict: obj, initialCommand: string, checkMistakes=true): string {
    // Used by a lot of functions to convert every letter in a string of characters
    let newtext: string[] = [];
    let i: number;
    for (i=0; i<letters.length; i++) {
        if (Object.values(ABOVE).concat(Object.values(BELOW)).filter(x => {return x !== "\u2710";}).includes(letters[i])) {  // Make sure it doesn't take spaces into consideration
            // If the letter is a combining symbol, it won't be converted into any other font, so simply push it to the last characte
            newtext[newtext.length-1] += letters[i];
        } else {
            newtext.push(Str(addSymbol(dict[letters[i]])));
        };
        if (checkMistakes) {
            mistakes(initialCommand + "{" + letters.join("") + "}", dict[letters[i]], letters[i]);
        };
    };
    return newtext.join("");
};

function addSymbol(command: any, keepArray=false): string | string[] {
    // Return the command if it's defined, if not it returns a bold "err" with two "x" under it
    if ((typeof command === "object") && !(keepArray)) {
        // Changes an array of characters into a string
        command = command.join("");
    };
    return (command !== undefined) ? command : "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";
};

function addSymbolArray(args: string[], command: string, checkMistakes=true): string {
    // Differs from the function above as it returns an array instead of a string
    let output: string = "";
    let i: number;
    for (i=0; i<args.length; i++) {
        output += (args[i] !== undefined) ? args[i] : "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";
        if (checkMistakes) {
            mistakes(command, args[i], "A symbol does not exist or can't be shown");
        };
    };
    return output;
};


//-----------------------------------------------------//

/** Check mistakes **/

function mistakes(textInput: string, textOutput: string | undefined, letter=""): string {
    // Writes every errors in a box, so it's easier for the user to find them

    // TODO: x^{\error} outputs:¬†x^{} -> try: 'x^{{}}' which is obviously a bad error message

    const popup: HTMLElement = <HTMLElement>document.getElementById("mistakes");
    const text: string = "\u{1D404}\u{1D42B}\u{1D42B}\u{1D428}\u{1D42B}\u{1D42C}: \r\n";  // "Errors" in bold
    if (textOutput === undefined) {
        if (letter != "") {
            if (letter !== "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") {  // Only add to errorsList once
                if (letter.includes("\u2710")) {  // i.e. Spaces
                    if (textInput.substring(0,5) == "\\text") {
                        errorsList += spaceCommand(textInput + " \u2192 Spaces are kept inside '" + textInput.replace(/{.*}/g, "") + "{}', no need for a spacing command") + "\r\n";
                    } else if ((textInput[0] === "^") || (textInput[0] === "_") || (textInput.substring(0,5) == "\\frac")) {
                        const initialSpaceCommand: string[] = ["\\:", "\\;", "\\quad", "\\qquad"];
                        errorsList += spaceCommand(textInput + " \u2192 Replace '" + initialSpaceCommand[letter.length-1] + "' by '\\hspace{" + letter.length + "}'") + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                } else {
                    const subSupChar = Object.values(SUPERSCRIPT).concat(Object.values(SUBSCRIPT)).filter(x => {return x !== "\u2710";});  // Makes sure that there are no spaces that sneaks in
                    if (subSupChar.includes(letter)) {
                        const argPos: string = Object.values(SUPERSCRIPT).includes(letter) ? "superscript" : "subscript";
                        const commandPos: string = (textInput[0] === "^") ? "superscript" : "subscript";
                        errorsList += spaceCommand(textInput + " \u2192 Can't put a " + argPos + " (" + letter + ") in a " + commandPos + " position") + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                };
            };
        } else {
            if ((textInput[0] === "^") || (textInput[0] === "_")) {
                if (textInput.indexOf(" needs an argument.") !== -1) {
                    const example: string = (textInput[0] === "^") ? "¬π" : "‚ÇÅ";
                    errorsList += "For '" + textInput[0] + "' alone: \\" + textInput[0] + " \u2192 " + textInput[0] + 
                    "  |  To use '" + textInput[0] + "' as a command: " + textInput[0] + "{1} \u2192 " + example + "\r\n";
                } else {
                    errorsList += '"' + textInput + '" \u2192 ' + "try: " + textInput[0] + "{" + textInput.slice(1) + "}" + '\r\n';
                };
            } else {
                errorsList += '"' + textInput + '" \r\n';
            };
        };
    };
    if (errorsList.length > 0) {
        popup.textContent = text + errorsList;
    };
    return "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}"; // bold "err" with two "x" under it
};


//-----------------------------------------------------//

/** Matrix document class **/

function matrix(text: string): string {
    // Used in \documentclass{matrix}
    // Converts arrays into a matrix (i.e. [a,b,c][1,2,3] will be converted to a matrix 2x3)
    text = text.replace(/ /g, "");
    let matrixText: string = "";
    let cpt: number = 0;
    let rceil: number = 0;
    let lceil: number = 0;
    let lfloor: number = 0;
    let rfloor: number = 0;

    let i: number;

    for (i=0; i<text.length; i++) {
        if (text[i] == "[" || text[i] == "]") {
            cpt += 1;
        };
    };
    if (cpt == 2) {
        // vector (ie single line matrix)
        matrixText = text.replace(/ /g, "");
        matrixText = matrixText.replace(/\[/g, "[ ");
        matrixText = matrixText.replace(/\]/g, " ]");
        matrixText = matrixText.replace(/,/g, "\u2710");
        return matrixText;
    } else {
        for (i=0; i<text.length; i++) {
            if (text[i] == "[" && rceil == 0) {
                matrixText += "\u23A1 ";
                rceil += 1;
            } else if (text[i] == "]" && lceil == 0) {
                matrixText += " \u23A4\u000A";
                lceil += 1;
            } else if (text[i] == "]") {
                matrixText += " \u23A5\u000A";
            } else if (text[i] == "[") {
                matrixText += "\u23A2 ";
            } else {
                matrixText += text[i];
            }
        };
        let matrixArr: string[];
        for (i = matrixText.length; i>0; i--) {
            if (matrixText[i] == "\u23A5" && i > rfloor) {
                matrixArr = matrixText.split("");
                matrixArr[i] = "\u23A6";
                matrixArr[i+1] = "";  // removes "\u000A" since it's the last line
                matrixText = matrixArr.join("");
                rfloor = i;
            } else if (matrixText[i] == "\u23A2" && i > lfloor) {
                matrixArr = matrixText.split("");
                matrixArr[i] = "\u23A3";
                matrixText = matrixArr.join("");
                lfloor = i;
            };
        };
    };
    matrixText = matrixCols(matrixText);  // Adjusts columns width
    matrixText = matrixText.replace(/,/g, " ");  // Add spaces between characters
    if ((cpt % 2 != 0) || (cpt == 0)) {
        matrixText = "";
        mistakes('Wrong arguments given" \r\n \r\nExample: "$matrix [a,b,c] [d,e,f] [1,2,3]', undefined);
    };
    return matrixText;
};

function matrixCols(matrix: string): string {
    // Adjusts columns length for $matrix package
    // So, if the input is [100,10,1][0,0,0], the output should still be a 2x3 matrix with the elements aligned
    let positionLength: number = 0;
    let posLengths: number[] = [];
    let matrixPositions: number[] = [];
    let matrixPos: number = 0;
    let realPositions: number[] = [];
    
    let i: number, j: number;
    for (i=0; i<matrix.length; i++) {
        if (matrix[i] == ",") {
            matrixPositions.push(matrixPos);
            matrixPos += 1;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-1);
        } else if ((matrix[i] === "\u23A4") || (matrix[i] === "\u23A5") || (matrix[i] === "\u23A6")) {  // right bracket
            matrixPositions.push(matrixPos);
            matrixPos = 0;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-2);
        } else if ((matrix[i] === "\u23A1") || (matrix[i] === "\u23A2") || (matrix[i] === "\u23A3") || (matrix[i] === " ") || (matrix[i] === "\u000A")) {  // left bracket and spaces
            continue;
        } else {
            positionLength += 1;
        };
    };
    // Add spaces to adjust columns length
    let spacesAdded: number = 1;
    let matrixArr: string[];
    for (i=0; i<posLengths.length; i++) {
        for (j=0; j<matrixPositions.length; j++) {
            if (matrixPositions[i] == matrixPositions[j]) {
                matrixArr = matrix.split("");
                while (posLengths[i] < posLengths[j]) {
                    matrixArr.splice(realPositions[i] + spacesAdded, 0, " ");
                    posLengths[i] += 1;
                    spacesAdded += 1;
                };
                matrix = matrixArr.join("");
            };
        };
    };
    return matrix;
};


//-----------------------------------------------------//

/** Automatic spacing **/

function spaceCommand(text: string): string {
    // Add spaces ("\:" command)
    // Internally, spaces that are kept even if 'Adjust spaces' is on are represented as \u2710
    // this commands changes them back to spaces
    text = text.replace(/\u2710/g, " ");
    return text;
};

function adjustSpacesCommon(input: string, symbolSpaced: string[], conditionalSpaces: string[]): string {
    // Removes spaces and add some depending on surrounding symbols
    // Used if 'Adjust space' is on

    /* 
        TODO: Spacing around symbols like '+' should depend of context
        For instance f(y+2) should return f(y+2), but 3x¬≤+4y should return 3x¬≤ + 4y 

        Also, a_{i}-x should return a_{i} - x, but \sum_{i}-x should return \sum_{i}-x (as in \sum_{i}(-x) or -\sum_{i}x)
        Again, it should take the context in consideration
    */
    input = input.slice(0, input.length - 1)  // Since the last char is a space
    if (input.length > 2) {
        const noSpaceSymbols: string[] = Object.values(SUPERSCRIPT).concat(Object.values(SUBSCRIPT), Object.values(ABOVE), Object.values(BELOW)).filter(x => {return x !== "\u2710";});
        const spacedChar: string = characters.concat(...noSpaceSymbols);  // Add space around 'conditionalSpaces' if the previous symbol is in spacedChar
        let output: string = "";
        input = input.replace(/ /g, "");
        let delayedSpace: boolean = false;
        let spaceStored: string[] = [];

        let i: number;
        for (i=0; i<input.length; i++) {
            delayedSpace = noSpaceSymbols.includes(input[i+1]);
            if (symbolSpaced.includes(input[i])) {
                if ((output[output.length - 1] !== " ") && (output[output.length - 1] !== undefined)) {
                    if (delayedSpace) {
                        output += " " + input[i];
                        spaceStored.push(" ");
                    } else {
                        output += " " + input[i] + " ";
                    }
                } else {
                    if (delayedSpace) {
                        output += input[i];
                        spaceStored.push(" ");
                    } else {
                        output += input[i] + " ";
                    };
                };
            } else if (conditionalSpaces.includes(input[i])) {
                if ((output[output.length - 1] !== " ") && (output[output.length - 1] !== undefined) && (spacedChar.includes(output[output.length - 1]))) {
                    if (delayedSpace) {
                        output += " " + input[i];
                    } else {
                        output += " " + input[i] + " ";
                    };
                } else {
                    output += input[i];
                };
            } else {
                if (delayedSpace) {
                    output += input[i];
                } else {
                    if (spaceStored.length >= 1) {
                        output += input[i] + " ";
                        spaceStored = [];
                    }
                    else {
                        output += input[i];
                    };
                };
            };
        };
        return spaceCommand(output);
    } else {
        return spaceCommand(input);
    };
};

function adjustSpaces(input: string): string {
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    const symbolSpaced: string[] = ["=", "\u003D", "\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
                "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
                "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
                "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
                "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
                "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2261", "\u2A67", "\u2263",
                "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
                "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
                "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2225",
                "\u2226", "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u2250",
                "\u2A66", "\u00D7", "\u22CA", "\u22C9", "\u225D"];
    const conditionalSpaces: string[] = ["+", "-", "\u002B", "\u2212", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};

function adjustSpaceChem(input: string): string {
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    const symbolSpaced: string[] = ["\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
            "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
            "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
            "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
            "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
            "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2A67", "\u2250", "\u2A66",
            "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
            "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
            "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2225",
            "\u2226", "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u00D7", 
            "\u22CA", "\u22C9", "\u225D"];
    const conditionalSpaces: string[] = ["+", "\u002B", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};


//-----------------------------------------------------//

/** Main **/

function main(): void {
    // Takes the original text (input) and outputs the new one, with the converted symbols

    mistakesBox.textContent = "";  // Starts with an empty box for errors
    errorsList = "";  // Starts with an empty list of errors

    let fullText: string = textIn.value;
    fullText = fullText.replace(/\u000A/g, " "); // Cancels the line skipped by pressing "enter", use "\\" instead
    fullText += " ";  // Usefull, since a space is a commandStopper

    const [plainTextConverter, packages, renewCommand, documentClass]¬†= getSettings(parametersText.value);
    const dict = makeDict(plainTextConverter, packages, renewCommand);

    let out: string;
    if (documentClass === "chem") {
        out = output(fullText, dict);
        if (spacesButton.checked) {
            out = adjustSpaceChem(out);
        };
    } else if (documentClass === "matrix") {
        out = matrix(fullText);
    } else {
        out = output(fullText, dict);
        if (spacesButton.checked) {  // TODO: Need to adjust spaces only in mathmode
            out = adjustSpaces(out);
        };
        // TODO: Verify in \: is converted to space without adjustSpaces
    };

    textOut.value = out;
    textOut.disabled = false;
};


//-----------------------------------------------------//
