/*
    The main purpose of this program is to take a text as input (mostly LaTeX commands), 
    to convert them into the desired symbol (character) and finally to display them so they can 
    be copied and sent via Messenger, Instagram, Twitter, etc.
*/


/*
    CODE STRUCTURE
    
    N.B. Every section header has the format: /// NAME /// and every subsection: * Name *


    /// GLOBALS ///  -> All the global variables
    ‚îÇ
    ‚îú‚îÄ Functions (as const)
    ‚îú‚îÄ Dictionaries
    ‚îú‚îÄ HTMLElements
    ‚îÇ   ‚îî‚îÄ Settings
    ‚îú‚îÄ Other
    ‚îÇ
    /// FUNCTIONS ///  -> All the functions
    ‚îÇ
    ‚îú‚îÄ Front-end
    ‚îú‚îÄ Build commands and operators
    ‚îú‚îÄ Completion box
    ‚îú‚îÄ Convert text
    ‚îÇ   ‚îú‚îÄ Main functions
    ‚îÇ   ‚îî‚îÄ Used by main functions
    ‚îú‚îÄ Check mistakes
    ‚îú‚îÄ Matrix document class
    ‚îú‚îÄ Automatic spacing
    ‚îî‚îÄ Main
*/


/**************************************************************************************/

"use strict";

/// GLOBALS ///


/** Functions (as const) **/

const mathbb = (arg, initialCommand) => {
    // mathbb stands for math blackboard-bold
    // This function converts the list of characters to the corresponding blackboard-bold character
    const symbols = {
        "A" : "\u{1D538}",
        "B" : "\u{1D539}",
        "C" : "\u2102",
        "D" : "\u{1D53B}",
        "E" : "\u{1D53C}",
        "F" : "\u{1D53D}",
        "G" : "\u{1D53E}",
        "H" : "\u210D",
        "I" : "\u{1D540}",
        "J" : "\u{1D541}",
        "K" : "\u{1D542}",
        "L" : "\u{1D543}",
        "M" : "\u{1D544}",
        "N" : "\u2115",
        "O" : "\u{1D546}",
        "P" : "\u2119",
        "Q" : "\u211A",
        "R" : "\u211D",
        "S" : "\u{1D54A}",
        "T" : "\u{1D54B}",
        "U" : "\u{1D54C}",
        "V" : "\u{1D54D}",
        "W" : "\u{1D54E}",
        "X" : "\u{1D54F}",
        "Y" : "\u{1D550}",
        "Z" : "\u2124",
        "a" : "\u{1D552}",
        "b" : "\u{1D553}",
        "c" : "\u{1D554}",
        "d" : "\u{1D555}",
        "e" : "\u{1D556}",
        "f" : "\u{1D557}",
        "g" : "\u{1D558}",
        "h" : "\u{1D559}",
        "i" : "\u{1D55A}",
        "j" : "\u{1D55B}",
        "k" : "\u{1D55C}",
        "l" : "\u{1D55D}",
        "m" : "\u{1D55E}",
        "n" : "\u{1D55F}",
        "o" : "\u{1D560}",
        "p" : "\u{1D561}",
        "q" : "\u{1D562}",
        "r" : "\u{1D563}",
        "s" : "\u{1D564}",
        "t" : "\u{1D565}",
        "u" : "\u{1D566}",
        "v" : "\u{1D567}",
        "w" : "\u{1D568}",
        "x" : "\u{1D569}",
        "y" : "\u{1D56A}",
        "z" : "\u{1D56B}",

        "ùê¥" : "\u{1D538}",
        "ùêµ" : "\u{1D539}",
        "ùê∂" : "\u2102",
        "ùê∑" : "\u{1D53B}",
        "ùê∏" : "\u{1D53C}",
        "ùêπ" : "\u{1D53D}",
        "ùê∫" : "\u{1D53E}",
        "ùêª" : "\u210D",
        "ùêº" : "\u{1D540}",
        "ùêΩ" : "\u{1D541}",
        "ùêæ" : "\u{1D542}",
        "ùêø" : "\u{1D543}",
        "ùëÄ" : "\u{1D544}",
        "ùëÅ" : "\u2115",
        "ùëÇ" : "\u{1D546}",
        "ùëÉ" : "\u2119",
        "ùëÑ" : "\u211A",
        "ùëÖ" : "\u211D",
        "ùëÜ" : "\u{1D54A}",
        "ùëá" : "\u{1D54B}",
        "ùëà" : "\u{1D54C}",
        "ùëâ" : "\u{1D54D}",
        "ùëä" : "\u{1D54E}",
        "ùëã" : "\u{1D54F}",
        "ùëå" : "\u{1D550}",
        "ùëç" : "\u2124",
        "ùëé" : "\u{1D552}",
        "ùëè" : "\u{1D553}",
        "ùëê" : "\u{1D554}",
        "ùëë" : "\u{1D555}",
        "ùëí" : "\u{1D556}",
        "ùëì" : "\u{1D557}",
        "ùëî" : "\u{1D558}",
        "‚Ñé" : "\u{1D559}",
        "ùëñ" : "\u{1D55A}",
        "ùëó" : "\u{1D55B}",
        "ùëò" : "\u{1D55C}",
        "ùëô" : "\u{1D55D}",
        "ùëö" : "\u{1D55E}",
        "ùëõ" : "\u{1D55F}",
        "ùëú" : "\u{1D560}",
        "ùëù" : "\u{1D561}",
        "ùëû" : "\u{1D562}",
        "ùëü" : "\u{1D563}",
        "ùë†" : "\u{1D564}",
        "ùë°" : "\u{1D565}",
        "ùë¢" : "\u{1D566}",
        "ùë£" : "\u{1D567}",
        "ùë§" : "\u{1D568}",
        "ùë•" : "\u{1D569}",
        "ùë¶" : "\u{1D56A}",
        "ùëß" : "\u{1D56B}",
        
        "ùõæ" : "\u213D",
        "ùõ§" : "\u213E",
        "ùõ±" : "\u213F",
        "ùúã" : "\u213C",
        "ùõ¥" : "\u2140",
        "Œ£" : "\u2140",
        "Œ†" : "\u213F",
        "œÄ" : "\u213C",
        "Œ≥" : "\u213D",
        "Œì" : "\u213E",

        "0" : "\u{1D7D8}",
        "1" : "\u{1D7D9}",
        "2" : "\u{1D7DA}",
        "3" : "\u{1D7DB}",
        "4" : "\u{1D7DC}",
        "5" : "\u{1D7DD}",
        "6" : "\u{1D7DE}",
        "7" : "\u{1D7DF}",
        "8" : "\u{1D7E0}",
        "9" : "\u{1D7E1}",

        "(" : "‚¶Ö",
        "{" : "‚¶É",
        "[" : "‚ü¶",
        "]" : "‚üß",
        "}" : "‚¶Ñ",
        ")" : "‚¶Ü",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const mathbf = (arg, initialCommand) => {
    // mathbf stands for math bold font
    // This function converts the list of characters to the corresponding bold font character
    const symbols = {
        "A" : "\u{1D468}",
        "a" : "\u{1D482}",
        "B" : "\u{1D469}",
        "b" : "\u{1D483}",
        "C" : "\u{1D46A}",
        "c" : "\u{1D484}",
        "D" : "\u{1D46B}",
        "d" : "\u{1D485}",
        "E" : "\u{1D46C}",
        "e" : "\u{1D486}",
        "F" : "\u{1D46D}",
        "f" : "\u{1D487}",
        "G" : "\u{1D46E}",
        "g" : "\u{1D488}",
        "H" : "\u{1D46F}",
        "h" : "\u{1D489}",
        "I" : "\u{1D470}",
        "i" : "\u{1D48A}",
        "J" : "\u{1D471}",
        "j" : "\u{1D48B}",
        "K" : "\u{1D472}",
        "k" : "\u{1D48C}",
        "L" : "\u{1D473}",
        "l" : "\u{1D48D}",
        "M" : "\u{1D474}",
        "m" : "\u{1D48E}",
        "N" : "\u{1D475}",
        "n" : "\u{1D48F}",
        "O" : "\u{1D476}",
        "o" : "\u{1D490}",
        "P" : "\u{1D477}",
        "p" : "\u{1D491}",
        "Q" : "\u{1D478}",
        "q" : "\u{1D492}",
        "R" : "\u{1D479}",
        "r" : "\u{1D493}",
        "S" : "\u{1D47A}",
        "s" : "\u{1D494}",
        "T" : "\u{1D47B}",
        "t" : "\u{1D495}",
        "U" : "\u{1D47C}",
        "u" : "\u{1D496}",
        "V" : "\u{1D47D}",
        "v" : "\u{1D497}",
        "W" : "\u{1D47E}",
        "w" : "\u{1D498}",
        "X" : "\u{1D47F}",
        "x" : "\u{1D499}",
        "Y" : "\u{1D480}",
        "y" : "\u{1D49A}",
        "Z" : "\u{1D481}",
        "z" : "\u{1D49B}",

        "ùê¥" : "\u{1D468}",
        "ùëé" : "\u{1D482}",
        "ùêµ" : "\u{1D469}",
        "ùëè" : "\u{1D483}",
        "ùê∂" : "\u{1D46A}",
        "ùëê" : "\u{1D484}",
        "ùê∑" : "\u{1D46B}",
        "ùëë" : "\u{1D485}",
        "ùê∏" : "\u{1D46C}",
        "ùëí" : "\u{1D486}",
        "ùêπ" : "\u{1D46D}",
        "ùëì" : "\u{1D487}",
        "ùê∫" : "\u{1D46E}",
        "ùëî" : "\u{1D488}",
        "ùêª" : "\u{1D46F}",
        "‚Ñé" : "\u{1D489}",
        "ùêº" : "\u{1D470}",
        "ùëñ" : "\u{1D48A}",
        "ùêΩ" : "\u{1D471}",
        "ùëó" : "\u{1D48B}",
        "ùêæ" : "\u{1D472}",
        "ùëò" : "\u{1D48C}",
        "ùêø" : "\u{1D473}",
        "ùëô" : "\u{1D48D}",
        "ùëÄ" : "\u{1D474}",
        "ùëö" : "\u{1D48E}",
        "ùëÅ" : "\u{1D475}",
        "ùëõ" : "\u{1D48F}",
        "ùëÇ" : "\u{1D476}",
        "ùëú" : "\u{1D490}",
        "ùëÉ" : "\u{1D477}",
        "ùëù" : "\u{1D491}",
        "ùëÑ" : "\u{1D478}",
        "ùëû" : "\u{1D492}",
        "ùëÖ" : "\u{1D479}",
        "ùëü" : "\u{1D493}",
        "ùëÜ" : "\u{1D47A}",
        "ùë†" : "\u{1D494}",
        "ùëá" : "\u{1D47B}",
        "ùë°" : "\u{1D495}",
        "ùëà" : "\u{1D47C}",
        "ùë¢" : "\u{1D496}",
        "ùëâ" : "\u{1D47D}",
        "ùë£" : "\u{1D497}",
        "ùëä" : "\u{1D47E}",
        "ùë§" : "\u{1D498}",
        "ùëã" : "\u{1D47F}",
        "ùë•" : "\u{1D499}",
        "ùëå" : "\u{1D480}",
        "ùë¶" : "\u{1D49A}",
        "ùëç" : "\u{1D481}",
        "ùëß" : "\u{1D49B}",

        "0" : "\u{1D7CE}",
        "1" : "\u{1D7CF}",
        "2" : "\u{1D7D0}",
        "3" : "\u{1D7D1}",
        "4" : "\u{1D7D2}",
        "5" : "\u{1D7D3}",
        "6" : "\u{1D7D4}",
        "7" : "\u{1D7D5}",
        "8" : "\u{1D7D6}",
        "9" : "\u{1D7D7}",

        "‚àÇ" : "\u{1D789}",

        // Greek
        "ùõ¢" : "\u{1D71C}",
        "ùõº" : "\u{1D736}",
        "ùõ£" : "\u{1D71D}",
        "ùõΩ" : "\u{1D737}",
        "ùõ§" : "\u{1D71E}",
        "ùõæ" : "\u{1D738}",
        "Œî" : "\u{1D6AB}",
        "ùõ•" : "\u{1D71F}",
        "ùõø" : "\u{1D739}",
        "ùõ¶" : "\u{1D720}",
        "œµ" : "\u{1D6DC}",
        "Œµ" : "\u{1D6C6}",
        "ùõß" : "\u{1D721}",
        "ùúÅ" : "\u{1D73B}",
        "ùõ®" : "\u{1D722}",
        "ùúÇ" : "\u{1D73C}",
        "Œò" : "\u{1D6BD}",
        "ùúÉ" : "\u{1D73D}",
        "ùúó" : "\u{1D751}",
        "ùõ™" : "\u{1D724}",
        "ùúÑ" : "\u{1D73E}",
        "ùõ´" : "\u{1D725}",
        "ùúÖ" : "\u{1D73F}",
        "ùúò" : "\u{1D752}",
        "ùõ¨" : "\u{1D726}",
        "ùúÜ" : "\u{1D740}",
        "ùõ≠" : "\u{1D727}",
        "ùúá" : "\u{1D741}",
        "ùõÆ" : "\u{1D728}",
        "ùúà" : "\u{1D742}",
        "Œû" : "\u{1D6B5}",
        "ùúâ" : "\u{1D743}",
        "ùõ∞" : "\u{1D72A}",
        "ùúä" : "\u{1D744}",
        "ùõ±" : "\u{1D72B}",
        "ùúã" : "\u{1D745}",
        "ùúõ" : "\u{1D755}",
        "ùõ≤" : "\u{1D72C}",
        "ùúå" : "\u{1D746}",
        "ùúö" : "\u{1D754}",
        "ùõ¥" : "\u{1D72E}",
        "ùúé" : "\u{1D748}",
        "ùúç" : "\u{1D747}",
        "ùõµ" : "\u{1D72F}",
        "ùúè" : "\u{1D749}",
        "ùõ∂" : "\u{1D730}",
        "ùúê" : "\u{1D74A}",
        "Œ¶" : "\u{1D6BD}",
        "ùúô" : "\u{1D753}",
        "ùúë" : "\u{1D74B}",
        "ùõ∏" : "\u{1D732}",
        "ùúí" : "\u{1D74C}",
        "ùõπ" : "\u{1D733}",
        "ùúì" : "\u{1D74D}",
        "‚Ñ¶" : "\u{1D6C0}",
        "ùúî" : "\u{1D74E}",

        "Œë" : "\u{1D756}",
        "Œ±" : "\u{1D770}",
        "Œí" : "\u{1D757}",
        "Œ≤" : "\u{1D771}",
        "Œì" : "\u{1D758}",
        "Œ≥" : "\u{1D772}",
        "Œ¥" : "\u{1D6C5}",
        "Œï" : "\u{1D75A}",
        "Œñ" : "\u{1D75B}",
        "Œ∂" : "\u{1D775}",
        "Œó" : "\u{1D75C}",
        "Œ∑" : "\u{1D776}",
        "Œ∏" : "\u{1D6C9}",
        "œë" : "\u{1D6DD}",
        "Œô" : "\u{1D75E}",
        "Œπ" : "\u{1D6CA}",
        "Œö" : "\u{1D75F}",
        "Œ∫" : "\u{1D779}",
        "œ∞" : "\u{1D78C}",
        "Œõ" : "\u{1D760}",
        "Œª" : "\u{1D77A}",
        "Œú" : "\u{1D761}",
        "Œº" : "\u{1D77B}",
        "Œù" : "\u{1D762}",
        "ŒΩ" : "\u{1D77C}",
        "Œæ" : "\u{1D77D}",
        "Œü" : "\u{1D764}",
        "Œø" : "\u{1D77E}",
        "Œ†" : "\u{1D765}",
        "œÄ" : "\u{1D77F}",
        "œñ" : "\u{1D78F}",
        "Œ°" : "\u{1D766}",
        "œÅ" : "\u{1D780}",
        "œ±" : "\u{1D78E}",
        "Œ£" : "\u{1D768}",
        "œÉ" : "\u{1D782}",
        "œÇ" : "\u{1D781}",
        "Œ§" : "\u{1D769}",
        "œÑ" : "\u{1D783}",
        "Œ•" : "\u{1D76A}",
        "œÖ" : "\u{1D784}",
        "œï" : "\u{1D78D}",
        "œÜ" : "\u{1D785}",
        "Œß" : "\u{1D76C}",
        "œá" : "\u{1D786}",
        "Œ®" : "\u{1D76D}",
        "œà" : "\u{1D787}",
        "Œ©" : "\u{1D76E}",
        "œâ" : "\u{1D788}",

        // mathcal
        "ùíú" : "\u{1D4D0}",
        "ùí∂" : "\u{1D4EA}",
        "‚Ñ¨" : "\u{1D4D1}",
        "ùí∑" : "\u{1D4EB}",
        "ùíû" : "\u{1D4D2}",
        "ùí∏" : "\u{1D4EC}",
        "ùíü" : "\u{1D4D3}",
        "ùíπ" : "\u{1D4ED}",
        "‚Ñ∞" : "\u{1D4D4}",
        "‚ÑØ" : "\u{1D4EE}",
        "‚Ñ±" : "\u{1D4D5}",
        "ùíª" : "\u{1D4EF}",
        "ùí¢" : "\u{1D4D6}",
        "‚Ñä" : "\u{1D4F0}",
        "‚Ñã" : "\u{1D4D7}",
        "ùíΩ" : "\u{1D4F1}",
        "‚Ñê" : "\u{1D4D8}",
        "ùíæ" : "\u{1D4F2}",
        "ùí•" : "\u{1D4D9}",
        "ùíø" : "\u{1D4F3}",
        "ùí¶" : "\u{1D4DA}",
        "ùìÄ" : "\u{1D4F4}",
        "‚Ñí" : "\u{1D4DB}",
        "ùìÅ" : "\u{1D4F5}",
        "‚Ñ≥" : "\u{1D4DC}",
        "ùìÇ" : "\u{1D4F6}",
        "ùí©" : "\u{1D4DD}",
        "ùìÉ" : "\u{1D4F7}",
        "ùí™" : "\u{1D4DE}",
        "‚Ñ¥" : "\u{1D4F8}",
        "ùí´" : "\u{1D4DF}",
        "ùìÖ" : "\u{1D4F9}",
        "ùí¨" : "\u{1D4E0}",
        "ùìÜ" : "\u{1D4FA}",
        "‚Ñõ" : "\u{1D4E1}",
        "ùìá" : "\u{1D4FB}",
        "ùíÆ" : "\u{1D4E2}",
        "ùìà" : "\u{1D4FC}",
        "ùíØ" : "\u{1D4E3}",
        "ùìâ" : "\u{1D4FD}",
        "ùí∞" : "\u{1D4E4}",
        "ùìä" : "\u{1D4FE}",
        "ùí±" : "\u{1D4E5}",
        "ùìã" : "\u{1D4FF}",
        "ùí≤" : "\u{1D4E6}",
        "ùìå" : "\u{1D500}",
        "ùí≥" : "\u{1D4E7}",
        "ùìç" : "\u{1D501}",
        "ùí¥" : "\u{1D4E8}",
        "ùìé" : "\u{1D502}",
        "ùíµ" : "\u{1D4E9}",
        "ùìè" : "\u{1D503}",

        // mathfrak
        "ùîÑ" : "\u{1D56C}",
        "ùîû" : "\u{1D586}",
        "ùîÖ" : "\u{1D56D}",
        "ùîü" : "\u{1D587}",
        "‚Ñ≠" : "\u{1D56E}",
        "ùî†" : "\u{1D588}",
        "ùîá" : "\u{1D56F}",
        "ùî°" : "\u{1D589}",
        "ùîà" : "\u{1D570}",
        "ùî¢" : "\u{1D58A}",
        "ùîâ" : "\u{1D571}",
        "ùî£" : "\u{1D58B}",
        "ùîä" : "\u{1D572}",
        "ùî§" : "\u{1D58C}",
        "‚Ñå" : "\u{1D573}",
        "ùî•" : "\u{1D58D}",
        "‚Ñë" : "\u{1D574}",
        "ùî¶" : "\u{1D58E}",
        "ùîç" : "\u{1D575}",
        "ùîß" : "\u{1D58F}",
        "ùîé" : "\u{1D576}",
        "ùî®" : "\u{1D590}",
        "ùîè" : "\u{1D577}",
        "ùî©" : "\u{1D591}",
        "ùîê" : "\u{1D578}",
        "ùî™" : "\u{1D592}",
        "ùîë" : "\u{1D579}",
        "ùî´" : "\u{1D593}",
        "ùîí" : "\u{1D57A}",
        "ùî¨" : "\u{1D594}",
        "ùîì" : "\u{1D57B}",
        "ùî≠" : "\u{1D595}",
        "ùîî" : "\u{1D57C}",
        "ùîÆ" : "\u{1D596}",
        "‚Ñú" : "\u{1D57D}",
        "ùîØ" : "\u{1D597}",
        "ùîñ" : "\u{1D57E}",
        "ùî∞" : "\u{1D598}",
        "ùîó" : "\u{1D57F}",
        "ùî±" : "\u{1D599}",
        "ùîò" : "\u{1D580}",
        "ùî≤" : "\u{1D59A}",
        "ùîô" : "\u{1D581}",
        "ùî≥" : "\u{1D59B}",
        "ùîö" : "\u{1D582}",
        "ùî¥" : "\u{1D59C}",
        "ùîõ" : "\u{1D583}",
        "ùîµ" : "\u{1D59D}",
        "ùîú" : "\u{1D584}",
        "ùî∂" : "\u{1D59E}",
        "‚Ñ®" : "\u{1D585}",
        "ùî∑" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const mathcal = (arg, initialCommand) => {
    // mathcal stands for math calligraphic
    // This function converts the list of characters to the corresponding calligraphic character
    const symbols = {
        "A" : "\u{1D49C}",
        "a" : "\u{1D4B6}",
        "B" : "\u212C",
        "b" : "\u{1D4B7}",
        "C" : "\u{1D49E}",
        "c" : "\u{1D4B8}",
        "D" : "\u{1D49F}",
        "d" : "\u{1D4B9}",
        "E" : "\u2130",
        "e" : "\u212F",
        "F" : "\u2131",
        "f" : "\u{1D4BB}",
        "G" : "\u{1D4A2}",
        "g" : "\u210A",
        "H" : "\u210B",
        "h" : "\u{1D4BD}",
        "I" : "\u2110",
        "i" : "\u{1D4BE}",
        "J" : "\u{1D4A5}",
        "j" : "\u{1D4BF}",
        "K" : "\u{1D4A6}",
        "k" : "\u{1D4C0}",
        "L" : "\u2112",
        "l" : "\u{1D4C1}",
        "M" : "\u2133",
        "m" : "\u{1D4C2}",
        "N" : "\u{1D4A9}",
        "n" : "\u{1D4C3}",
        "O" : "\u{1D4AA}",
        "o" : "\u2134",
        "P" : "\u{1D4AB}",
        "p" : "\u{1D4C5}",
        "Q" : "\u{1D4AC}",
        "q" : "\u{1D4C6}",
        "R" : "\u211B",
        "r" : "\u{1D4C7}",
        "S" : "\u{1D4AE}",
        "s" : "\u{1D4C8}",
        "T" : "\u{1D4AF}",
        "t" : "\u{1D4C9}",
        "U" : "\u{1D4B0}",
        "u" : "\u{1D4CA}",
        "V" : "\u{1D4B1}",
        "v" : "\u{1D4CB}",
        "W" : "\u{1D4B2}",
        "w" : "\u{1D4CC}",
        "X" : "\u{1D4B3}",
        "x" : "\u{1D4CD}",
        "Y" : "\u{1D4B4}",
        "y" : "\u{1D4CE}",
        "Z" : "\u{1D4B5}",
        "z" : "\u{1D4CF}",

        "ùê¥" : "\u{1D49C}",
        "ùëé" : "\u{1D4B6}",
        "ùêµ" : "\u212C",
        "ùëè" : "\u{1D4B7}",
        "ùê∂" : "\u{1D49E}",
        "ùëê" : "\u{1D4B8}",
        "ùê∑" : "\u{1D49F}",
        "ùëë" : "\u{1D4B9}",
        "ùê∏" : "\u2130",
        "ùëí" : "\u212F",
        "ùêπ" : "\u2131",
        "ùëì" : "\u{1D4BB}",
        "ùê∫" : "\u{1D4A2}",
        "ùëî" : "\u210A",
        "ùêª" : "\u210B",
        "‚Ñé" : "\u{1D4BD}",
        "ùêº" : "\u2110",
        "ùëñ" : "\u{1D4BE}",
        "ùêΩ" : "\u{1D4A5}",
        "ùëó" : "\u{1D4BF}",
        "ùêæ" : "\u{1D4A6}",
        "ùëò" : "\u{1D4C0}",
        "ùêø" : "\u2112",
        "ùëô" : "\u{1D4C1}",
        "ùëÄ" : "\u2133",
        "ùëö" : "\u{1D4C2}",
        "ùëÅ" : "\u{1D4A9}",
        "ùëõ" : "\u{1D4C3}",
        "ùëÇ" : "\u{1D4AA}",
        "ùëú" : "\u2134",
        "ùëÉ" : "\u{1D4AB}",
        "ùëù" : "\u{1D4C5}",
        "ùëÑ" : "\u{1D4AC}",
        "ùëû" : "\u{1D4C6}",
        "ùëÖ" : "\u211B",
        "ùëü" : "\u{1D4C7}",
        "ùëÜ" : "\u{1D4AE}",
        "ùë†" : "\u{1D4C8}",
        "ùëá" : "\u{1D4AF}",
        "ùë°" : "\u{1D4C9}",
        "ùëà" : "\u{1D4B0}",
        "ùë¢" : "\u{1D4CA}",
        "ùëâ" : "\u{1D4B1}",
        "ùë£" : "\u{1D4CB}",
        "ùëä" : "\u{1D4B2}",
        "ùë§" : "\u{1D4CC}",
        "ùëã" : "\u{1D4B3}",
        "ùë•" : "\u{1D4CD}",
        "ùëå" : "\u{1D4B4}",
        "ùë¶" : "\u{1D4CE}",
        "ùëç" : "\u{1D4B5}",
        "ùëß" : "\u{1D4CF}",

        "ùë®" : "\u{1D4D0}",
        "ùíÇ" : "\u{1D4EA}",
        "ùë©" : "\u{1D4D1}",
        "ùíÉ" : "\u{1D4EB}",
        "ùë™" : "\u{1D4D2}",
        "ùíÑ" : "\u{1D4EC}",
        "ùë´" : "\u{1D4D3}",
        "ùíÖ" : "\u{1D4ED}",
        "ùë¨" : "\u{1D4D4}",
        "ùíÜ" : "\u{1D4EE}",
        "ùë≠" : "\u{1D4D5}",
        "ùíá" : "\u{1D4EF}",
        "ùëÆ" : "\u{1D4D6}",
        "ùíà" : "\u{1D4F0}",
        "ùëØ" : "\u{1D4D7}",
        "ùíâ" : "\u{1D4F1}",
        "ùë∞" : "\u{1D4D8}",
        "ùíä" : "\u{1D4F2}",
        "ùë±" : "\u{1D4D9}",
        "ùíã" : "\u{1D4F3}",
        "ùë≤" : "\u{1D4DA}",
        "ùíå" : "\u{1D4F4}",
        "ùë≥" : "\u{1D4DB}",
        "ùíç" : "\u{1D4F5}",
        "ùë¥" : "\u{1D4DC}",
        "ùíé" : "\u{1D4F6}",
        "ùëµ" : "\u{1D4DD}",
        "ùíè" : "\u{1D4F7}",
        "ùë∂" : "\u{1D4DE}",
        "ùíê" : "\u{1D4F8}",
        "ùë∑" : "\u{1D4DF}",
        "ùíë" : "\u{1D4F9}",
        "ùë∏" : "\u{1D4E0}",
        "ùíí" : "\u{1D4FA}",
        "ùëπ" : "\u{1D4E1}",
        "ùíì" : "\u{1D4FB}",
        "ùë∫" : "\u{1D4E2}",
        "ùíî" : "\u{1D4FC}",
        "ùëª" : "\u{1D4E3}",
        "ùíï" : "\u{1D4FD}",
        "ùëº" : "\u{1D4E4}",
        "ùíñ" : "\u{1D4FE}",
        "ùëΩ" : "\u{1D4E5}",
        "ùíó" : "\u{1D4FF}",
        "ùëæ" : "\u{1D4E6}",
        "ùíò" : "\u{1D500}",
        "ùëø" : "\u{1D4E7}",
        "ùíô" : "\u{1D501}",
        "ùíÄ" : "\u{1D4E8}",
        "ùíö" : "\u{1D502}",
        "ùíÅ" : "\u{1D4E9}",
        "ùíõ" : "\u{1D503}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const mathfrak = (arg, initialCommand) => {
    // mathfrak stands for math fraktur
    // This function converts the list of characters to the corresponding fraktur character
    const symbols = {
        "A" : "\u{1D504}",
        "a" : "\u{1D51E}",
        "B" : "\u{1D505}",
        "b" : "\u{1D51F}",
        "C" : "\u212D",
        "c" : "\u{1D520}",
        "D" : "\u{1D507}",
        "d" : "\u{1D521}",
        "E" : "\u{1D508}",
        "e" : "\u{1D522}",
        "F" : "\u{1D509}",
        "f" : "\u{1D523}",
        "G" : "\u{1D50A}",
        "g" : "\u{1D524}",
        "H" : "\u210C",
        "h" : "\u{1D525}",
        "I" : "\u2111",
        "i" : "\u{1D526}",
        "J" : "\u{1D50D}",
        "j" : "\u{1D527}",
        "K" : "\u{1D50E}",
        "k" : "\u{1D528}",
        "L" : "\u{1D50F}",
        "l" : "\u{1D529}",
        "M" : "\u{1D510}",
        "m" : "\u{1D52A}",
        "N" : "\u{1D511}",
        "n" : "\u{1D52B}",
        "O" : "\u{1D512}",
        "o" : "\u{1D52C}",
        "P" : "\u{1D513}",
        "p" : "\u{1D52D}",
        "Q" : "\u{1D514}",
        "q" : "\u{1D52E}",
        "R" : "\u211C",
        "r" : "\u{1D52F}",
        "S" : "\u{1D516}",
        "s" : "\u{1D530}",
        "T" : "\u{1D517}",
        "t" : "\u{1D531}",
        "U" : "\u{1D518}",
        "u" : "\u{1D532}",
        "V" : "\u{1D519}",
        "v" : "\u{1D533}",
        "W" : "\u{1D51A}",
        "w" : "\u{1D534}",
        "X" : "\u{1D51B}",
        "x" : "\u{1D535}",
        "Y" : "\u{1D51C}",
        "y" : "\u{1D536}",
        "Z" : "\u2128",
        "z" : "\u{1D537}",

        "ùê¥" : "\u{1D504}",
        "ùëé" : "\u{1D51E}",
        "ùêµ" : "\u{1D505}",
        "ùëè" : "\u{1D51F}",
        "ùê∂" : "\u212D",
        "ùëê" : "\u{1D520}",
        "ùê∑" : "\u{1D507}",
        "ùëë" : "\u{1D521}",
        "ùê∏" : "\u{1D508}",
        "ùëí" : "\u{1D522}",
        "ùêπ" : "\u{1D509}",
        "ùëì" : "\u{1D523}",
        "ùê∫" : "\u{1D50A}",
        "ùëî" : "\u{1D524}",
        "ùêª" : "\u210C",
        "‚Ñé" : "\u{1D525}",
        "ùêº" : "\u2111",
        "ùëñ" : "\u{1D526}",
        "ùêΩ" : "\u{1D50D}",
        "ùëó" : "\u{1D527}",
        "ùêæ" : "\u{1D50E}",
        "ùëò" : "\u{1D528}",
        "ùêø" : "\u{1D50F}",
        "ùëô" : "\u{1D529}",
        "ùëÄ" : "\u{1D510}",
        "ùëö" : "\u{1D52A}",
        "ùëÅ" : "\u{1D511}",
        "ùëõ" : "\u{1D52B}",
        "ùëÇ" : "\u{1D512}",
        "ùëú" : "\u{1D52C}",
        "ùëÉ" : "\u{1D513}",
        "ùëù" : "\u{1D52D}",
        "ùëÑ" : "\u{1D514}",
        "ùëû" : "\u{1D52E}",
        "ùëÖ" : "\u211C",
        "ùëü" : "\u{1D52F}",
        "ùëÜ" : "\u{1D516}",
        "ùë†" : "\u{1D530}",
        "ùëá" : "\u{1D517}",
        "ùë°" : "\u{1D531}",
        "ùëà" : "\u{1D518}",
        "ùë¢" : "\u{1D532}",
        "ùëâ" : "\u{1D519}",
        "ùë£" : "\u{1D533}",
        "ùëä" : "\u{1D51A}",
        "ùë§" : "\u{1D534}",
        "ùëã" : "\u{1D51B}",
        "ùë•" : "\u{1D535}",
        "ùëå" : "\u{1D51C}",
        "ùë¶" : "\u{1D536}",
        "ùëç" : "\u2128",
        "ùëß" : "\u{1D537}",

        "ùë®" : "\u{1D56C}",
        "ùíÇ" : "\u{1D586}",
        "ùë©" : "\u{1D56D}",
        "ùíÉ" : "\u{1D587}",
        "ùë™" : "\u{1D56E}",
        "ùíÑ" : "\u{1D588}",
        "ùë´" : "\u{1D56F}",
        "ùíÖ" : "\u{1D589}",
        "ùë¨" : "\u{1D570}",
        "ùíÜ" : "\u{1D58A}",
        "ùë≠" : "\u{1D571}",
        "ùíá" : "\u{1D58B}",
        "ùëÆ" : "\u{1D572}",
        "ùíà" : "\u{1D58C}",
        "ùëØ" : "\u{1D573}",
        "ùíâ" : "\u{1D58D}",
        "ùë∞" : "\u{1D574}",
        "ùíä" : "\u{1D58E}",
        "ùë±" : "\u{1D575}",
        "ùíã" : "\u{1D58F}",
        "ùë≤" : "\u{1D576}",
        "ùíå" : "\u{1D590}",
        "ùë≥" : "\u{1D577}",
        "ùíç" : "\u{1D591}",
        "ùë¥" : "\u{1D578}",
        "ùíé" : "\u{1D592}",
        "ùëµ" : "\u{1D579}",
        "ùíè" : "\u{1D593}",
        "ùë∂" : "\u{1D57A}",
        "ùíê" : "\u{1D594}",
        "ùë∑" : "\u{1D57B}",
        "ùíë" : "\u{1D595}",
        "ùë∏" : "\u{1D57C}",
        "ùíí" : "\u{1D596}",
        "ùëπ" : "\u{1D57D}",
        "ùíì" : "\u{1D597}",
        "ùë∫" : "\u{1D57E}",
        "ùíî" : "\u{1D598}",
        "ùëª" : "\u{1D57F}",
        "ùíï" : "\u{1D599}",
        "ùëº" : "\u{1D580}",
        "ùíñ" : "\u{1D59A}",
        "ùëΩ" : "\u{1D581}",
        "ùíó" : "\u{1D59B}",
        "ùëæ" : "\u{1D582}",
        "ùíò" : "\u{1D59C}",
        "ùëø" : "\u{1D583}",
        "ùíô" : "\u{1D59D}",
        "ùíÄ" : "\u{1D584}",
        "ùíö" : "\u{1D59E}",
        "ùíÅ" : "\u{1D585}",
        "ùíõ" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const superscript = (arg, initialCommand, forFrac=false) => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg[0], Superscript, initialCommand, !forFrac);
    if (((output.indexOf(errSymbol) === -1) && (output.filter(e => accents[e] !== undefined).length === 0)) || (forFrac)) {
        return output.concat(extraArgs(arg.slice(1), initialCommand));
    } else {
        return ["^(" + arg[0].join("") + ")"].concat(extraArgs(arg.slice(1), initialCommand));
    };
};

const subscript = (arg, initialCommand, forFrac=false) => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg[0], Subscript, initialCommand, !forFrac);
    if (((output.indexOf(errSymbol) === -1) && (output.filter(e => accents[e] !== undefined).length === 0)) || (forFrac)) {
        return output.concat(extraArgs(arg.slice(1), initialCommand));
    } else {
        return ["_(" + arg[0].join("") + ")"].concat(extraArgs(arg.slice(1), initialCommand));
    };
};

const textbf = (arg, initialCommand) => {
    // textbf stands for text bold font
    // This function converts the list of characters to the corresponding (text) bold font character
	const symbols = {
        "A" : "\u{1D5D4}",
        "a" : "\u{1D5EE}",
        "B" : "\u{1D5D5}",
        "b" : "\u{1D5EF}",
        "C" : "\u{1D5D6}",
        "c" : "\u{1D5F0}",
        "D" : "\u{1D5D7}",
        "d" : "\u{1D5F1}",
        "E" : "\u{1D5D8}",
        "e" : "\u{1D5F2}",
        "F" : "\u{1D5D9}",
        "f" : "\u{1D5F3}",
        "G" : "\u{1D5DA}",
        "g" : "\u{1D5F4}",
        "H" : "\u{1D5DB}",
        "h" : "\u{1D5F5}",
        "I" : "\u{1D5DC}",
        "i" : "\u{1D5F6}",
        "J" : "\u{1D5DD}",
        "j" : "\u{1D5F7}",
        "K" : "\u{1D5DE}",
        "k" : "\u{1D5F8}",
        "L" : "\u{1D5DF}",
        "l" : "\u{1D5F9}",
        "M" : "\u{1D5E0}",
        "m" : "\u{1D5FA}",
        "N" : "\u{1D5E1}",
        "n" : "\u{1D5FB}",
        "O" : "\u{1D5E2}",
        "o" : "\u{1D5FC}",
        "P" : "\u{1D5E3}",
        "p" : "\u{1D5FD}",
        "Q" : "\u{1D5E4}",
        "q" : "\u{1D5FE}",
        "R" : "\u{1D5E5}",
        "r" : "\u{1D5FF}",
        "S" : "\u{1D5E6}",
        "s" : "\u{1D600}",
        "T" : "\u{1D5E7}",
        "t" : "\u{1D601}",
        "U" : "\u{1D5E8}",
        "u" : "\u{1D602}",
        "V" : "\u{1D5E9}",
        "v" : "\u{1D603}",
        "W" : "\u{1D5EA}",
        "w" : "\u{1D604}",
        "X" : "\u{1D5EB}",
        "x" : "\u{1D605}",
        "Y" : "\u{1D5EC}",
        "y" : "\u{1D606}",
        "Z" : "\u{1D5ED}",
        "z" : "\u{1D607}",

        "ùê¥" : "\u{1D5D4}",
        "ùëé" : "\u{1D5EE}",
        "ùêµ" : "\u{1D5D5}",
        "ùëè" : "\u{1D5EF}",
        "ùê∂" : "\u{1D5D6}",
        "ùëê" : "\u{1D5F0}",
        "ùê∑" : "\u{1D5D7}",
        "ùëë" : "\u{1D5F1}",
        "ùê∏" : "\u{1D5D8}",
        "ùëí" : "\u{1D5F2}",
        "ùêπ" : "\u{1D5D9}",
        "ùëì" : "\u{1D5F3}",
        "ùê∫" : "\u{1D5DA}",
        "ùëî" : "\u{1D5F4}",
        "ùêª" : "\u{1D5DB}",
        "‚Ñé" : "\u{1D5F5}",
        "ùêº" : "\u{1D5DC}",
        "ùëñ" : "\u{1D5F6}",
        "ùêΩ" : "\u{1D5DD}",
        "ùëó" : "\u{1D5F7}",
        "ùêæ" : "\u{1D5DE}",
        "ùëò" : "\u{1D5F8}",
        "ùêø" : "\u{1D5DF}",
        "ùëô" : "\u{1D5F9}",
        "ùëÄ" : "\u{1D5E0}",
        "ùëö" : "\u{1D5FA}",
        "ùëÅ" : "\u{1D5E1}",
        "ùëõ" : "\u{1D5FB}",
        "ùëÇ" : "\u{1D5E2}",
        "ùëú" : "\u{1D5FC}",
        "ùëÉ" : "\u{1D5E3}",
        "ùëù" : "\u{1D5FD}",
        "ùëÑ" : "\u{1D5E4}",
        "ùëû" : "\u{1D5FE}",
        "ùëÖ" : "\u{1D5E5}",
        "ùëü" : "\u{1D5FF}",
        "ùëÜ" : "\u{1D5E6}",
        "ùë†" : "\u{1D600}",
        "ùëá" : "\u{1D5E7}",
        "ùë°" : "\u{1D601}",
        "ùëà" : "\u{1D5E8}",
        "ùë¢" : "\u{1D602}",
        "ùëâ" : "\u{1D5E9}",
        "ùë£" : "\u{1D603}",
        "ùëä" : "\u{1D5EA}",
        "ùë§" : "\u{1D604}",
        "ùëã" : "\u{1D5EB}",
        "ùë•" : "\u{1D605}",
        "ùëå" : "\u{1D5EC}",
        "ùë¶" : "\u{1D606}",
        "ùëç" : "\u{1D5ED}",
        "ùëß" : "\u{1D607}",

        "ùòà" : "\u{1D63C}",
        "ùò¢" : "\u{1D656}",
        "ùòâ" : "\u{1D63D}",
        "ùò£" : "\u{1D657}",
        "ùòä" : "\u{1D63E}",
        "ùò§" : "\u{1D658}",
        "ùòã" : "\u{1D63F}",
        "ùò•" : "\u{1D659}",
        "ùòå" : "\u{1D640}",
        "ùò¶" : "\u{1D65A}",
        "ùòç" : "\u{1D641}",
        "ùòß" : "\u{1D65B}",
        "ùòé" : "\u{1D642}",
        "ùò®" : "\u{1D65C}",
        "ùòè" : "\u{1D643}",
        "ùò©" : "\u{1D65D}",
        "ùòê" : "\u{1D644}",
        "ùò™" : "\u{1D65E}",
        "ùòë" : "\u{1D645}",
        "ùò´" : "\u{1D65F}",
        "ùòí" : "\u{1D646}",
        "ùò¨" : "\u{1D660}",
        "ùòì" : "\u{1D647}",
        "ùò≠" : "\u{1D661}",
        "ùòî" : "\u{1D648}",
        "ùòÆ" : "\u{1D662}",
        "ùòï" : "\u{1D649}",
        "ùòØ" : "\u{1D663}",
        "ùòñ" : "\u{1D64A}",
        "ùò∞" : "\u{1D664}",
        "ùòó" : "\u{1D64B}",
        "ùò±" : "\u{1D665}",
        "ùòò" : "\u{1D64C}",
        "ùò≤" : "\u{1D666}",
        "ùòô" : "\u{1D64D}",
        "ùò≥" : "\u{1D667}",
        "ùòö" : "\u{1D64E}",
        "ùò¥" : "\u{1D668}",
        "ùòõ" : "\u{1D64F}",
        "ùòµ" : "\u{1D669}",
        "ùòú" : "\u{1D650}",
        "ùò∂" : "\u{1D66A}",
        "ùòù" : "\u{1D651}",
        "ùò∑" : "\u{1D66B}",
        "ùòû" : "\u{1D652}",
        "ùò∏" : "\u{1D66C}",
        "ùòü" : "\u{1D653}",
        "ùòπ" : "\u{1D66D}",
        "ùò†" : "\u{1D654}",
        "ùò∫" : "\u{1D66E}",
        "ùò°" : "\u{1D655}",
        "ùòª" : "\u{1D66F}",

        "0" : "\u{1D7EC}",
        "1" : "\u{1D7ED}",
        "2" : "\u{1D7EE}",
        "3" : "\u{1D7EF}",
        "4" : "\u{1D7F0}",
        "5" : "\u{1D7F1}",
        "6" : "\u{1D7F2}",
        "7" : "\u{1D7F3}",
        "8" : "\u{1D7F4}",
        "9" : "\u{1D7F5}",

        // These symbols don't exist in textbf, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
		" " : "\u2710",
        "\u000A" : "\u000A",
        "" : ""
	};
	return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const textit = (arg, initialCommand) => {
    // textit stands for text italic
    // This function converts the list of characters to the corresponding italic character
    const symbols = {
        "A" : "\u{1D608}",
        "a" : "\u{1D622}",
        "B" : "\u{1D609}",
        "b" : "\u{1D623}",
        "C" : "\u{1D60A}",
        "c" : "\u{1D624}",
        "D" : "\u{1D60B}",
        "d" : "\u{1D625}",
        "E" : "\u{1D60C}",
        "e" : "\u{1D626}",
        "F" : "\u{1D60D}",
        "f" : "\u{1D627}",
        "G" : "\u{1D60E}",
        "g" : "\u{1D628}",
        "H" : "\u{1D60F}",
        "h" : "\u{1D629}",
        "I" : "\u{1D610}",
        "i" : "\u{1D62A}",
        "J" : "\u{1D611}",
        "j" : "\u{1D62B}",
        "K" : "\u{1D612}",
        "k" : "\u{1D62C}",
        "L" : "\u{1D613}",
        "l" : "\u{1D62D}",
        "M" : "\u{1D614}",
        "m" : "\u{1D62E}",
        "N" : "\u{1D615}",
        "n" : "\u{1D62F}",
        "O" : "\u{1D616}",
        "o" : "\u{1D630}",
        "P" : "\u{1D617}",
        "p" : "\u{1D631}",
        "Q" : "\u{1D618}",
        "q" : "\u{1D632}",
        "R" : "\u{1D619}",
        "r" : "\u{1D633}",
        "S" : "\u{1D61A}",
        "s" : "\u{1D634}",
        "T" : "\u{1D61B}",
        "t" : "\u{1D635}",
        "U" : "\u{1D61C}",
        "u" : "\u{1D636}",
        "V" : "\u{1D61D}",
        "v" : "\u{1D637}",
        "W" : "\u{1D61E}",
        "w" : "\u{1D638}",
        "X" : "\u{1D61F}",
        "x" : "\u{1D639}",
        "Y" : "\u{1D620}",
        "y" : "\u{1D63A}",
        "Z" : "\u{1D621}",
        "z" : "\u{1D63B}",

        "ùê¥" : "\u{1D608}",
        "ùëé" : "\u{1D622}",
        "ùêµ" : "\u{1D609}",
        "ùëè" : "\u{1D623}",
        "ùê∂" : "\u{1D60A}",
        "ùëê" : "\u{1D624}",
        "ùê∑" : "\u{1D60B}",
        "ùëë" : "\u{1D625}",
        "ùê∏" : "\u{1D60C}",
        "ùëí" : "\u{1D626}",
        "ùêπ" : "\u{1D60D}",
        "ùëì" : "\u{1D627}",
        "ùê∫" : "\u{1D60E}",
        "ùëî" : "\u{1D628}",
        "ùêª" : "\u{1D60F}",
        "‚Ñé" : "\u{1D629}",
        "ùêº" : "\u{1D610}",
        "ùëñ" : "\u{1D62A}",
        "ùêΩ" : "\u{1D611}",
        "ùëó" : "\u{1D62B}",
        "ùêæ" : "\u{1D612}",
        "ùëò" : "\u{1D62C}",
        "ùêø" : "\u{1D613}",
        "ùëô" : "\u{1D62D}",
        "ùëÄ" : "\u{1D614}",
        "ùëö" : "\u{1D62E}",
        "ùëÅ" : "\u{1D615}",
        "ùëõ" : "\u{1D62F}",
        "ùëÇ" : "\u{1D616}",
        "ùëú" : "\u{1D630}",
        "ùëÉ" : "\u{1D617}",
        "ùëù" : "\u{1D631}",
        "ùëÑ" : "\u{1D618}",
        "ùëû" : "\u{1D632}",
        "ùëÖ" : "\u{1D619}",
        "ùëü" : "\u{1D633}",
        "ùëÜ" : "\u{1D61A}",
        "ùë†" : "\u{1D634}",
        "ùëá" : "\u{1D61B}",
        "ùë°" : "\u{1D635}",
        "ùëà" : "\u{1D61C}",
        "ùë¢" : "\u{1D636}",
        "ùëâ" : "\u{1D61D}",
        "ùë£" : "\u{1D637}",
        "ùëä" : "\u{1D61E}",
        "ùë§" : "\u{1D638}",
        "ùëã" : "\u{1D61F}",
        "ùë•" : "\u{1D639}",
        "ùëå" : "\u{1D620}",
        "ùë¶" : "\u{1D63A}",
        "ùëç" : "\u{1D621}",
        "ùëß" : "\u{1D63B}",

        "ùóî" : "\u{1D63C}",
        "ùóÆ" : "\u{1D656}",
        "ùóï" : "\u{1D63D}",
        "ùóØ" : "\u{1D657}",
        "ùóñ" : "\u{1D63E}",
        "ùó∞" : "\u{1D658}",
        "ùóó" : "\u{1D63F}",
        "ùó±" : "\u{1D659}",
        "ùóò" : "\u{1D640}",
        "ùó≤" : "\u{1D65A}",
        "ùóô" : "\u{1D641}",
        "ùó≥" : "\u{1D65B}",
        "ùóö" : "\u{1D642}",
        "ùó¥" : "\u{1D65C}",
        "ùóõ" : "\u{1D643}",
        "ùóµ" : "\u{1D65D}",
        "ùóú" : "\u{1D644}",
        "ùó∂" : "\u{1D65E}",
        "ùóù" : "\u{1D645}",
        "ùó∑" : "\u{1D65F}",
        "ùóû" : "\u{1D646}",
        "ùó∏" : "\u{1D660}",
        "ùóü" : "\u{1D647}",
        "ùóπ" : "\u{1D661}",
        "ùó†" : "\u{1D648}",
        "ùó∫" : "\u{1D662}",
        "ùó°" : "\u{1D649}",
        "ùóª" : "\u{1D663}",
        "ùó¢" : "\u{1D64A}",
        "ùóº" : "\u{1D664}",
        "ùó£" : "\u{1D64B}",
        "ùóΩ" : "\u{1D665}",
        "ùó§" : "\u{1D64C}",
        "ùóæ" : "\u{1D666}",
        "ùó•" : "\u{1D64D}",
        "ùóø" : "\u{1D667}",
        "ùó¶" : "\u{1D64E}",
        "ùòÄ" : "\u{1D668}",
        "ùóß" : "\u{1D64F}",
        "ùòÅ" : "\u{1D669}",
        "ùó®" : "\u{1D650}",
        "ùòÇ" : "\u{1D66A}",
        "ùó©" : "\u{1D651}",
        "ùòÉ" : "\u{1D66B}",
        "ùó™" : "\u{1D652}",
        "ùòÑ" : "\u{1D66C}",
        "ùó´" : "\u{1D653}",
        "ùòÖ" : "\u{1D66D}",
        "ùó¨" : "\u{1D654}",
        "ùòÜ" : "\u{1D66E}",
        "ùó≠" : "\u{1D655}",
        "ùòá" : "\u{1D66F}",

        "ùü¨" : "ùü¨",
        "ùü≠" : "ùü≠",
        "ùüÆ" : "ùüÆ",
        "ùüØ" : "ùüØ",
        "ùü∞" : "ùü∞",
        "ùü±" : "ùü±",
        "ùü≤" : "ùü≤",
        "ùü≥" : "ùü≥",
        "ùü¥" : "ùü¥",
        "ùüµ" : "ùüµ",

        // These symbols don't exist in textit, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",
        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
        " " : "\u2710",
        "\u000A" : "\u000A",
        "" : ""
	};
	return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const texttt = (arg, initialCommand) => {
    // texttt stands for text typewriter
    // This function converts the list of characters to the corresponding typewriter character
    const symbols = {
        "A" : "\u{1D670}",
        "a" : "\u{1D68A}",
        "B" : "\u{1D671}",
        "b" : "\u{1D68B}",
        "C" : "\u{1D672}",
        "c" : "\u{1D68C}",
        "D" : "\u{1D673}",
        "d" : "\u{1D68D}",
        "E" : "\u{1D674}",
        "e" : "\u{1D68E}",
        "F" : "\u{1D675}",
        "f" : "\u{1D68F}",
        "G" : "\u{1D676}",
        "g" : "\u{1D690}",
        "H" : "\u{1D677}",
        "h" : "\u{1D691}",
        "I" : "\u{1D678}",
        "i" : "\u{1D692}",
        "J" : "\u{1D679}",
        "j" : "\u{1D693}",
        "K" : "\u{1D67A}",
        "k" : "\u{1D694}",
        "L" : "\u{1D67B}",
        "l" : "\u{1D695}",
        "M" : "\u{1D67C}",
        "m" : "\u{1D696}",
        "N" : "\u{1D67D}",
        "n" : "\u{1D697}",
        "O" : "\u{1D67E}",
        "o" : "\u{1D698}",
        "P" : "\u{1D67F}",
        "p" : "\u{1D699}",
        "Q" : "\u{1D680}",
        "q" : "\u{1D69A}",
        "R" : "\u{1D681}",
        "r" : "\u{1D69B}",
        "S" : "\u{1D682}",
        "s" : "\u{1D69C}",
        "T" : "\u{1D683}",
        "t" : "\u{1D69D}",
        "U" : "\u{1D684}",
        "u" : "\u{1D69E}",
        "V" : "\u{1D685}",
        "v" : "\u{1D69F}",
        "W" : "\u{1D686}",
        "w" : "\u{1D6A0}",
        "X" : "\u{1D687}",
        "x" : "\u{1D6A1}",
        "Y" : "\u{1D688}",
        "y" : "\u{1D6A2}",
        "Z" : "\u{1D689}",
        "z" : "\u{1D6A3}",

        "ùê¥" : "\u{1D670}",
        "ùëé" : "\u{1D68A}",
        "ùêµ" : "\u{1D671}",
        "ùëè" : "\u{1D68B}",
        "ùê∂" : "\u{1D672}",
        "ùëê" : "\u{1D68C}",
        "ùê∑" : "\u{1D673}",
        "ùëë" : "\u{1D68D}",
        "ùê∏" : "\u{1D674}",
        "ùëí" : "\u{1D68E}",
        "ùêπ" : "\u{1D675}",
        "ùëì" : "\u{1D68F}",
        "ùê∫" : "\u{1D676}",
        "ùëî" : "\u{1D690}",
        "ùêª" : "\u{1D677}",
        "‚Ñé" : "\u{1D691}",
        "ùêº" : "\u{1D678}",
        "ùëñ" : "\u{1D692}",
        "ùêΩ" : "\u{1D679}",
        "ùëó" : "\u{1D693}",
        "ùêæ" : "\u{1D67A}",
        "ùëò" : "\u{1D694}",
        "ùêø" : "\u{1D67B}",
        "ùëô" : "\u{1D695}",
        "ùëÄ" : "\u{1D67C}",
        "ùëö" : "\u{1D696}",
        "ùëÅ" : "\u{1D67D}",
        "ùëõ" : "\u{1D697}",
        "ùëÇ" : "\u{1D67E}",
        "ùëú" : "\u{1D698}",
        "ùëÉ" : "\u{1D67F}",
        "ùëù" : "\u{1D699}",
        "ùëÑ" : "\u{1D680}",
        "ùëû" : "\u{1D69A}",
        "ùëÖ" : "\u{1D681}",
        "ùëü" : "\u{1D69B}",
        "ùëÜ" : "\u{1D682}",
        "ùë†" : "\u{1D69C}",
        "ùëá" : "\u{1D683}",
        "ùë°" : "\u{1D69D}",
        "ùëà" : "\u{1D684}",
        "ùë¢" : "\u{1D69E}",
        "ùëâ" : "\u{1D685}",
        "ùë£" : "\u{1D69F}",
        "ùëä" : "\u{1D686}",
        "ùë§" : "\u{1D6A0}",
        "ùëã" : "\u{1D687}",
        "ùë•" : "\u{1D6A1}",
        "ùëå" : "\u{1D688}",
        "ùë¶" : "\u{1D6A2}",
        "ùëç" : "\u{1D689}",
        "ùëß" : "\u{1D6A3}",

        "0" : "\u{1D7F6}",
        "1" : "\u{1D7F7}",
        "2" : "\u{1D7F8}",
        "3" : "\u{1D7F9}",
        "4" : "\u{1D7FA}",
        "5" : "\u{1D7FB}",
        "6" : "\u{1D7FC}",
        "7" : "\u{1D7FD}",
        "8" : "\u{1D7FE}",
        "9" : "\u{1D7FF}",

        // These symbols don't exist in texttt, but don't output errors
        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
        " " : "\u2710",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const text = (arg, initialCommand) => {
    // This function doesn't change the output (i.e. "abc" -> "abc")
    const symbols = {
        "A" : "A",
        "a" : "a",
        "B" : "B",
        "b" : "b",
        "C" : "C",
        "c" : "c",
        "D" : "D",
        "d" : "d",
        "E" : "E",
        "e" : "e",
        "F" : "F",
        "f" : "f",
        "G" : "G",
        "g" : "g",
        "H" : "H",
        "h" : "h",
        "I" : "I",
        "i" : "i",
        "J" : "J",
        "j" : "j",
        "K" : "K",
        "k" : "k",
        "L" : "L",
        "l" : "l",
        "M" : "M",
        "m" : "m",
        "N" : "N",
        "n" : "n",
        "O" : "O",
        "o" : "o",
        "P" : "P",
        "p" : "p",
        "Q" : "Q",
        "q" : "q",
        "R" : "R",
        "r" : "r",
        "S" : "S",
        "s" : "s",
        "T" : "T",
        "t" : "t",
        "U" : "U",
        "u" : "u",
        "V" : "V",
        "v" : "v",
        "W" : "W",
        "w" : "w",
        "X" : "X",
        "x" : "x",
        "Y" : "Y",
        "y" : "y",
        "Z" : "Z",
        "z" : "z",

        "ùê¥" : "A",
        "ùëé" : "a",
        "ùêµ" : "B",
        "ùëè" : "b",
        "ùê∂" : "C",
        "ùëê" : "c",
        "ùê∑" : "D",
        "ùëë" : "d",
        "ùê∏" : "E",
        "ùëí" : "e",
        "ùêπ" : "F",
        "ùëì" : "f",
        "ùê∫" : "G",
        "ùëî" : "g",
        "ùêª" : "H",
        "‚Ñé" : "h",
        "ùêº" : "I",
        "ùëñ" : "i",
        "ùêΩ" : "J",
        "ùëó" : "j",
        "ùêæ" : "K",
        "ùëò" : "k",
        "ùêø" : "L",
        "ùëô" : "l",
        "ùëÄ" : "M",
        "ùëö" : "m",
        "ùëÅ" : "N",
        "ùëõ" : "n",
        "ùëÇ" : "O",
        "ùëú" : "o",
        "ùëÉ" : "P",
        "ùëù" : "p",
        "ùëÑ" : "Q",
        "ùëû" : "q",
        "ùëÖ" : "R",
        "ùëü" : "r",
        "ùëÜ" : "S",
        "ùë†" : "s",
        "ùëá" : "T",
        "ùë°" : "t",
        "ùëà" : "U",
        "ùë¢" : "u",
        "ùëâ" : "V",
        "ùë£" : "v",
        "ùëä" : "W",
        "ùë§" : "w",
        "ùëã" : "X",
        "ùë•" : "x",
        "ùëå" : "Y",
        "ùë¶" : "y",
        "ùëç" : "Z",
        "ùëß" : "z",

        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "." : ".",
        "," : ",",
        "'" : "'",
        "‚Ä≤" : "'",
        '"' : '"',
        "‚Ä≥" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¬¢" : "¬¢",
        "¬£" : "¬£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "‚à∂" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "¬∞" : "¬∞",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
        " " : "\u2710",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const hspace = (arg, initialCommand) => {
    // hspace stands for horizontal space
    // Adds the number of space specified in 'arg'
    let spaces = [];
    const num = arg[0].join("");
    if (num * 0 !== 0) {
        spaces.push(mistakes(initialCommand + "{" + num + "}", undefined, "Argument must be a number"));
    } else {
        for (let i=0; i<parseInt(num); i++) {
            spaces.push("\u2710");
        };
    };
    return spaces.concat(extraArgs(arg.slice(1), initialCommand));
};

const vskip = (arg, initialCommand) => {
    // vskip stands for vertical skip
    // Adds the number of linebreaks specified in 'arg'
    let skips = [];
    const num = arg[0].join("");
    if (num * 0 !== 0) {
        skips.push(mistakes(initialCommand + "{" + num + "}", undefined, "Argument must be a number"));
    } else {
        for (let i=0; i<parseInt(num); i++) {
            skips.push("\u000A");
        };
    };
    return skips.concat(extraArgs(arg.slice(1), initialCommand));
};

const phantom = (arg, initialCommand) => {
    // Outputs the same number of spaces as the length of the argument
    // e.g. \phantom{abc} -> 3 spaces and \phantom{\int} -> 1 space
    let spaces = [];
    for (let i=0; i<arg[0].length; i++) {
        spaces.push("\u2710");
    };
    if (arg[0].includes(errSymbol)) {
        mistakes(initialCommand + "{" + arg[0].join("") + "}", undefined, "Undefined argument");
    };
    return spaces.concat(extraArgs(arg.slice(1), initialCommand));
};

const mathord = (arg, initialCommand) => {
    // Removes spaces around arg
    // \mathord{arg} is equivalent to {arg} and \! arg \!
    let output = [];
    for (let i in arg) {
        output.push("\u270E", arg[i].join(""), "\u270E");
        if (arg[i].includes(errSymbol)) {
            mistakes(initialCommand + "{" + arg[i].join("") + "}", undefined, "Undefined argument");
        };
    };
    return output;
};

const sqrt = (arg, initialCommand) => {
    // sqrt stands for square root
    const numStart = parseInt(initialCommand.indexOf("["));
    const numEnd = parseInt(initialCommand.indexOf("]"));
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]{x}", undefined, "‚Åø‚àöùë•");
            return addSymbol(undefined);
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output = "";
    switch (rootNum) {
        // There's already a unicode symbol for square root, cube root and 4th root
        // If rootNum is different than those, the symbol is built
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(superscript([rootNum.split("")], initialCommand)) + "\u221A";
    };
    if (arg[0].length >= 2) {
        output += "(" + addSymbolArray(arg[0], initialCommand + "{" + arg[0].join("") + "}") + ")";
    } else {
        output += addSymbolArray(arg[0], initialCommand + "{" + arg[0].join("") + "}");
    };
    return [output].concat(extraArgs(arg.slice(1), initialCommand));
};

const frac = (arg, initialCommand) => {
    // Used to make a fraction
    // If a character doesn't exist in superscript or subscript, it outputs the fraction in the format f(x)/g(x)
    let output = [];
    if (arg.length < 2) {
        mistakes("\\frac{}{}", undefined, "Two arguments needed");
        return [errSymbol];
    };
    output.push(...addSymbol(superscript([arg[0]], initialCommand, true), true), "\u2215");
    output.push(...addSymbol(subscript([arg[1]], initialCommand, true), true));
    if ((output.indexOf(errSymbol) === -1) && (output.filter(e => accents[e] !== undefined).length === 0)) {
        return output.concat(extraArgs(arg.slice(2), initialCommand));
    } else {
        // TODO: Why???
        if (arg.join("").includes("\u2710")) {
            const spaces = arg.filter(c => {return c.includes("\u2710")});
            for (let i in spaces) {
                mistakes(initialCommand + "{" + arg.join("") + "}", undefined, spaces[i]);
            };
        };
        output = ["(", 
                  addSymbolArray(arg[0], "\\frac{" + arg[0].join("") + "}" + "{" + arg[1].join("") + "}"), 
                  "/", 
                  addSymbolArray(arg[1], "\\frac{" + arg[0].join("") + "}" + "{" + arg[1].join("") + "}"),
                   ")"];
        return output.concat(extraArgs(arg.slice(2), initialCommand));
    };
};

const singleCharFrac = (arg, initialCommand) => {
    // Some fractions already exists as unicode symbols they can be accessed via this function
    let noSpaceArg = arg.slice(0,2).join("").replace(/ /g, "")
                                            .replace(/\u000A/g, "");
    const fractions = {
        "12" : "\u00BD",
        "17" : "‚Öê",
        "19" : "‚Öë",
        "110" : "‚Öí",
        "13"  :"‚Öì",
        "23" : "‚Öî",
        "15" : "‚Öï",
        "25" : "‚Öñ",
        "35" : "‚Öó",
        "45" : "‚Öò",
        "16" : "‚Öô",
        "56" : "‚Öö",
        "18" : "‚Öõ",
        "38" : "‚Öú",
        "58" : "‚Öù",
        "78" : "‚Öû",
        "ac" : "\u2100",
        "as" : "\u2101",
        "co" : "\u2105",
        "cu" : "\u2106"
    };
    let output = fractions[noSpaceArg];
    return (output !== undefined) ? [output].concat(extraArgs(arg.slice(2), initialCommand)) : frac(arg, initialCommand);
};

const pmod = (arg, initialCommand) => {
    // returns ' (mod arg)'
    return ["\u2710(mod\u2710" + arg[0].join("") + ")"].concat(extraArgs(arg.slice(1), initialCommand));
};

const today = () => {
    // returns today's date
    let date = new Date();
    let month = date.toLocaleString('en', {month: 'long'});  // Will change to 'default' when many languages will be supported
    return month + " " + date.getDate() + ", " + date.getFullYear();
};

// These functions call combineSymbols with a predetermined symbol

const overline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0305")};

const underline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0332")};

const vec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D7")};

const hvec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D1")};

const overfrown = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0361", "\u0361")};

const oversmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035D", "\u035D")};

const undersmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035C", "\u035C")};

const hat = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0302")};

const not = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0338")};

const tilde = (arg, initialCommand) => {if ((arg == "\u27F6") ||¬†(arg == "\u2192")) {return ["\u2972"]} else {return combineSymbols(arg, initialCommand, "\u0303", "\u0360")}};

const dot = (arg, initialCommand) => {if ((arg == "=") || (arg == "\u003D")) {return ["\u2250"]} else if (arg == "\u2261") {return ["\u2A67"]} else {return combineSymbols(arg, initialCommand, "\u0307")}};

const ddot = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0308")};

const underarrow = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0362", "\u0362")};

const underharpoon = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20EC")};

const acute = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0301")};

const grave = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0300")};

const bar = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0304")};

const breve = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0306")};

const caron = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030C")};

const doubleAccute = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030B")};

const ringAbove = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030A")};

const cedilla = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0327")};

const dotBelow = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0323")};

const ogonek = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0328")};

// TODO: Change for \stackrel
const above = (arg, initialCommand) => {
    // Returns the symbol to be put above the preceding character in the input text
    if (arg[0].length > 1) {
        return mistakes(initialCommand + "{" + arg[0].join("") + "}", undefined, "Only one argument accepted");
    };
    mistakes(initialCommand + "{" + arg[0].join("") + "}", Above[arg[0][0]], (arg[0][0] !== undefined) ? arg[0][0] : "Argument doesn't exist");
    return [Above[arg[0][0]]].concat(extraArgs(arg.slice(1), initialCommand));
};

const below = (arg, initialCommand) => {
    // Returns the symbol to be put below the preceding character in the input text
    if (arg[0].length > 1) {
        return mistakes(initialCommand + "{" + arg[0].join("") + "}", undefined, "Only one argument accepted");
    };
    mistakes(initialCommand + "{" + arg[0].join("") + "}", Below[arg[0][0]], (arg[0][0] !== undefined) ? arg[0][0] : "Argument doesn't exist");
    return [Below[arg[0][0]]].concat(extraArgs(arg.slice(1), initialCommand));
};


//-----------------------------------------------------//


/** Dictionaries **/

// mathDictionary is the main dict for converting commands into symbols
const mathDictionary = {
    // Math operators
    "\\times" : "\u00D7",
    "\\rtimes" : "\u22CA",
    "\\ltimes" : "\u22C9",
    "\\div" : "\u00F7",
    "\\longdiv" : "\u27CC",
    "\\int" : "\u222B",
    "\\iint" : "\u222C",
    "\\iiint" : "\u222D",
    "\\iiiint" : "\u2A0C",
    "\\oint" : "\u222E",
    "\\oiint" : "\u222F",
    "\\oiiint" : "\u2230",
    "\\intclockwise" : "\u2231",
    "\\ointclockwise" : "\u2232",
    "\\ointctrclockwise" : "\u2233",
    "\\sqint" : "\u2A16",
    "\\fint" : "\u2A0F",
    "\\cupint" : "\u2A1A",
    "\\capint" : "\u2A19",
    "\\overbarint" : "\u2A1B",
    "\\underbarint" : "\u2A1C",
    "\\cupplus" : "\u228E",
    "\\timesint" : "\u2A18",
    "\\ast" : "\u2217",
    "\\star" : "\u22C6",
    "\\partial" : "\u2202",
    "\\nabla" : "\u2207",
    "\\sqrt2" : "\u221A",
    "\\sqrt3" : "\u221B",
    "\\sqrt4" : "\u221C",
    "\\circ" : "\u2218",
    "\\sum" : "\u2211",
    "\\osum" : "\u2A0A",
    "\\sumint" : "\u2A0B",
    "\\prod" : "\u220F",
    "\\cdot" : "\u00B7",
    "\\cdotp" : "\u22C5",
    "\\pm" : "\u00B1",
    "\\mp" : "\u2213",
    "\\emptyset" : "\u2205",
    "\\sin" : "sin",
    "\\cos" : "cos",
    "\\tan" : "tan",
    "\\arcsin" : "arcsin",
    "\\arccos" : "arccos",
    "\\arctan" : "arctan",
    "\\cot" : "cot",
    "\\csc" : "csc",
    "\\sec" : "sec",
    "\\arccot" : "arccot",
    "\\arccsc" : "arccsc",
    "\\arcsec" : "arcsec",
    "\\*" : "*",
    "\\det" : "det",
    "\\rank" : "rank",
    "\\log" : "log",
    "\\ln" : "ln",
    "\\lim" : "lim",
    "\\mod" : "\u2710\u2710mod\u2710",  // 2 spaces + 'mod' + 1 space
    "\\bmod" : "\u2710mod\u2710",  // 1 space + 'mod' + 1 space
    "\\pmod" : pmod,  // 1 space + '(mod' + 1 space + arg + ')'
    "\\cup" : "\u222A",
    "\\Cup" : "\u22D3",
    "\\sqcup" : "\u2294",
    "\\sqCup" : "\u2A4F",
    "\\cap" : "\u2229",
    "\\Cap" : "\u22D2",
    "\\sqcap" : "\u2293",
    "\\sqCap" : "\u2A4E",
    "\\uplus" : "\u228E",
    "\\def" : "\u225D",
    "\\coloneqq" : "\u2254",
    "\\eqqcolon" : "\u2255",
    "\\vee" : "\u2228",
    "\\doublevee" : "\u2A56",
    "\\wedge" : "\u2227",
    "\\doublewedge" : "\u2A55",
    "\\curlyvee" : "\u22CE",
    "\\curlywedge" : "\u22CF",
    "\\diamond" : "\u22C4",
    "\\wr" : "\u2240",
    "\\oplus" : "\u2295",
    "\\ominus" : "\u2296",
    "\\otimes" : "\u2297",
    "\\oslash" : "\u2298",
    "\\odot" : "\u2299",
    "\\obullet" : "\u29BF",
    "\\ocirc" : "\u29BE",
    "\\operp" : "\u29B9",
    "\\oparallel" : "\u29B7",
    "\\oast" : "\u229B",
    "\\oeq" : "\u229C",
    "\\opluslhrim" : "\u2A2D",
    "\\oplusrhrim" : "\u2A2E",
    "\\otimeslhrim" : "\u2A34",
    "\\otimesrhrim" : "\u2A35",
    "\\boxplus" : "\u229E",
    "\\boxminus" : "\u229F",
    "\\boxtimes" : "\u22A0",
    "\\boxdot" : "\u22A1",
    "\\amalg" : "\u2210",
    "\\tprime" : "\u2034",
    "\\lthree" : "\u22CB",
    "\\rthree" : "\u22CC",
    "\\pitchfork" : "\u22D4",
    "\\topfork" : "\u2ADA",
    "\\invamp" : "\u214B",
    "\\originalof" : "\u22B6",
    "\\imageof" : "\u22B7",
    "\\multimap" : "\u22B8",
    "\\leftmultimap" : "\u27DC",
    "\\uptack" : "\u27DF",
    "\\xor" : "\u22BB",
    "\\nand" : "\u22BC",
    "\\nor" : "\u22BD",
    "\\divideontimes" : "\u22C7",
    "\\smashtimes" : "\u2A33",
    "\\fracline" : "\u2215",  // Better suited for superscript over subscript

    // Relations
    "\\forall" : "\u2200",
    "\\exists" : "\u2203",
    "\\nexists" : "\u2204",
    "\\land" : "\u2227",
    "\\lor" : "\u2228",
    "\\sqland" : "\u27CE",
    "\\sqlor" : "\u27CF",
    "\\in" : "\u2208",
    "\\notin" : "\u2209",
    "\\ni" : "\u220B",
    "\\subset" : "\u2282",
    "\\nsubset" : "\u2284",
    "\\subseteq" : "\u2286",
    "\\nsubseteq" : "\u2288",
    "\\supset" : "\u2283",
    "\\nsupset" : "\u2285",
    "\\supseteq" : "\u2287",
    "\\nsupseteq" : "\u2289",
    "\\sqsubset" : "\u228F",
    "\\sqsupset" : "\u2290",
    "\\sqsubseteq" : "\u2291",
    "\\sqsupseteq" : "\u2292",
    "\\Subset" : "\u22D0",
    "\\Supset" : "\u22D1",
    "\\subsetplus" : "\u2ABF",
    "\\supsetplus" : "\u2AC0",
    "\\osubset" : "\u27C3",
    "\\osupset" : "\u27C4",
    "\\setminus" : "\u2216",
    "\\cong" : "\u2245",
    "\\ncong" : "\u2247",
    "\\propto" : "\u221D",
    "\\equiv" : "\u2261",
    "\\dotequiv" : "\u2A67",
    "\\superequiv" : "\u2263",
    "\\tbond" : "\u2261",
    "\\qbond" : "\u2263",
    "\\doteq" : "\u2250",
    "\\eqdot" : "\u2A66",
    "\\neq" : "\u2260",
    "\\approx" : "\u2248",
    "\\sim" : "\u223C",
    "\\simeq" : "\u224C",
    "\\nsim" : "\u2241",
    "\\nless" : "\u226E",
    "\\ngtr" : "\u226F",
    "\\leq" : "\u2264",
    "\\leqslant" : "\u2A7D",
    "\\geq" : "\u2265",
    "\\geqslant" : "\u2A7E",
    "\\nleq" : "\u2270",
    "\\ngeq" : "\u2271",
    "\\lneq" : "\u2A87",
    "\\lneqq" : "\u2268",
    "\\gneq" : "\u2A88",
    "\\gneqq" : "\u2269",
    "\\lnapprox" : "\u2A89",
    "\\gnapprox" : "\u2A8A",
    "\\lnsim" : "\u22E6",
    "\\gnsim" : "\u22E7",
    "\\ll" : "\u226A",
    "\\lll" : "\u22D8",
    "\\gg" : "\u226B",
    "\\ggg" : "\u22D9",
    "\\prec" : "\u227A",
    "\\succ" : "\u227B",
    "\\nprec" : "\u2280",
    "\\nsucc" : "\u2281",
    "\\preceq" : "\u227C",
    "\\succeq" : "\u227D",
    "\\precneqq" : "\u2AB5",
    "\\succneqq" : "\u2AB6",
    "\\precnapprox" : "\u2AB9",
    "\\succnapprox" : "\u2ABA",
    "\\precnsim" : "\u22E8",
    "\\succnsim" : "\u22E9",
    "\\perp" : "\u27C2",
    "\\Perp" : "\u2AEB",
    "\\parallel" : "\u2225",
    "\\nparallel" : "\u2226",
    "\\vvvert" : "\u2AF4",
    "\\nvvvert" : "\u2AF5",
    "\\mid" : "|",
    "\\nmid" : "\u2224",
    "\\asymp" : "\u224D",
    "\\neg" : "\u00AC",
    "\\bowtie" : "\u2A1D",
    "\\vdash" : "\u22A2",
    "\\nvdash" : "\u22AC",
    "\\dashv" : "\u22A3",
    "\\vDash" : "\u22A8",
    "\\Dashv" : "\u2AE4",
    "\\nvDash" : "\u22AD",
    "\\Vdash" : "\u22A9",
    "\\dashV" : "\u2AE3",
    "\\nVdash" : "\u22AE",
    "\\VDash" : "\u22AB",
    "\\DashV" : "\u2AE5",
    "\\nVDash" : "\u22AF",
    "\\triangleleft" : "\u22B2",
    "\\ntriangleleft" : "\u22EA",
    "\\triangleright" : "\u22B3",
    "\\ntriangleright" : "\u22EB",
    "\\ntrianglelefteq" : "\u22EC",
    "\\ntrianglerighteq" : "\u22ED",
    "\\trianglelefteq" : "\u22B4",
    "\\trianglerighteq" : "\u22B5",
    "\\triangleq" : "\u225C",
    "\\equest" : "\u225F",
    "\\lquest" : "\u2A7B",
    "\\rquest" : "\u2A7C",
    "\\mquest" : "\u225E",
    "\\vdots" : "\u22EE",
    "\\cdots" : "\u22EF",
    "\\udots" : "\u22F0",
    "\\ddots" : "\u22F1",
    "\\ldots" : "\u2026",
    "\\top" : "\u22A4",
    "\\bot" : "\u22A5",
    "\\between" : "\u226C",
    "\\therefore" : "\u2234",
    "\\because" : "\u2235",
    "\\squaredots" : "\u2237",
    "\\dotminus" : "\u2238",
    "\\max" : "max",
    "\\min" : "min",
    "\\grad" : "grad",
    "\\curl" : "curl",
    "\\ratio" : "\u2236",  // Same as ":", except with "!chem"

    // Arrows
    "\\Rightarrow" : "\u21D2",
    "\\Leftarrow" : "\u21D0",
    "\\nLeftarrow" : "\u21CD",
    "\\nRightarrow" : "\u21CF",
    "\\nLeftrightarrow" : "\u21CE",
    "\\Uparrow" : "\u21D1",
    "\\Downarrow" : "\u21D3",
    "\\Updownarrow" : "\u21D5",
    "\\rightarrow" : "\u2192",
    "\\to" : "\u2192",
    "\\longrightarrow" : "\u27F6",
    "\\leftarrow" : "\u2190",
    "\\longleftarrow" : "\u27F5",
    "\\leftrightarrow" : "\u2194",
    "\\nleftrightarrow" : "\u21AE",
    "\\uparrow" : "\u2191",
    "\\downarrow" : "\u2193",
    "\\updownarrow" : "\u2195",
    "\\nleftarrow" : "\u219A",
    "\\nrightarrow" : "\u219B",
    "\\Longleftarrow" : "\u27F8",
    "\\implies" : "\u27F9",
    "\\Longrightarrow" : "\u27F9",
    "\\Leftrightarrow" : "\u21D4",
    "\\iff" : "\u27FA",
    "\\mapsto" : "\u27FC",
    "\\rightleftharpoons" : "\u21CC",
    "\\leftrightharpoons" : "\u21CB",
    "\\rightharpoonup" : "\u21C0",
    "\\rightharpoondown" : "\u21C1",
    "\\leftharpoonup" : "\u21BC",
    "\\leftharpoondown" : "\u21BD",
    "\\upharpoonleft" : "\u21BF",
    "\\upharpoonright" : "\u21BE",
    "\\downharpoonleft" : "\u21C3",
    "\\downharpoonright" : "\u21C2", 
    "\\hookleftarrow" : "\u21A9",
    "\\hookrightarrow" : "\u21AA",
    "\\nearrow" : "\u2197",
    "\\searrow" : "\u2198",
    "\\swarrow" : "\u2199",
    "\\nwarrow" : "\u2196",
    "\\Nearrow" : "\u21D7",
    "\\Searrow" : "\u21D8",
    "\\Swarrow" : "\u21D9",
    "\\Nwarrow" : "\u21D6",
    "\\twoheadleftarrow" : "\u219E",
    "\\twoheadrightarrow" : "\u21A0",
    "\\twoheaduparrow" : "\u219F",
    "\\twoheaddownarrow" : "\u21A1",
    "\\Lsh" : "\u21B0",
    "\\Rsh" : "\u21B1",
    "\\leftleftarrows" : "\u21C7",
    "\\rightrightarrows" : "\u21C9",
    "\\rightrightrightarrows" : "\u21F6",
    "\\upuparrows" : "\u21C8",
    "\\downdownarrows" : "\u21CA",
    "\\leftrightarrows" : "\u21C6",
    "\\rightleftarrows" : "\u21C4",
    "\\Lleftarrow" : "\u21DA",
    "\\Rrightarrow" : "\u21DB",
    "\\Uuparrow" : "\u290A",
    "\\Ddownarrow" : "\u290B",
    "\\leftarrowtail" : "\u21A2",
    "\\rightarrowtail" : "\u21A3",
    "\\leftsquigarrow" : "\u21DC",
    "\\rightsquigarrow" : "\u21DD",
    "\\leftrightsquigarrow" : "\u21AD",
    "\\longrightsquiglearrow" : "\u27FF",
    "\\looparrowleft" : "\u21AB",
    "\\looparrowright" : "\u21AC",
    "\\circlearrowleft" : "\u21BA",
    "\\circlearrowright" : "\u21BB",
    "\\curvearrowleft" : "\u21B6",
    "\\curvearrowright" : "\u21B7",
    "\\leftdasharrow" : "\u21E0",
    "\\rightdasharrow" : "\u21E2",
    "\\updasharrow" : "\u21E1",
    "\\downdasharrow" : "\u21E3",
    "\\tildeabovearrow" : "\u2972",
    "\\tildebelowarrow" : "\u2974",
    "\\equalabovearrow" : "\u2971",

    // Hebrew alphabet
    "\\aleph" : "\u2135",
    "\\beth" : "\u2136",
    "\\gimel" : "\u2137",
    "\\dalet" : "\u2138",

    // Convert text
    "\\mathbb" : mathbb,
    "\\mathbf" : mathbf,
    "\\mathcal" : mathcal,
    "\\mathfrak" : mathfrak,
    "^" : superscript,
    "_" : subscript,
    "\\mathrm" : text,
    "\\text" : text,
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,

    // Spaces
    "\\hspace" : hspace,
    "\\vskip" : vskip,
    "\\phantom" : phantom,
    "\\mathord" : mathord,

    // Square root and fractions
    "\\sqrt" : sqrt,
    // "\\sqrt*" : sqrtNoArg,  // TODO: Remove from docs
    "\\frac" : frac,
    "\\frac*" : singleCharFrac,

    // Combining symbols
    "\\overline" : overline,
    "\\underline" : underline,
    "\\underarrow" : underarrow,
    "\\underharpoon" : underharpoon,
    "\\overfrown" : overfrown,
    "\\oversmile" : oversmile,
    "\\undersmile" : undersmile,
    "\\hat" : hat,
    "\\not" : not,
    "\\tilde" : tilde,
    "\\vec" : vec,
    "\\hvec" : hvec,
    "\\dot" : dot,
    "\\ddot" : ddot,
    "\\acute" : acute,
    "\\grave" : grave,
    "\\above" : above,
    "\\below" : below,
    "\\check" : caron,
    "\\breve" : breve,
    "\\bar" : bar,

    // For Lewis Notation
    "\\mdot" : "\u2E31",
    "\\mddot" : "\u003A",

    // Chess
    "\\wking" : "\u2654",
    "\\wqueen" : "\u2655",
    "\\wrook" : "\u2656",
    "\\wbishop" : "\u2657",
    "\\wknight" :"\u2658",
    "\\wpawn" : "\u2659",
    "\\bking" : "\u265A",
    "\\bqueen" : "\u265B",
    "\\brook" : "\u265C",
    "\\bbishop" : "\u265D",
    "\\bknight" :"\u265E",
    "\\bpawn" : "\u265F",

    // Card games
    "\\bspade" : "\u2660",
    "\\wheart" : "\u2661",
    "\\wdiamond" : "\u2662",
    "\\bclub" : "\u2663",
    "\\wspade" : "\u2664",
    "\\bheart" : "\u2665",
    "\\bdiamond" : "\u2666",
    "\\wclub" : "\u2667",

    // Money
    "\\dollar" : "\u0024",
    "\\cent" : "\u00A2",
    "\\pound" : "\u00A3",
    "\\yen" : "\u00A5",
    "\\franc" : "\u20A3",
    "\\euro" : "\u20AC",
    "\\peso" : "\u20B1",
    "\\bitcoin" : "\u20BF",
    "\\austral" : "\u20B3",
    "\\ruble" : "\u20BD",
    "\\hryvnia" : "\u20B4",
    "\\rupee" : "\u20B9",
    "\\lira" : "\u20AA",
    "\\tlira" : "\u20A9",
    "\\won" : "\u20A9",
    "\\baht" : "\u0E3F",

    // Non italic letters
    "\\A" : "A",
    "\\a" : "a",
    "\\B" : "B",
    "\\b" : "b",
    "\\C" : "C",
    "\\c" : "c",
    "\\D" : "D",
    "\\d" : "d",
    "\\E" : "E",
    "\\e" : "e",
    "\\F" : "F",
    "\\f" : "f",
    "\\G" : "G",
    "\\g" : "g",
    "\\H" : "H",
    "\\h" : "h",
    "\\I" : "I",
    "\\i" : "i",
    "\\J" : "J",
    "\\j" : "j",
    "\\K" : "K",
    "\\k" : "k",
    "\\L" : "L",
    "\\l" : "l",
    "\\M" : "M",
    "\\m" : "m",
    "\\N" : "N",
    "\\n" : "n",
    "\\O" : "O",
    "\\o" : "o",
    "\\P" : "P",
    "\\p" : "p",
    "\\Q" : "Q",
    "\\q" : "q",
    "\\R" : "R",
    "\\r" : "r",
    "\\S" : "S",
    "\\s" : "s",
    "\\T" : "T",
    "\\t" : "t",
    "\\U" : "U",
    "\\u" : "u",
    "\\V" : "V",
    "\\v" : "v",
    "\\W" : "W",
    "\\w" : "w",
    "\\X" : "X",
    "\\x" : "x",
    "\\Y" : "Y",
    "\\y" : "y",
    "\\Z" : "Z",
    "\\z" : "z",

    "\\^" : "^",
    "\\_" : "_",

    // Matrix
    "\\id1" : "[1]",
    "\\id2" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u23A4 \u000A \u23A3 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id3" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id4" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 0 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\idn" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u22EF \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 \u22EF \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 \u2710 \u22EE \u2710 \u2710 \u22EE \u2710 \u2710 \u22F1 \u2710 \u2710 \u22EE \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 \u22EF \u2710 1 \u2710 \u23A6",
    
    // To build your own
    "\\mlceil" : "\u23A1",
    "\\mrceil" : "\u23A4",
    "\\mlmid" : "\u23A2",
    "\\mrmid" : "\u23A5",
    "\\mlfloor" : "\u23A3",
    "\\mrfloor" : "\u23A6",

    // Music
    "\\flat" : "\u{1D12C}",
    "\\natural" : "\u{1D12E}",
    "\\sharp" : "\u{1D130}",
    "\\eightnote" : "\u{1D160}",
    "\\sixteenthnote" : "\u{1D161}",
    "\\halfnote" : "\u{1D15E}",
    "\\quarternote" : "\u{1D15F}",
    "\\fullnote" : "\u{1D15D}",
    "\\doublenote" : "\u266B",
    "\\trebleclef" : "\u{1D11E}",
    
    // Box drawing
    "\\boxh" : "\u2500",
    "\\boxbfh" : "\u2501",
    "\\boxH" : "\u2550",
    "\\boxv" : "\u2502",
    "\\boxbfv" : "\u2503",
    "\\boxV" : "\u2551",
    "\\boxdr" : "\u250C",
    "\\boxbfdr" : "\u250F",
    "\\boxDR" : "\u2554",
    "\\boxdl" : "\u2510",
    "\\boxbfdl" : "\u2513",
    "\\boxDL" : "\u2557",
    "\\boxur" : "\u2514",
    "\\boxbfur" : "\u2517",
    "\\boxUR" : "\u255A",
    "\\boxul" : "\u2518",
    "\\boxbful" : "\u251B",
    "\\boxUL" : "\u255D",
    "\\boxvr" : "\u251C",
    "\\boxbfvr" : "\u2523",
    "\\boxVR" : "\u2560",
    "\\boxvl" : "\u2524",
    "\\boxbfvl" : "\u252B",
    "\\boxVL" : "\u2563",
    "\\boxdh" : "\u252C",
    "\\boxbfdh" : "\u2533",
    "\\boxDH" : "\u2566",
    "\\boxuh" : "\u2534",
    "\\boxbfuh" : "\u253B",
    "\\boxUH" : "\u2569",
    "\\boxvh" : "\u253C",
    "\\boxbfvh" : "\u254B",
    "\\boxVH" : "\u256C",

    // Other symbols
    "\\LaTeX" : "ùêø·¥¨ùëá·¥áùëã",
    "\\TeX" : "ùëá·¥áùëã",
    "\\MatTalX" : "ùëÄ·¥Ä·¥õùëá·¥Ä üùëã",
    "\\CaMuS" : "ùê∂·¥¨ùëÄ·¥úùëÜ",  // http://camus.math.usherbrooke.ca/index.html
    "\\infty" : "\u221E",
    "\\iinfin" : "\u29DC",
    "\\tieinfty" : "\u29DD",
    "\\nvinfty" : "\u29DE",
    "\\acidfree" : "\u267E",
    "\\radioactive" : "\u2622",
    "\\biohazard" : "\u2623",
    "\\atom" : "\u269B",
    "\\permil" : "‚Ä∞",
    "\\textperthousand" : "‚Ä∞",  // Weird command name, but trying to respect LaTeX's nomenclature
    "\\perthousand" : "‚Ä±",
    "\\angle" : "\u2220",
    "\\measuredangle" : "\u2221",
    "\\sphericalangle" : "\u2222",
    "\\rightangle" : "\u299C",
    "\\hbar" : "\u210F",
    "\\ell" : "\u2113",
    "\\dagger" : "\u2020",
    "\\ddagger" : "\u2021",
    "\\dddagger" : "\u2E4B",
    "\\hermitian" : "\u22B9",
    "\\qc" : "\u269C",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\wp" : "\u2118",
    "\\laplace" : "\u2112",
    "\\bloch" : "\u212C",
    "\\im" : "\u2111",
    "\\fourier" : "\u2131",
    "\\angstrom" : "\u212B",
    "\\mho" : "\u2127",
    "\\emdash" : "\u2014",
    "\\bullet" : "\u2219",
    "\\textbullet" : "\u2022",
    "\\bigbullet" : "\u25CF",
    "\\langle" : "\u27E8",
    "\\rangle" : "\u27E9",
    "\\llangle" : "\u27EA",
    "\\rrangle" : "\u27EB",
    "\\lceil" : "\u2308",
    "\\rceil" : "\u2309",
    "\\lfloor" : "\u230A",
    "\\rfloor" : "\u230B",
    "\\lBrace" : "\u2983",
    "\\rBrace" : "\u2984",
    "\\%" : "%",
    "\\{" : "{",
    "\\}" : "}",
    "\\(" : "(",
    "\\)" : ")",
    "\\$" : "$",
    "\\backslash" : "\\",
    "\\llbracket" : "\u27E6",
    "\\rrbracket" : "\u27E7",
    "\\llparenthesis" : "\u2985",
    "\\rrparenthesis" : "\u2986",
    "\\frown" : "\u2322",
    "\\smile" : "\u2323",
    "\\qed" : "\u220E",
    "\\blacksquare" : "\u25A0",
    "\\square" : "\u25A1",
    "\\lightning" : "\u21AF",
    "\\dbend" : "\u2621",
    "\\male" : "\u2642",
    "\\female" : "\u2640",
    "\\Hermaphrodite" : "\u26A5",
    "\\neuter" : "\u26B2",
    "\\malemale" : "\u26A3",
    "\\femalefemale" : "\u26A2",
    "\\femalemale" : "\u26A4",
    "\\" : "\\",
    "\\:" : "\u2710",  // Space (internally represented with \u2710 (‚úê), but switched to a real space before output)
    "\\;" : "\u2710\u2710",  // Double space
    "\\quad" : "\u2710\u2710\u2710",
    "\\qquad" : "\u2710\u2710\u2710\u2710",
    "\\!" : "\u270E",  // Remove space (if there's one surrounding \!) \u270E (‚úé) will be removed before the output
    "\\colon" : "\u003A",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009"
};

// Standard dict for greek letters
const stdGreek = {
    "\\Alpha" : "\u{1D6E2}",
    "\\alpha" : "\u{1D6FC}",
    "\\Beta" : "\u{1D6E3}",
    "\\beta" : "\u{1D6FD}",
    "\\Gamma" : "\u{1D6E4}",
    "\\gamma" : "\u{1D6FE}",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u{1D6FF}",
    "\\Epsilon" : "\u{1D6E6}",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u{1D6E7}",
    "\\zeta" : "\u{1D701}",
    "\\Eta" : "\u{1D6E8}",
    "\\eta" : "\u{1D702}",
    "\\Theta" : "\u0398",
    "\\theta" : "\u{1D703}",
    "\\vartheta" : "\u{1D717}",
    "\\Iota" : "\u{1D6EA}",
    "\\iota" : "\u{1D704}",
    "\\Kappa" : "\u{1D6EB}",
    "\\kappa" : "\u{1D705}",
    "\\varkappa" : "\u{1D718}",
    "\\Lambda" : "\u{1D6EC}",
    "\\lambda" : "\u{1D706}",
    "\\Mu" : "\u{1D6ED}",
    "\\mu" : "\u{1D707}",
    "\\Nu" : "\u{1D6EE}",
    "\\nu" : "\u{1D708}",
    "\\Xi" : "\u039E",
    "\\xi" : "\u{1D709}",
    "\\Omicron" : "\u{1D6F0}",
    "\\omicron" : "\u{1D70A}",
    "\\Pi" : "\u{1D6F1}",
    "\\pi" : "\u{1D70B}",
    "\\varpi" : "\u{1D71B}",
    "\\Rho" : "\u{1D6F2}",
    "\\rho" : "\u{1D70C}",
    "\\varrho" : "\u{1D71A}",
    "\\Sigma" : "\u{1D6F4}",
    "\\sigma" : "\u{1D70E}",
    "\\varsigma" : "\u{1D70D}",
    "\\Tau" : "\u{1D6F5}",
    "\\tau" : "\u{1D70F}",
    "\\Upsilon" : "\u{1D6F6}",
    "\\upsilon" : "\u{1D710}",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u{1D719}",
    "\\varphi" : "\u{1D711}",
    "\\Chi" : "\u{1D6F8}",
    "\\chi" : "\u{1D712}",
    "\\Psi" : "\u{1D6F9}",
    "\\psi" : "\u{1D713}",
    "\\Omega" : "\u2126",
    "\\omega" : "\u{1D714}"
};

// Greek letters if the user wants basic UTF-8 characters (nostyle)
const noStyleGreek = {
    "\\Alpha" : "\u0391",
    "\\alpha" : "\u03B1",
    "\\Beta" : "\u0392",
    "\\beta" : "\u03B2",
    "\\Gamma" : "\u0393",
    "\\gamma" : "\u03B3",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u03B4",
    "\\Epsilon" : "\u0395",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u0396",
    "\\zeta" : "\u03B6",
    "\\Eta" : "\u0397",
    "\\eta" : "\u03B7",
    "\\Theta" : "\u0398",
    "\\theta" : "\u03B8",
    "\\vartheta" : "\u03D1",
    "\\Iota" : "\u0399",
    "\\iota" : "\u03B9",
    "\\Kappa" : "\u039A",
    "\\kappa" : "\u03BA",
    "\\varkappa" : "\u03F0",
    "\\Lambda" : "\u039B",
    "\\lambda" : "\u03BB",
    "\\Mu" : "\u039C",
    "\\mu" : "\u03BC",
    "\\Nu" : "\u039D",
    "\\nu" : "\u03BD",
    "\\Xi" : "\u039E",
    "\\xi" : "\u03BE",
    "\\Omicron" : "\u039F",
    "\\omicron" : "\u03BF",
    "\\Pi" : "\u03A0",
    "\\pi" : "\u03C0",
    "\\varpi" : "\u03D6",
    "\\Rho" : "\u03A1",
    "\\rho" : "\u03C1",
    "\\varrho" : "\u03F1",
    "\\Sigma" : "\u03A3",
    "\\sigma" : "\u03C3",
    "\\varsigma" : "\u03C2",
    "\\Tau" : "\u03A4",
    "\\tau" : "\u03C4",
    "\\Upsilon" : "\u03A5",
    "\\upsilon" : "\u03C5",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u03D5",
    "\\varphi" : "\u03C6",
    "\\Chi" : "\u03A7",
    "\\chi" : "\u03C7",
    "\\Psi" : "\u03A8",
    "\\psi" : "\u03C8",
    "\\Omega" : "\u03A9",
    "\\omega" : "\u03C9"
};

// Default dict (in math mode), used in the completion popup
const defaultDict = {...mathDictionary, ...stdGreek};

const textCommands = {
    "\\LaTeX" : "ùêø·¥¨ùëá·¥áùëã",
    "\\TeX" : "ùëá·¥áùëã",
    "\\MatTalX" : "ùëÄ·¥Ä·¥õùëá·¥Ä üùëã",
    "\\CaMuS" : "ùê∂·¥¨ùëÄ·¥úùëÜ",  // http://camus.math.usherbrooke.ca/index.html
    "\\textbullet" : "\u2022",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\%" : "%",
    "\\#" : "#",
    "\\{" : "{",
    "\\}" : "}",
    "\\$" : "$",
    "\\backslash" : "\\",
    "\\textbackslash" : "\\",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009",
    "\\!" : "\u270E",
    "\\O" : "\u00D8",
    "\\o" : "\u00F8",
    "\\i" : "\u0131",
    "\\j" : "\u0237",
    "\\L" : "\u0141",
    "\\l" : "\u0142",
    "\\OE" : "\u0152",
    "\\oe" : "\u0153",
    "\\AE" : "\u00C6",
    "\\ae" : "\u00E6",
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,
    "\\hspace" : hspace,
    "\\vskip" : vskip,
    "\\`" : grave,
    "\\'" : acute,
    "\\^" : hat,
    '\\"' : ddot,
    "\\H" : doubleAccute,
    "\\~" : tilde,
    "\\c" : cedilla,
    "\\k" : ogonek,
    "\\=" : bar,
    "\\b" : underline,
    "\\." : dot,
    "\\d" : dotBelow,
    "\\r" : ringAbove,
    "\\u" : breve,
    "\\v" : caron,
    "\\today" : today()
};

// Superscript is used (by the superscript function) to convert characters to the corresponding superscript character
const Superscript = {
    "0" : "\u2070",
    "1" : "\u00B9",
    "2" : "\u00B2",
    "3" : "\u00B3",
    "4" : "\u2074",
    "5" : "\u2075",
    "6" : "\u2076",
    "7" : "\u2077",
    "8" : "\u2078",
    "9" : "\u2079",

    "+" : "\u207A",
    "-" : "\u207B",
    "\u2212" : "\u207B",
    "=" : "\u207C",
    "‚â†" : "·ôø",
    "(" : "\u207D",
    ")" : "\u207E",
    "\\" : "·ê†",
    "‚àñ" : "·ê†",
    "/" : "·êü",
    "." : "·êß",
    "," : "\u02D2",
    "!" : "Íúù",
    "$" : "·ôö",
    "‚üÇ" : "·óÆ",
    "√ó" : "·ïÅ",
    "‚à´" : "·∂¥",
    "‚àò" : "¬∞",
    "‚àû" : "\u2710\u1AB2\u2710",  // Only works on certain website/apps
    "‚àÖ" : "\u{1D1A9}",
    "*" : "*",
    "<" : "·ëâ",
    "‚à•" : "·ê¶",
    "‚äÇ" : "·íº",
    "‚äÉ" : "·ê£",
    "‚à™" : "·ê°",
    "‚à©" : "·ê¢",
    "‚à®" : "·òÅ",
    "‚àß" : "·∂∫",
    "‚åä" : "·íª",
    "‚åã" : "·íΩ",
    "‚Ñß" : "·∂∑",
    "‚Üë" : "Íúõ",
    "‚Üì" : "Íúú",
    "≈í" : "êû£",
    "≈ì" : "Íüπ",
    "√¶" : "êûÉ",

    "A" : "·¥¨",
    "a" : "·µÉ",
    "B" : "·¥Æ",
    "b" : "·µá",
    "C" : "·∂ú",
    "c" : "·∂ú",
    "D" : "·¥∞",
    "d" : "·µà",
    "E" : "·¥±",
    "e" : "·µâ",
    "f" : "·∂†",
    "G" : "·¥≥",
    "g" : "·µç",
    "H" : "·¥¥",
    "h" : " ∞",
    "I" : "·¥µ",
    "i" : "‚Å±",
    "J" : "·¥∂",
    "j" : " ≤",
    "K" : "·¥∑",
    "k" : "·µè",
    "L" : "·¥∏",
    "l" : "À°",
    "M" : "·¥π",
    "m" : "·µê",
    "N" : "·¥∫",
    "n" : "‚Åø",
    "O" : "·¥º",
    "o" : "·µí",
    "P" : "·¥æ",
    "p" : "·µñ",
    "R" : "·¥ø",
    "r" : " ≥",
    "S" : "À¢",
    "s" : "À¢",
    "T" : "·µÄ",
    "t" : "·µó",
    "U" : "·µÅ",
    "u" : "·µò",
    "V" : "‚±Ω",
    "v" : "·µõ",
    "W" : "·µÇ",
    "w" : " ∑",
    "X" : "À£",
    "x" : "À£",
    "y" : " ∏",
    "Z" : "·ôÜ",
    "z" : "·∂ª",

    "ùê¥" : "·¥¨",
    "ùëé" : "·µÉ",
    "ùêµ" : "·¥Æ",
    "ùëè" : "·µá",
    "ùê∂" : "·∂ú",
    "ùëê" : "·∂ú",
    "ùê∑" : "·¥∞",
    "ùëë" : "·µà",
    "ùê∏" : "·¥±",
    "ùëí" : "·µâ",
    "ùëì" : "·∂†",
    "ùê∫" : "·¥≥",
    "ùëî" : "·µç",
    "ùêª" : "·¥¥",
    "‚Ñé" : " ∞",
    "ùêº" : "·¥µ",
    "ùëñ" : "‚Å±",
    "ùêΩ" : "·¥∂",
    "ùëó" : " ≤",
    "ùêæ" : "·¥∑",
    "ùëò" : "·µè",
    "ùêø" : "·¥∏",
    "ùëô" : "À°",
    "ùëÄ" : "·¥π",
    "ùëö" : "·µê",
    "ùëÅ" : "·¥∫",
    "ùëõ" : "‚Åø",
    "ùëÇ" : "·¥º",
    "ùëú" : "·µí",
    "ùëÉ" : "·¥æ",
    "ùëù" : "·µñ",
    "ùëÖ" : "·¥ø",
    "ùëü" : " ≥",
    "ùëÜ" : "À¢",
    "ùë†" : "À¢",
    "ùëá" : "·µÄ",
    "ùë°" : "·µó",
    "ùëà" : "·µÅ",
    "ùë¢" : "·µò",
    "ùëâ" : "‚±Ω",
    "ùë£" : "·µõ",
    "ùëä" : "·µÇ",
    "ùë§" : " ∑",
    "ùëã" : "À£",
    "ùë•" : "À£",
    "ùë¶" : " ∏",
    "ùëç" : "·∂ª",
    "ùëß" : "·∂ª",

    "ùõΩ" : "\u1D5D",
    "Œ≤" : "\u1D5D", 
    "ùõ§" : "·£ò",
    "Œì" : "·£ò",
    "ùõæ" : "\u1D5E",
    "Œ≥" : "\u1D5E",
    "Œî" : "·êû",
    "Œ¥" : "\u1D5F",
    "ùõø" : "\u1D5F",
    "œµ" : "·µã",
    "Œµ" : "·µã",
    "ùõ¨" : "·£î",
    "Œõ" : "·£î",
    "ùúÉ" : "\u1DBF",
    "Œ∏" : "\u1DBF", 
    "ùúÑ" : "·∂•",
    "Œπ" : "·∂•",
    "ùúà" : "·∂π",
    "ŒΩ" : "·∂π",
    "ùúé" : "·£ô",
    "œÉ" : "·£ô",
    "Œ¶" : "·∂≤",
    "ùúô" : "·∂≤",
    "œï" : "·∂≤",
    "ùúë" : "\u1D60",
    "œÜ" : "\u1D60",
    "ùúå" : "·£ñ",
    "œÅ" : "·£ñ",
    "ùúí" : "\u1D61",
    "œá" : "\u1D61",

    "\u2710" : "\u2710",
    "\u270E" : "\u270E",
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Subscript is used (by the subscript function) to convert characters to the corresponding subscript character
const Subscript = {
    "0" : "\u2080",
    "1" : "\u2081",
    "2" : "\u2082",
    "3" : "\u2083",
    "4" : "\u2084",
    "5" : "\u2085",
    "6" : "\u2086",
    "7" : "\u2087",
    "8" : "\u2088",
    "9" : "\u2089",

    "+" : "\u208A",
    "-" : "\u208B",
    "\u2212" : "\u208B",
    "=" : "\u208C",
    "(" : "\u208D",
    ")" : "\u208E",
    "," : "\u2710\u0326\u2710",
    "." : "\u2710\u0323\u2710",
    "√ó" : "·ôÆ",

    "a" : "\u2090",
    "e" : "\u2091",
    "h" : "\u2095",
    "i" : "\u1D62",
    "j" : "‚±º",
    "k" : "\u2096",
    "l" : "\u2097",
    "m" : "\u2098",
    "n" : "\u2099",
    "O" : "\u2092",
    "o" : "\u2092",
    "p" : "\u209A",
    "r" : "·µ£",
    "S" : "\u209B",
    "s" : "\u209B",
    "t" : "\u209C",
    "u" : "·µ§",
    "V" : "·µ•",
    "v" : "·µ•",
    "X" : "\u2093",
    "x" : "\u2093",

    "ùëé" : "\u2090",
    "ùëí" : "\u2091",
    "‚Ñé" : "\u2095",
    "ùëñ" : "\u1D62",
    "ùëó" : "‚±º",
    "ùëò" : "\u2096",
    "ùëô" : "\u2097",
    "ùëö" : "\u2098",
    "ùëõ" : "\u2099",
    "ùëÇ" : "\u2092",
    "ùëú" : "\u2092",
    "ùëù" : "\u209A",
    "ùëü" : "·µ£",
    "ùëÜ" : "\u209B",
    "ùë†" : "\u209B",
    "ùë°" : "\u209C",
    "ùë¢" : "·µ§",
    "ùëâ" : "·µ•",
    "ùë£" : "·µ•",
    "ùëã" : "\u2093",
    "ùë•" : "\u2093",

    "ùõΩ" : "\u1D66",
    "Œ≤" : "\u1D66",
    "ùõæ" : "\u1D67",
    "Œ≥" : "\u1D67",
    "ùúå" : "\u1D68",
    "œÅ" : "\u1D68",
    "ùúë" : "\u1D69",
    "œÜ" : "\u1D69",
    "ùúô" : "\u1D69",
    "œï" : "\u1D69",
    "ùúí" : "\u1D6A",
    "œá" : "\u1D6A",

    "‚Üí" : "\u2710\u2710\u0362\u2710\u2710",
    "‚àû" : "\u2710\u035A\u2710",

    "\u2710" : "\u2710",
    "\u270E" : "\u270E",
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Dict with characters and their corresponding symbol that can be combined and put above another symbol
const Above = {
    "." : "\u0307",
    ":" : "\u0308",
    "\u2236" : "\u0308",
    "-" : "\u0305",
    "‚àí" : "\u0305",
    "`" : "\u0300",
    "¬¥" : "\u0301",
    "^" : "\u0302",
    "=" : "\u033F",
    "‚àº" : "\u0303",
    "‚àû" : "\u1AB2", // Only works on certain website/apps
    "‚àò" : "\u030A",
    "¬∞" : "\u030A",
    "a" : "\u0363",
    "ùëé" : "\u0363",
    "b" : "\u1DE8",
    "ùëè" : "\u1DE8",
    "c" : "\u0368",
    "ùëê" : "\u0368",
    "d" : "\u0369",
    "ùëë" : "\u0369",
    "e" : "\u0364",
    "ùëí" : "\u0364",
    "f" : "\u1DEB",
    "ùëì" : "\u1DEB",
    "h" : "\u036A",
    "‚Ñé" : "\u036A",
    "i" : "\u0365",
    "ùëñ" : "\u0365",
    "k" : "\u1DDC",  // Only works on certain website/apps
    "ùëò" : "\u1DDC",
    "m" : "\u036B",
    "ùëö" : "\u036B",
    "N" : "\u1DE1",
    "ùëÅ" : "\u1DE1",
    "n" : "\u1DE0",  // Only works on certain website/apps
    "ùëõ" : "\u1DE0",
    "o" : "\u0366",
    "ùëú" : "\u0366",
    "p" : "\u1DEE",
    "ùëù" : "\u1DEE",
    "R" : "\u1DE2",
    "ùëÖ" : "\u1DE2",
    "r" : "\u036C",
    "ùëü" : "\u036C",
    "t" : "\u036D",
    "ùë°" : "\u036D",
    "u" : "\u0367",
    "ùë¢" : "\u0367",
    "v" : "\u036E",
    "ùë£" : "\u036E",
    "x" : "\u036F",
    "ùë•" : "\u036F",

    "ùõº" : "\u1DE7",
    "Œ±" : "\u1DE7",
    "ùõΩ" : "\u1DE9",
    "Œ≤" : "\u1DE9",

    "‚Üº" : "\u20D0",
    "‚áÄ" : "\u20D1",
    "‚Üî" : "\u20E1",
    "‚Ü∂" : "\u20D4",
    "‚Ü∑" : "\u20D5",
    "‚Üê" : "\u20D6",
    "‚Üí" : "\u20D7",
    "‚Üì" : "\u1AB3",
    "‚à¥" : "\u1AB4",
    "‚ãØ" : "\u20DB",
    "‚Ä¶" : "\u20DB",
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Dict with characters and their corresponding symbol that can be combined and put below another symbol
const Below = {
    "." : "\u0323",
    ":" : "\u0324",
    "\u2236" : "\u0324",
    "-" : "\u0332",
    "‚àí" : "\u0332",
    "=" : "\u0333",
    "m" : "\u1AC0",
    "ùëö" : "\u1AC0",
    "x" : "\u0353",
    "ùë•" : "\u0353",
    "w" : "\u1ABF",
    "ùë§" : "\u1ABF",
    "‚ÜΩ" : "\u20ED",
    "‚áÅ" : "\u20EC",
    "‚Üê" : "\u20EE",
    "‚Üí" : "\u20EF",
    "‚Üî" : "\u034D",
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Regular dict used to convert characters that are not a command
// Automatically convert text into a mathematical font
const lettersMath = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "¬∞" : "¬∞",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "*" : "*",
    "@" : "@",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "<",
    ">" : ">",
    "%" : "%",
    "#" : "#",
    "~" : "~",
    "¬¨" : "¬¨",
    ":" : "\u2236",
    ";" : ";",
    "‚Ä¶" : "‚Ä¶",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9",
    "A" : "\u{1D434}",
    "a" : "\u{1D44E}",
    "B" : "\u{1D435}",
    "b" : "\u{1D44F}",
    "C" : "\u{1D436}",
    "c" : "\u{1D450}",
    "D" : "\u{1D437}",
    "d" : "\u{1D451}",
    "E" : "\u{1D438}",
    "e" : "\u{1D452}",
    "F" : "\u{1D439}",
    "f" : "\u{1D453}",
    "G" : "\u{1D43A}",
    "g" : "\u{1D454}",
    "H" : "\u{1D43B}",
    "h" : "\u210E",
    "I" : "\u{1D43C}",
    "i" : "\u{1D456}",
    "J" : "\u{1D43D}",
    "j" : "\u{1D457}",
    "K" : "\u{1D43E}",
    "k" : "\u{1D458}",
    "L" : "\u{1D43F}",
    "l" : "\u{1D459}",
    "M" : "\u{1D440}",
    "m" : "\u{1D45A}",
    "N" : "\u{1D441}",
    "n" : "\u{1D45B}",
    "O" : "\u{1D442}",
    "o" : "\u{1D45C}",
    "P" : "\u{1D443}",
    "p" : "\u{1D45D}",
    "Q" : "\u{1D444}",
    "q" : "\u{1D45E}",
    "R" : "\u{1D445}",
    "r" : "\u{1D45F}",
    "S" : "\u{1D446}",
    "s" : "\u{1D460}",
    "T" : "\u{1D447}",
    "t" : "\u{1D461}",
    "U" : "\u{1D448}",
    "u" : "\u{1D462}",
    "V" : "\u{1D449}",
    "v" : "\u{1D463}",
    "W" : "\u{1D44A}",
    "w" : "\u{1D464}",
    "X" : "\u{1D44B}",
    "x" : "\u{1D465}",
    "Y" : "\u{1D44C}",
    "y" : "\u{1D466}",
    "Z" : "\u{1D44D}",
    "z" : "\u{1D467}",
    "\u2710" : " ",
    " " : " ",
    "\u000A" : "",
    "" : ""
};

// Dict used to convert characters that are not a command if the keyword !chem is used as the fist word of the text input
const lettersNoFont = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "¬∞" : "¬∞",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "<",
    ">" : ">",
    "%" : "%",
    "*" : "*",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "¬¨" : "¬¨",
    ":" : ":",  // Same as "\colon", use "\ratio" instead to get the same as without "!chem"
    ";" : ";",
    "‚Ä¶" : "‚Ä¶",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "a" : "a",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "c" : "c",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "e" : "e",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "i" : "i",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "o" : "o",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    "\u2710" : " ",
    " " : " ",
    "\u000A" : "",
    "" : ""
};

const lettersOutMathMode = {
    "+" : "+",
    "-" : "-",
    "=" : "=",
    "'" : "'",
    '"' : '"',
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "¬∞" : "¬∞",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "<",
    ">" : ">",
    "%" : "%",
    "*" : "*",
    "^" : "^",
    "_" : "_",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "¬¨" : "¬¨",
    ":" : ":",
    ";" : ";",
    "‚Ä¶" : "‚Ä¶",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "a" : "a",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "c" : "c",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "e" : "e",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "i" : "i",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "o" : "o",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    "\u2710" : " ",
    " " : " ",
    "\u000A" : "",
    "" : ""
};

const accents = {
    "\u0300" : "\u0300",
    "\u0301" : "\u0301",
    "\u0302" : "\u0302",
    "\u0303" : "\u0303",
    "\u0304" : "\u0304",
    "\u0305" : "\u0305",
    "\u0306" : "\u0306",
    "\u0307" : "\u0307",
    "\u0308" : "\u0308",
    "\u0309" : "\u0309",
    "\u030A" : "\u030A",
    "\u030B" : "\u030B",
    "\u030C" : "\u030C",
    "\u030D" : "\u030D",
    "\u030E" : "\u030E",
    "\u030F" : "\u030F",
    "\u0310" : "\u0310",
    "\u0311" : "\u0311",
    "\u0312" : "\u0312",
    "\u0313" : "\u0313",
    "\u0314" : "\u0314",
    "\u0315" : "\u0315",
    "\u0316" : "\u0316",
    "\u0317" : "\u0317",
    "\u0318" : "\u0318",
    "\u0319" : "\u0319",
    "\u031A" : "\u031A",
    "\u031B" : "\u031B",
    "\u031C" : "\u031C",
    "\u031D" : "\u031D",
    "\u031E" : "\u031E",
    "\u031F" : "\u031F",
    "\u0320" : "\u0320",
    "\u0321" : "\u0321",
    "\u0322" : "\u0322",
    "\u0323" : "\u0323",
    "\u0324" : "\u0324",
    "\u0325" : "\u0325",
    "\u0326" : "\u0326",
    "\u0327" : "\u0327",
    "\u0328" : "\u0328",
    "\u0329" : "\u0329",
    "\u032A" : "\u032A",
    "\u032B" : "\u032B",
    "\u032C" : "\u032C",
    "\u032D" : "\u032D",
    "\u032E" : "\u032E",
    "\u032F" : "\u032F",
    "\u0330" : "\u0330",
    "\u0331" : "\u0331",
    "\u0332" : "\u0332",
    "\u0333" : "\u0333",
    "\u0334" : "\u0334",
    "\u0335" : "\u0335",
    "\u0336" : "\u0336",
    "\u0337" : "\u0337",
    "\u0338" : "\u0338",
    "\u0339" : "\u0339",
    "\u033A" : "\u033A",
    "\u033B" : "\u033B",
    "\u033C" : "\u033C",
    "\u033D" : "\u033D",
    "\u033E" : "\u033E",
    "\u033F" : "\u033F",
    "\u0340" : "\u0340",
    "\u0341" : "\u0341",
    "\u0342" : "\u0342",
    "\u0343" : "\u0343",
    "\u0344" : "\u0344",
    "\u0345" : "\u0345",
    "\u0346" : "\u0346",
    "\u0347" : "\u0347",
    "\u0348" : "\u0348",
    "\u0349" : "\u0349",
    "\u034A" : "\u034A",
    "\u034B" : "\u034B",
    "\u034C" : "\u034C",
    "\u034D" : "\u034D",
    "\u034E" : "\u034E"
};

// This object contains the functions to create or modify commands
const settingsFunctions = {
    "\\newcommand" : newCommand,
    "\\renewcommand" : renewCommand,
    "\\DeclareMathOperator" : declareMathOperator,
    "\\DeclareUnicodeCharacter" : declareUnicodeCharacter
};


//-----------------------------------------------------//


/** HTMLElements **/

// Convert button
const convertButton = document.getElementById("convert");
convertButton.onclick = function() {main()};

// Copy button
const copyButton = document.getElementById("copy");
copyButton.onclick = function() {copyTextOut()};

// Clear button
const resetButton = document.getElementById("reset");
resetButton.onclick = function() {clear()};

// Button to open the completion popup
const completionBtn = document.getElementById("completionBtn");
completionBtn.onclick = function() {getCompletion()};

// Originally hidden
// Can be accessed with a keyboard shortcut (Alt+C by default) or by clicking the button
const completionPopup = document.getElementById("completion");

// Adjust spaces button
const spacesButton = document.getElementById("adjust");

// Mathematical font button
const changeFontButton = document.getElementById("mathFont");

// Math mode button
const changeModeButton = document.getElementById("mathMode");

// Settings popup
const settingsBtn = document.getElementById("settingsBtn");
settingsBtn.onclick = function() {openSettings()};
const settingsBox = document.getElementById("settingsBox");
const resetSettingsButton = document.getElementById("resetSettingsBtn");
resetSettingsButton.onclick = function() {resetSettings()};

// First and second text box
const textIn = document.getElementById("text_in");
const textOut = document.getElementById("text_out");

const mistakesBox = document.getElementById("mistakes");


// Settings

// Style
const darkMode = document.getElementById("darkMode");
const fontSize = document.getElementById("fontSize");
const fontFamily = document.getElementById("fontFamily");

// Keyboard shortcuts

// Shortcuts settings
const setCopyInputKey = document.getElementById("shortCopyInputK");
const setCopyInputLetter = document.getElementById("shortCopyInputL");
const setCopyOutputKey = document.getElementById("shortCopyOutputK");
const setCopyOutputLetter = document.getElementById("shortCopyOutputL");
const setCompletionKey = document.getElementById("shortCompletionK");
const setCompletionLetter = document.getElementById("shortCompletionL");
const showCompletionBtn = document.getElementById("showCompletionBtn");

// Shortcuts info (in dropdownInfo)
const shortcutsList = document.getElementById("shortcuts");
const textOpenMatTalX = document.getElementById("short_open_mattalx_command");
const textCopyInputKey = document.getElementById("short_copy_input_key");
const textCopyInputLetter = document.getElementById("short_copy_input_letter");
const textCopyOutputKey = document.getElementById("short_copy_output_key");
const textCopyOutputLetter = document.getElementById("short_copy_output_letter");
const textCompletionKey = document.getElementById("short_open_completion_key");
const textCompletionLetter = document.getElementById("short_open_completion_letter");

// Commands & Operators
const buildCommandsBtn = document.getElementById("buildNewCommand");
buildCommandsBtn.onclick = function() {buildNewCommand()};
const commandsBuilt = document.getElementById("commandsBuilt");

//-----------------------------------------------------//


/** Other **/

// Used in the subsection 'Completion box' to recognize on which word is the cursor
const wordsDelimiters = [" ", "", "\u000A", "\\", "^", "_", "(", ")", "[", "]", "{", "}", ".", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!", "$"];
const wordsDelimitersWOB = [" ", "", "\u000A", "^", "_", "(", ")", "[", "]", "{", "}", ".", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!", "$"]; // Without backslash

// Used in adjustSpacesCommon to chose which symbols to surround with spaces (if touched by a specific symbol like '+' or '-')
const characters = "A√Ä√ÇBC√áDE√â√à√ã√äFGHIJKLMNO√î√ñPQRSTU√ô√õVWXYZa√†√¢bc√ßde√©√®√™√´fghijklmno√¥√∂pqrstu√π√ªvwxyz0123456789"+
                   "ùê¥ùêµùê∂ùê∑ùê∏ùêπùê∫ùêªùêºùêΩùêæùêøùëÄùëÅùëÇùëÉùëÑùëÖùëÜùëáùëàùëâùëäùëãùëåùëçùëéùëèùëêùëëùëíùëìùëî‚Ñéùëñùëóùëòùëôùëöùëõùëúùëùùëûùëüùë†ùë°ùë¢ùë£ùë§ùë•ùë¶ùëß"+
                   "ùî∏ùîπ‚ÑÇùîªùîºùîΩùîæ‚ÑçùïÄùïÅùïÇùïÉùïÑ‚ÑïùïÜ‚Ñô‚Ñö‚Ñùùïäùïãùïåùïçùïéùïèùïê‚Ñ§ùïíùïìùïîùïïùïñùïóùïòùïôùïöùïõùïúùïùùïûùïüùï†ùï°ùï¢ùï£ùï§ùï•ùï¶ùïßùï®ùï©ùï™ùï´ùüòùüôùüöùüõùüúùüùùüûùüüùü†ùü°"+
                   "ùë®ùë©ùë™ùë´ùë¨ùë≠ùëÆùëØùë∞ùë±ùë≤ùë≥ùë¥ùëµùë∂ùë∑ùë∏ùëπùë∫ùëªùëºùëΩùëæùëøùíÄùíÅùíÇùíÉùíÑùíÖùíÜùíáùíàùíâùíäùíãùíåùíçùíéùíèùíêùíëùííùíìùíîùíïùíñùíóùíòùíôùíöùíõ"+
                   "ùíú‚Ñ¨ùíûùíü‚Ñ∞‚Ñ±ùí¢‚Ñã‚Ñêùí•ùí¶‚Ñí‚Ñ≥ùí©ùí™ùí´ùí¨‚ÑõùíÆùíØùí∞ùí±ùí≤ùí≥ùí¥ùíµùí∂ùí∑ùí∏ùíπ‚ÑØùíª‚ÑäùíΩùíæùíøùìÄùìÅùìÇùìÉ‚Ñ¥ùìÖùìÜùìáùìàùìâùìäùìãùìåùìçùìéùìè"+
                   "ùîÑùîÖ‚Ñ≠ùîáùîàùîâùîä‚Ñå‚Ñëùîçùîéùîèùîêùîëùîíùîìùîî‚Ñúùîñùîóùîòùîôùîöùîõùîú‚Ñ®ùîûùîüùî†ùî°ùî¢ùî£ùî§ùî•ùî¶ùîßùî®ùî©ùî™ùî´ùî¨ùî≠ùîÆùîØùî∞ùî±ùî≤ùî≥ùî¥ùîµùî∂ùî∑"+
                   "ùï¨ùï≠ùïÆùïØùï∞ùï±ùï≤ùï≥ùï¥ùïµùï∂ùï∑ùï∏ùïπùï∫ùïªùïºùïΩùïæùïøùñÄùñÅùñÇùñÉùñÑùñÖùñÜùñáùñàùñâùñäùñãùñåùñçùñéùñèùñêùñëùñíùñìùñîùñïùññùñóùñòùñôùñöùñõùñúùñùùñûùñü"+
                   "ùìêùìëùìíùììùìîùìïùìñùìóùìòùìôùìöùìõùìúùìùùìûùìüùì†ùì°ùì¢ùì£ùì§ùì•ùì¶ùìßùì®ùì©ùì™ùì´ùì¨ùì≠ùìÆùìØùì∞ùì±ùì≤ùì≥ùì¥ùìµùì∂ùì∑ùì∏ùìπùì∫ùìªùìºùìΩùìæùìøùîÄùîÅùîÇùîÉ"+
                   "ùóîùóïùóñùóóùóòùóôùóöùóõùóúùóùùóûùóüùó†ùó°ùó¢ùó£ùó§ùó•ùó¶ùóßùó®ùó©ùó™ùó´ùó¨ùó≠ùóÆùóØùó∞ùó±ùó≤ùó≥ùó¥ùóµùó∂ùó∑ùó∏ùóπùó∫ùóªùóºùóΩùóæùóøùòÄùòÅùòÇùòÉùòÑùòÖùòÜùòáùü¨ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≥ùü¥ùüµ"+
                   "ùòàùòâùòäùòãùòåùòçùòéùòèùòêùòëùòíùòìùòîùòïùòñùòóùòòùòôùòöùòõùòúùòùùòûùòüùò†ùò°ùò¢ùò£ùò§ùò•ùò¶ùòßùò®ùò©ùò™ùò´ùò¨ùò≠ùòÆùòØùò∞ùò±ùò≤ùò≥ùò¥ùòµùò∂ùò∑ùò∏ùòπùò∫ùòª"+
                   "ùô∞ùô±ùô≤ùô≥ùô¥ùôµùô∂ùô∑ùô∏ùôπùô∫ùôªùôºùôΩùôæùôøùöÄùöÅùöÇùöÉùöÑùöÖùöÜùöáùöàùöâùöäùöãùöåùöçùöéùöèùöêùöëùöíùöìùöîùöïùöñùöóùöòùöôùööùöõùöúùöùùöûùöüùö†ùö°ùö¢ùö£ùü∂ùü∑ùü∏ùüπùü∫ùüªùüºùüΩùüæùüø"+
                   "ùòºùòΩùòæùòøùôÄùôÅùôÇùôÉùôÑùôÖùôÜùôáùôàùôâùôäùôãùôåùôçùôéùôèùôêùôëùôíùôìùôîùôïùôñùôóùôòùôôùôöùôõùôúùôùùôûùôüùô†ùô°ùô¢ùô£ùô§ùô•ùô¶ùôßùô®ùô©ùô™ùô´ùô¨ùô≠ùôÆùôØ"+
                   "ùõ¢ùõºùõ£ùõΩùõ§ùõæŒîùõ•ùõøùõ¶œµŒµùõßùúÅùõ®ùúÇŒòùúÉùúóùõ™ùúÑùõ´ùúÖùúòùõ¨ùúÜùõ≠ùúáùõÆùúàŒ¶ùúôùúëŒûùúâùõ∞ùúäùõ±ùúãùúõùõ≤ùúåœ±ùõ¥ùúéùúçùõµùúèùõ∂ùúêùõ∏ùúíùõπùúì‚Ñ¶ùúî"+
                   "ùúúùú∂ùúùùú∑ùúûùú∏ùö´ùúüùúπùú†ùõúùõÜùú°ùúªùú¢ùúºùöΩùúΩùùëùú§ùúæùú•ùúøùùíùú¶ùùÄùúßùùÅùú®ùùÇùöΩùùìùùãùöµùùÉùú™ùùÑùú´ùùÖùùïùú¨ùùÜùõ†ùúÆùõîùùáùúØùùâùú∞ùùäùú≤ùùåùú≥ùùçùõÄùùé"+ 
                   "ŒëŒ±ŒíŒ≤ŒìŒ≥Œ¥ŒñŒ∂ŒóŒ∑Œ∏œëŒôŒπŒöŒ∫œ∞ŒõŒªŒúŒºŒùŒΩŒæŒüŒøŒ†œÄœñŒ°œÅœ±Œ£œÉœÇŒ§œÑŒ•œÖœïœÜŒßœáŒ®œàŒ©œâ" + 
                   "ùùñùù∞ùùóùù±ùùòùù≤ùõÖùùõùùµùùúùù∂ùõâùõùùùûùõäùùüùùπùûåùù†ùù∫ùù°ùùªùù¢ùùºùùΩùù§ùùæùù•ùùøùûèùù¶ùûÄùûéùù®ùûÇùûÅùù©ùûÉùù™ùûÑùûçùûÖùù¨ùûÜùù≠ùûáùùÆùûà" +
                   "‚Ñæ‚ÑΩ‚Ñø‚Ñº‚ÖÄ" + 
                   ")]}‚¶Ü‚üß‚¶Ñ";  // Only right parentheses, since the algorithm to adjust spaces only looks at the previous symbol

// Symbol for an error
const errSymbol = "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";  // bold "err" with two "x" under it

// Every undefined commands
let errorsList = "";

// Recognize if the device is screen only
const touchScreen = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Used by tokenizer() and tokensToText()
const specialTokens = {startMathmode: "STARTMM", endMathmode: "ENDMM", startArgument: "STARTARG", endArgument: "ENDARG"};

// Detects the prefered color scheme of the user
const prefersDarkMode = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)')).matches;

// Default values for settings (only those in the Settings box)
const defaultSettings = {
    "dark_mode" : prefersDarkMode,
    "font_size" : 14,
    "font_family" : "monospace",
    "open_mattalx_shortcut" : "Alt+M",
    "copy_input_key" : "Alt",
    "copy_input_letter" : "I",
    "copy_output_key" : "Alt",
    "copy_output_letter" : "O",
    "completion_key" : "Alt",
    "completion_letter" : "C",
    "completion_button" : false
};

// Colors

// Index 0 is for light mode and 1 is for dark mode
const mainColors = {
    "body" : ["white", "rgb(39,39,39)"],
    "text" : {
        "color" : ["black", "whitesmoke"],
        "background" : ["whitesmoke", "rgb(83,83,83)"],
        "border" : ["rgb(231,231,231)", "rgb(83,83,83)"]
    },
    "infoBtn" : ["white", "rgb(39,39,39)"],
    "shortcuts" : ["black", "whitesmoke"],
    "dropdown" : ["whitesmoke", "rgb(31,31,31)"],
    "btnDropdown" : {
        "color" : ["black", "whitesmoke"],
        "background" : ["whitesmoke", "rgb(31,31,31)"],
        "hover" : ["lightgrey", "rgb(41,41,41)"]
    },
    "mainBtn" : {
        "color" : ["black", "whitesmoke"],
        "background" : ["rgb(230,229,229)", "rgb(53,53,53)"],
        "hover" : ["lightgrey", "rgb(61,61,61)"]
    },
    "mistakes" : ["black", "whitesmoke"],
    "completion" : {
        "border" : ["rgb(238,238,238)", "rgb(31,31,31)"],
        "backgroundTrTd" : ["white", "rgb(39,39,39)"]
    },
    "settingsBox" : {
        "background" : ["rgba(245,245,245,0.7)", "rgba(31,31,31,0.7)"],
        "backgroundBackup" : ["whitesmoke", "rgb(31,31,31)"]
    },
    "settingsContent" : {
        "color" : ["black", "whitesmoke"],
        "background" : ["whitesmoke", "rgb(31,31,31)"],
        "input" : {
            "color" : ["black", "whitesmoke"],
            "background" : ["white", "rgb(61,61,61)"]
        },
        "inputBtn" : {
            "color" : ["black", "whitesmoke"],
            "background" : ["rgb(230,229,229)", "rgb(53,53,53)"],
            "hover" : ["lightgrey", "rgb(61,61,61)"]
        }
    }
};


/**************************************************************************************/


/// FUNCTIONS ///

/** Front-end **/

// Show completion button and hide shortcuts if the device is screen only
if (touchScreen) {
    completionBtn.style.display = "inline-block";
    shortcutsList.style.display = "none";
};

function copyTextOut() {
    // Copy second box (output) to clipboard
    if (textOut.disabled === false) {
        navigator.clipboard.writeText(textOut.value);
        copyButton.value = "Copied!";
        setTimeout(() => {
            copyButton.value = "Copy text";
        }, 2500)  // Returns to initial copyButton
    };
};

function copyTextIn() {
    // Copy first box (input) to clipboard
    navigator.clipboard.writeText(textIn.value);
};

function clear() {
    // Clears everything
    copyButton.value = "Copy text";
    mistakesBox.textContent = "";
    textOut.disabled = true;
    completionPopup.style.display = "none";
    completionPopup.textContent = "";
};

function verifySettings(variable, varType) {
    // Makes sure the settings are appropriate
    const restriction = {
        "font" : {
            // Should be fine since 2 char limits in HTML
            min: 1,
            max: 99,
        },
        "letter" : {
            min: "A",
            max: "z",
        }
    };
    if ((variable < restriction[varType].min) || (variable > restriction[varType].max)) {
        const errReason = (varType === "letter") ? "not an accepted character" : "out of range";
        mistakesBox.textContent = "";
        errorsList = "";
        mistakes("Settings", undefined, variable + " is " + errReason);
    };
};

function applySettings() {
    // Writes down the value of the shortcuts chosen in the settings and updates the font
    // Called when MatTalX opens, when the Settings box closes and by resetSettings()
    textCopyInputKey.textContent = setCopyInputKey.value;
    textCopyInputLetter.textContent = setCopyInputLetter.value.toUpperCase();
    textCopyOutputKey.textContent = setCopyOutputKey.value;
    textCopyOutputLetter.textContent = setCopyOutputLetter.value.toUpperCase();
    textCompletionKey.textContent = setCompletionKey.value;
    textCompletionLetter.textContent = setCompletionLetter.value.toUpperCase();

    // Verify if each shortcut is unique
    const listShortcuts = [
        textOpenMatTalX.textContent,
        [textCopyInputKey.textContent, "+", textCopyInputLetter.textContent].join(""), 
        [textCopyOutputKey.textContent, "+", textCopyOutputLetter.textContent].join(""),
        [textCompletionKey.textContent, "+", textCompletionLetter.textContent].join("")
    ];
    if ((new Set(listShortcuts)).size !== listShortcuts.length) {
        mistakes("Settings", undefined, "At least two shortcuts are identical");
    };

    textIn.style.fontSize = fontSize.value.toString() + "px";
    textOut.style.fontSize = (parseInt(fontSize.value)+1).toString() + "px";

    textIn.style.fontFamily = fontFamily.value;
    textOut.style.fontFamily = fontFamily.value;

    completionBtn.style.display = (showCompletionBtn.checked || touchScreen) ? "inline-block" : "none";
};

function resetSettings() {
    // Give each setting its default value
    // Called when the 'Reset' button in the Settings box is clicked
    darkMode.checked = defaultSettings["dark_mode"];
    fontSize.value = defaultSettings["font_size"];
    fontFamily.value = defaultSettings["font_family"];
    setCopyInputKey.value = defaultSettings["copy_input_key"];
    setCopyInputLetter.value = defaultSettings["copy_input_letter"];
    setCopyOutputKey.value = defaultSettings["copy_output_key"];
    setCopyOutputLetter.value = defaultSettings["copy_output_letter"];
    setCompletionKey.value = defaultSettings["completion_key"];
    setCompletionLetter.value = defaultSettings["completion_letter"];
    showCompletionBtn.checked = defaultSettings["completion_button"];

    updateMainColors();
    applySettings();
};

function updateMainColors() {
    // Updates the colors (light or dark mode) of the popup
    const titleLight = document.getElementById("title_light");
    const titleDark = document.getElementById("title_dark");
    const infoBtnLight = document.getElementById("infoButton_light");
    const infoBtnDark = document.getElementById("infoButton_dark");
    const infoImgLight = document.getElementById("info_light");
    const infoImgDark = document.getElementById("info_dark");
    const dropdownInfo = document.getElementById("dropdownInfo");
    const docsBtn = document.getElementById("docs");
    const gitBtn = document.getElementById("git");
    const adjustSpacesBtn = document.getElementById("adjustSpaces");
    const changeFontBtn = document.getElementById("changeFont");
    const changeModeBtn = document.getElementById("changeMode");
    const settingsContent = document.getElementById("settingsContent");
    const settingsContentInp = settingsContent.getElementsByTagName("input");
    const settingsContentSel = settingsContent.getElementsByTagName("select");

    const i = (darkMode.checked) ? 1 : 0;
    document.body.style.backgroundColor = mainColors["body"][i];
    textIn.style.color = mainColors["text"]["color"][i];
    textIn.style.backgroundColor = mainColors["text"]["background"][i];
    textIn.style.border = "2px solid " + mainColors["text"]["border"][i];
    textOut.style.color = mainColors["text"]["color"][i];
    textOut.style.backgroundColor = mainColors["text"]["background"][i];
    textOut.style.border = "2px solid " + mainColors["text"]["border"][i];
    dropdownInfo.style.backgroundColor = mainColors["dropdown"][i];
    shortcutsList.style.color = mainColors["shortcuts"][i];

    docsBtn.style.color = mainColors["btnDropdown"]["color"][i];
    docsBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    docsBtn.addEventListener("mouseenter", (e) => {
        docsBtn.style.backgroundColor = mainColors["btnDropdown"]["hover"][i];
    });
    docsBtn.addEventListener("mouseleave", (e) => {
        docsBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    });
    gitBtn.style.color = mainColors["btnDropdown"]["color"][i];
    gitBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    gitBtn.addEventListener("mouseenter", (e) => {
        gitBtn.style.backgroundColor = mainColors["btnDropdown"]["hover"][i];
    });
    gitBtn.addEventListener("mouseleave", (e) => {
        gitBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    });
    adjustSpacesBtn.style.color = mainColors["btnDropdown"]["color"][i];
    adjustSpacesBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    adjustSpacesBtn.addEventListener("mouseenter", (e) => {
        adjustSpacesBtn.style.backgroundColor = mainColors["btnDropdown"]["hover"][i];
    });
    adjustSpacesBtn.addEventListener("mouseleave", (e) => {
        adjustSpacesBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    });
    changeFontBtn.style.color = mainColors["btnDropdown"]["color"][i];
    changeFontBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    changeFontBtn.addEventListener("mouseenter", (e) => {
        changeFontBtn.style.backgroundColor = mainColors["btnDropdown"]["hover"][i];
    });
    changeFontBtn.addEventListener("mouseleave", (e) => {
        changeFontBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    });
    changeModeBtn.style.color = mainColors["btnDropdown"]["color"][i];
    changeModeBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    changeModeBtn.addEventListener("mouseenter", (e) => {
        changeModeBtn.style.backgroundColor = mainColors["btnDropdown"]["hover"][i];
    });
    changeModeBtn.addEventListener("mouseleave", (e) => {
        changeModeBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    });
    settingsBtn.style.color = mainColors["btnDropdown"]["color"][i];
    settingsBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    settingsBtn.addEventListener("mouseenter", (e) => {
        settingsBtn.style.backgroundColor = mainColors["btnDropdown"]["hover"][i];
    });
    settingsBtn.addEventListener("mouseleave", (e) => {
        settingsBtn.style.backgroundColor = mainColors["btnDropdown"]["background"][i];
    });
    convertButton.style.color = mainColors["mainBtn"]["color"][i];
    convertButton.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    convertButton.addEventListener("mouseenter", (e) => {
        convertButton.style.backgroundColor = mainColors["mainBtn"]["hover"][i];
    });
    convertButton.addEventListener("mouseleave", (e) => {
        convertButton.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    });
    resetButton.style.color = mainColors["mainBtn"]["color"][i];
    resetButton.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    resetButton.addEventListener("mouseenter", (e) => {
        resetButton.style.backgroundColor = mainColors["mainBtn"]["hover"][i];
    });
    resetButton.addEventListener("mouseleave", (e) => {
        resetButton.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    });
    copyButton.style.color = mainColors["mainBtn"]["color"][i];
    copyButton.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    copyButton.addEventListener("mouseenter", (e) => {
        copyButton.style.backgroundColor = mainColors["mainBtn"]["hover"][i];
    });
    copyButton.addEventListener("mouseleave", (e) => {
        copyButton.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    });
    completionBtn.style.color = mainColors["mainBtn"]["color"][i];
    completionBtn.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    completionBtn.addEventListener("mouseenter", (e) => {
        completionBtn.style.backgroundColor = mainColors["mainBtn"]["hover"][i];
    });
    completionBtn.addEventListener("mouseleave", (e) => {
        completionBtn.style.backgroundColor = mainColors["mainBtn"]["background"][i];
    });

    mistakesBox.style.color = mainColors["mistakes"][i];
    completionPopup.style.border = "1px solid " + mainColors["completion"]["border"][i];
    completionPopup.style.backgroundColor = mainColors["completion"]["border"][i];
    settingsBox.style.backgroundColor = mainColors["settingsBox"]["backgroundBackup"][i];
    settingsBox.style.backgroundColor = mainColors["settingsBox"]["background"][i];
    settingsContent.style.color = mainColors["settingsContent"]["color"][i];
    settingsContent.style.backgroundColor = mainColors["settingsContent"]["background"][i];
    resetSettingsButton.addEventListener("mouseenter", (e) => {
        resetSettingsButton.style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["hover"][i];
    });
    resetSettingsButton.addEventListener("mouseleave", (e) => {
        resetSettingsButton.style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["background"][i];
    });
    buildCommandsBtn.addEventListener("mouseenter", (e) => {
        buildCommandsBtn.style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["hover"][i];
    });
    buildCommandsBtn.addEventListener("mouseleave", (e) => {
        buildCommandsBtn.style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["background"][i];
    });

    let j;
    for (j=0; j<settingsContentInp.length; j++) {
        if ((settingsContentInp[j].type == "number") || (settingsContentInp[j].type == "text")) {
            settingsContentInp[j].style.color = mainColors["settingsContent"]["input"]["color"][i];
            settingsContentInp[j].style.backgroundColor = mainColors["settingsContent"]["input"]["background"][i];
        } else if (settingsContentInp[j].type == "button") {
            settingsContentInp[j].style.color = mainColors["settingsContent"]["inputBtn"]["color"][i];
            settingsContentInp[j].style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["background"][i];
        };
    };
    for (j=0; j<settingsContentSel.length; j++) {
        settingsContentSel[j].style.color = mainColors["settingsContent"]["input"]["color"][i];
        settingsContentSel[j].style.backgroundColor = mainColors["settingsContent"]["input"]["background"][i];
    };

    if (darkMode.checked) {
        titleDark.style.display = "inline-block";
        titleDark.style.width = "25%";
        titleDark.style.height = "25%";
        titleDark.style.marginLeft = "37%";
        titleDark.style.marginRight = "37%";
        titleLight.style.display = "none";
        infoBtnDark.style.display = "inline-block";
        infoBtnDark.style.border = "none";
        infoBtnDark.style.float = "right";
        infoBtnDark.style.backgroundColor = mainColors["infoBtn"][i];
        infoBtnLight.style.display = "none";
        infoImgDark.style.display = "inline-block";
        infoImgDark.style.width = "15px";
        infoImgDark.style.height = "15px";
        infoImgDark.style.cursor = "default";
        infoImgDark.style.float = "right";
        infoImgLight.style.display = "none";
    } else {
        titleLight.style.display = "inline-block";
        titleLight.style.width = "25%";
        titleLight.style.height = "25%";
        titleLight.style.marginLeft = "37%";
        titleLight.style.marginRight = "37%";
        titleDark.style.display = "none";
        infoBtnLight.style.display = "inline-block";
        infoBtnLight.style.border = "none";
        infoBtnLight.style.float = "right";
        infoBtnLight.style.backgroundColor = mainColors["infoBtn"][i];
        infoBtnDark.style.display = "none";
        infoImgLight.style.display = "inline-block";
        infoImgLight.style.width = "15px";
        infoImgLight.style.height = "15px";
        infoImgLight.style.cursor = "default";
        infoImgLight.style.float = "right";
        infoImgDark.style.display = "none";
    };
};

darkMode.addEventListener("click", (e) => {
    updateMainColors();
});

document.addEventListener("keydown", (keyPressed) => {
    // Listens for keydown to open completion popup, copy the input text or copy the output
    if (((keyPressed.key === setCompletionLetter.value.toLowerCase()) || (keyPressed.key === setCompletionLetter.value.toUpperCase())) && 
         (
          (keyPressed.altKey && ("Alt" === setCompletionKey.value)) || 
          (keyPressed.ctrlKey && ("Ctrl" === setCompletionKey.value)) || 
          (keyPressed.altKey && keyPressed.shiftKey && ("Alt+Shift" === setCompletionKey.value)) ||
          (keyPressed.ctrlKey && keyPressed.shiftKey && ("Ctrl+Shift" === setCompletionKey.value))
          ) &&
         (textIn == document.activeElement)) {
        // Shows completion but closes the popup if the completion box is already opened
        getCompletion();
    } else if (((keyPressed.key === setCopyInputLetter.value.toLowerCase()) || (keyPressed.key === setCopyInputLetter.value.toUpperCase())) && 
        (
        (keyPressed.altKey && ("Alt" === setCopyInputKey.value)) || 
        (keyPressed.ctrlKey && ("Ctrl" === setCopyInputKey.value)) || 
        (keyPressed.altKey && keyPressed.shiftKey && ("Alt+Shift" === setCopyInputKey.value)) ||
        (keyPressed.ctrlKey && keyPressed.shiftKey && ("Ctrl+Shift" === setCopyInputKey.value))
        )) {
        copyTextIn();
    } else if (((keyPressed.key === setCopyOutputLetter.value.toLowerCase()) || (keyPressed.key === setCopyOutputLetter.value.toUpperCase())) && 
        (
        (keyPressed.altKey && ("Alt" === setCopyOutputKey.value)) || 
        (keyPressed.ctrlKey && ("Ctrl" === setCopyOutputKey.value)) || 
        (keyPressed.altKey && keyPressed.shiftKey && ("Alt+Shift" === setCopyOutputKey.value)) ||
        (keyPressed.ctrlKey && keyPressed.shiftKey && ("Ctrl+Shift" === setCopyOutputKey.value))
        )) {
        copyTextOut();
    } else {
        // If any key is pressed while the completion popup is opened, it adjusts the suggestions
        // The word must be adjusted "by hand" because the eventListener is synchronous
        if (completionPopup.style.display === "inline-block") {
            if (keyPressed.key === "Backspace") {
                completionPopup.textContent = "";
                let word = findWord(textIn.value, textIn.selectionEnd - 1, "Backspace");
                completion(word);
            } else if (keyPressed.code === "Space") {
                closeCompletion();
            } else if (keyPressed.key.length === 1) {  // i.e. A letter
                completionPopup.textContent = "";
                let word = findWord(textIn.value, textIn.selectionEnd - 1, keyPressed.key);
                completion(word);
            } else if ((keyPressed.key === "ArrowUp") || (keyPressed.key === "ArrowRight") || (keyPressed.key === "ArrowLeft") || (keyPressed.key === "ArrowDown")) {
                completionPopup.textContent = "";
                const arrows = {"ArrowUp": 0, "ArrowRight": 1, "ArrowLeft": -1, "ArrowDown": 0};
                let word = findWord(textIn.value, (textIn.selectionEnd - 1 + arrows[keyPressed.key]));  // Only adjusts the cursor position for right and left arrows
                completion(word);
            };
        };
    };
});

//-----------------------------------------------------//


/** Build commands and operators **/

function buildNewCommand() {
    // Called when 'buildCommandsBtn' is clicked
    // Adds a new row to the 'commandsBuilt' table
    const darkModeInt = (darkMode.checked) ? 1 : 0;

    commandsBuilt.style.display = "block";

    // Curly brackets are used to mimic the style of \command{}{}
    let curlyBracketsLeftCN = document.createElement("td");
    let curlyBracketsRigthCN = document.createElement("td");
    let curlyBracketsLeftCA = document.createElement("td");
    let curlyBracketsRigthCA = document.createElement("td");
    curlyBracketsLeftCN.textContent = "{";
    curlyBracketsRigthCN.textContent = "}";
    curlyBracketsLeftCA.textContent = "{";
    curlyBracketsRigthCA.textContent = "}";

    let row = document.createElement("tr");

    // This block builds the select form from which you can select what to build
    let typeInput = document.createElement("td");
    let select = document.createElement("select");
    select.className = "commandList";
    let newCommandOpt = document.createElement("option");
    let renewCommandOpt = document.createElement("option");
    let declareMathOperatorOpt = document.createElement("option");
    let declareUnicodeCharacterOpt = document.createElement("option");
    newCommandOpt.text = "\\newcommand";
    newCommandOpt.value = "\\newcommand";
    renewCommandOpt.text = "\\renewcommand";
    renewCommandOpt.value = "\\renewcommand";
    declareMathOperatorOpt.text = "\\DeclareMathOperator";
    declareMathOperatorOpt.value = "\\DeclareMathOperator";
    declareUnicodeCharacterOpt.text = "\\DeclareUnicodeCharacter";
    declareUnicodeCharacterOpt.value = "\\DeclareUnicodeCharacter";
    select.add(newCommandOpt);
    select.add(renewCommandOpt);
    select.add(declareMathOperatorOpt);
    select.add(declareUnicodeCharacterOpt);
    select.style.color = mainColors["settingsContent"]["input"]["color"][darkModeInt];
    select.style.backgroundColor = mainColors["settingsContent"]["input"]["background"][darkModeInt];
    typeInput.appendChild(select);
    row.appendChild(typeInput);

    row.appendChild(curlyBracketsLeftCN);

    // newCommandName is the command name *to be* used
    let newCommandName = document.createElement("td");
    let inputNewCommandName = document.createElement("input");
    inputNewCommandName.type = "text";
    inputNewCommandName.style.color = mainColors["settingsContent"]["input"]["color"][darkModeInt];
    inputNewCommandName.style.backgroundColor = mainColors["settingsContent"]["input"]["background"][darkModeInt];
    newCommandName.appendChild(inputNewCommandName);
    row.appendChild(newCommandName);
    inputNewCommandName.style.width = "90%";

    row.appendChild(curlyBracketsRigthCN);
    row.appendChild(curlyBracketsLeftCA);

    // defaultCommandName is the *old* (or default) command
    let defaultCommandName = document.createElement("td");
    let inputDefaultCommandArg = document.createElement("input");
    inputDefaultCommandArg.type = "text";
    inputDefaultCommandArg.style.color = mainColors["settingsContent"]["input"]["color"][darkModeInt];
    inputDefaultCommandArg.style.backgroundColor = mainColors["settingsContent"]["input"]["background"][darkModeInt];
    defaultCommandName.appendChild(inputDefaultCommandArg);
    row.appendChild(defaultCommandName);
    inputDefaultCommandArg.style.width = "90%";

    row.appendChild(curlyBracketsRigthCA);

    // Button used to delete the command (and remove the row)
    let deleteCommand = document.createElement("td");
    let deleteCommandBtn = document.createElement("input");
    deleteCommandBtn.type = "button";
    deleteCommandBtn.value = "‚òí";
    deleteCommandBtn.style.fontSize = "18px";
    deleteCommandBtn.style.borderRadius = "6px";
    deleteCommandBtn.style.padding = "5px";
    deleteCommandBtn.style.color = mainColors["settingsContent"]["inputBtn"]["color"][darkModeInt];
    deleteCommandBtn.style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["background"][darkModeInt];

    // Commented out since it leads to a bug. The color chosen now "sticks" to the button. Therefore, if the user changes 
    // the color mode, the button won't have the right color when hover.
    /*
    deleteCommandBtn.addEventListener("mouseenter", (e) => {
        deleteCommandBtn.style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["hover"][darkModeInt];
    });
    deleteCommandBtn.addEventListener("mouseleave", (e) => {
        deleteCommandBtn.style.backgroundColor = mainColors["settingsContent"]["inputBtn"]["background"][darkModeInt];
    });
    */

    deleteCommandBtn.addEventListener("click", () => {
        // Delete the command
        row.remove();
    });

    deleteCommand.appendChild(deleteCommandBtn);
    row.appendChild(deleteCommand);

    commandsBuilt.appendChild(row);
};

function storeCommands() {
    // Loops on all the commands and returns an array containing all the info
    // Called when MatTalX or the settings popup closes
    let commandsList = [];
    for (let row=0; row<commandsBuilt.rows.length; row++) {
        if (commandsBuilt.rows[row].cells[2].firstChild.value !== undefined && 
            commandsBuilt.rows[row].cells[5].firstChild.value !== undefined &&
            commandsBuilt.rows[row].cells[2].firstChild.value !== "" &&
            commandsBuilt.rows[row].cells[5].firstChild.value !== "")
        {
            commandsList.push({
                type : commandsBuilt.rows[row].cells[0].firstChild.value,
                newInput : commandsBuilt.rows[row].cells[2].firstChild.value,
                output : commandsBuilt.rows[row].cells[5].firstChild.value
            });
        };
    };
    return commandsList;
};

function buildAllCommands(fullDict) {
    // Includes every commands built by the user in the object containing every commands (in math mode)
    // Called by makeDict()
    for (let i=0; i<commandsBuilt.rows.length; i++) {
        if (commandsBuilt.rows[i].cells[2].firstChild.value !== undefined && 
            commandsBuilt.rows[i].cells[5].firstChild.value !== undefined && 
            commandsBuilt.rows[i].cells[2].firstChild.value !== "" && 
            commandsBuilt.rows[i].cells[5].firstChild.value !== "")
        {
            fullDict = settingsFunctions[commandsBuilt.rows[i].cells[0].firstChild.value](
                            fullDict, 
                            commandsBuilt.rows[i].cells[2].firstChild.value.replace(/ /g, ""), 
                            commandsBuilt.rows[i].cells[5].firstChild.value+" "
                        );
        };
    };
    return fullDict;
};

function newCommand(fullDict, input, output) {
    // Only add the command if its name is not already defined
    if (Object.hasOwn(fullDict, input)) {
        mistakes("Settings", undefined, input + " is already defined. Use '\\renewcommand' instead.");
    } else {
        let outNoSpace = output.replace(/ /g, "");
        let outputSymbol;
        if (typeof fullDict[outNoSpace] == "function") {
            outputSymbol = fullDict[outNoSpace];
        } else {
            outputSymbol = tokensToText(tokenize(output, true), fullDict, {}, (t) => {return t;});
        };
        fullDict[input] = outputSymbol;
    };
    return fullDict;
};

function renewCommand(fullDict, input, output) {
    // Overrides existing command if needed, if not it creates it (like newCommand)
    let outNoSpace = output.replace(/ /g, "");
    let outputSymbol;
    if (typeof fullDict[outNoSpace] == "function") {
        outputSymbol = fullDict[outNoSpace];
    } else {
        outputSymbol = tokensToText(tokenize(output, true), fullDict, {}, (t) => {return t;});
    };
    fullDict[input] = outputSymbol;
    return fullDict;
};

function declareMathOperator(fullDict, input, output) {
    // Adds a new operator
    // Currently only accepts 1 argument
    let outputSymbol = tokensToText(tokenize(output, true), fullDict, {}, (t) => {return t;});
    const newOp = (arg, initialCommand) => {
        // This function will be the value of every operator built by the user
        return [outputSymbol + "[" + arg.join("") + "]"];
    };
    fullDict[input] = newOp;
    return fullDict;
};

function declareUnicodeCharacter(fullDict, input, output) {
    // Verifies if the output is a valid unicode character and if so, adds it as a command
    if (output.substring(0,2) === "\\u") {
        try {
            let outputSymbol = String.fromCodePoint(parseInt(output.substring(2).replace(/ /g, ""), 16));
            fullDict[input] = outputSymbol
            return fullDict;
        } catch(err) {
            mistakes("Settings", undefined, output + " is not a valid unicode character.");
            return fullDict;
        };
    } else {
        mistakes("Settings", undefined, output + " is not a valid unicode character. Must be of the form '\\uXXXX'.");
        return fullDict;
    };
};


//-----------------------------------------------------//


/** Completion box **/

function closeCompletion() {
    // Close and empties the completion popup
    completionPopup.style.display = "none";
    completionPopup.textContent = "";
};

function getCompletion() {
    // Calls completion() with the word touching the cursor if the popup is closed, else it closes the popup
    if (completionPopup.style.display !== "inline-block") { 
        completionPopup.textContent = "";
        let word = findWord(textIn.value, textIn.selectionEnd - 1);
        completionPopup.style.display = "inline-block";
        completion(word);
    } else {
        closeCompletion();
    };
};

function findWord(text, cursorPosition, addedLetter="") {
    // Used in the completion popup
    // Finds the word that is touched by the cursor
    if (addedLetter.length === 1) {  // ie a letter
        text = text.split("");
        text[cursorPosition] += addedLetter;
        text = text.join("");
    } else if (addedLetter === "Backspace") {
        text = text.split("");
        text[cursorPosition] = "";
        text = text.join("");
        cursorPosition -= 1;
    };
    let word = "";
    while (!(wordsDelimiters.includes(text.charAt(cursorPosition + 1)))) {
        cursorPosition += 1;
    };
    while (!(wordsDelimitersWOB.includes(text.charAt(cursorPosition)))) {
        if (text.charAt(cursorPosition) === "\\") {
            word = text.charAt(cursorPosition) + word;
            break;
        } else {
            word = text.charAt(cursorPosition) + word;
            cursorPosition -= 1;
        }
    };
    return word;
};

function completion(command) {
    // Outputs list of other commands that are similar to the one currently being written
    const btnBackColor = mainColors["completion"]["backgroundTrTd"][(darkMode.checked) ? 1 : 0];
    const btnFontColor = (darkMode.checked) ? "whitesmoke" : "black";
    if (command === "") {
        closeCompletion();
    } else if (command[0] !== "\\") {
        let row = completionPopup.insertRow(-1);
        let cell = row.insertCell(0);
        cell.textContent = "The first character of the command must be a backslash (\\). Superscript starts with ^ and subscript with _";
        cell.style.color = btnFontColor;
    } else {
        command = command.substring(1, command.length);  // Erases the backslash so that, for instance, \arrow will also show \rightarrow, etc.
        for (let keys in defaultDict) {
            // Puts commands in button form, so they can be clicked on to replace the command being written
            if (keys.toLowerCase().indexOf(command.toLowerCase()) !== -1) {
                let row = completionPopup.insertRow(-1);
                let cell = row.insertCell(0);
                let btn = document.createElement("button");
                btn.name = showCommand(keys);
                btn.textContent = toReplaceCommand(keys);
                btn.value = toReplaceCommand(keys);  // Value is unchanged

                // Button style
                btn.style.width = "145px";  // Would be cleaner with something like 'fit-content', but is way to slow
                btn.style.height = "17px";
                btn.style.backgroundColor = btnBackColor
                btn.style.border = "1px solid " + btnBackColor;
                btn.style.color = btnFontColor;
                btn.style.borderRadius = "3px";
                btn.type = "button";
                btn.tabIndex = "0";

                cell.style.border = "1px solid " + btnBackColor;
                cell.style.backgroundColor = btnBackColor;

                // Complete the command if the user clicks on that command
                btn.addEventListener("click", () => {
                    textIn.value = semiAutoCompletion(textIn.value, textIn.selectionEnd, btn.value);
                    closeCompletion();
                    textIn.focus();
                });

                // Shows what the command ouputs on mouseover, return to normal on mouseout
                btn.addEventListener("mouseover", () => {
                    let tmp = btn.textContent;
                    btn.textContent = btn.name;
                    btn.name = tmp;
                });
                btn.addEventListener("mouseout", () => {
                    let tmp = btn.textContent;
                    btn.textContent = btn.name;
                    btn.name = tmp;
                });
                cell.appendChild(btn);
            };
        };
    };
};

function semiAutoCompletion(textIn, cursorPosition, command) {
    // Replace the command being written by the selected suggestion
    let textOut = textIn;
    // Find end of word
    while (!(wordsDelimiters.includes(textIn.charAt(cursorPosition)))) {
        cursorPosition += 1;
    };
    // Deletes word
    while (textIn.charAt(cursorPosition - 1) !== "\\") {
        textOut = textOut.substring(0, cursorPosition - 1) + textOut.substring(cursorPosition);
        cursorPosition -= 1;
    };
    // Replace by selected suggestion
    textOut = textOut.substring(0, cursorPosition - 1) + command + textOut.substring(cursorPosition);
    return textOut;
};

function showCommand(key) {
    // Used in completion
    // Changes what's seen when the user hovers on a command in the completion popup
    if (typeof defaultDict[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[n]{x} \u2192 ‚Åø‚àöùë•";
        } else if (key == "\\frac") {
            return "\\frac{1}{2} \u2192 ¬π‚àï‚ÇÇ";
        } else if (key == "\\frac*") {
            return "\\frac*{1}{2} \u2192 ¬Ω";
        } else if ((key == "\\above") || (key == "\\below") || (key == "\\hspace") || (key == "\\vskip")) {
            return key + "{}";
        } else if ((key == "_") || (key == "^")) {
            return "x" + key + "{a1} \u2192 ùë•" + spaceCommand((defaultDict[key](["a", "1"], defaultDict[key])).join(""));
        } else if (key == "\\pmod") {
            return key + "{n} \u2192 " + spaceCommand(defaultDict[key](["n"], defaultDict[key]));
        } else {
            return key + "{abc} \u2192 " + spaceCommand((defaultDict[key](["a", "b", "c"], defaultDict[key])).join(""));
        };
    } else {
        if (key == "\\:") {
            return "1 space";
        } else if ((key == "\\;") || ((key == "\\quad") || (key == "\\qquad"))) {
            return defaultDict[key].length + " spaces";
        } else if (key === "\\!") {
            return "Remove a space";
        } else if ((key == "\\id2") || (key == "\\id3") || (key == "\\id4") || (key == "\\idn")) {
            const M = {
                "\\id2": "‚é° 1 0 ‚é§\u000A‚é£ 0 1 ‚é¶",
                "\\id3" : "‚é° 1 0 0 ‚é§\u000A‚é¢ 0 1 0 ‚é•\u000A‚é£ 0 0 1 ‚é¶",
                "\\id4" : "‚é° 1 0 0 0 ‚é§\u000A‚é¢ 0 1 0 0 ‚é•\u000A‚é¢ 0 0 1 0 ‚é•\u000A‚é£ 0 0 0 1 ‚é¶",
                "\\idn" : "‚é° 1 0 ‚ãØ 0 ‚é§\u000A‚é¢ 0 1 ‚ãØ 0 ‚é•\u000A‚é¢  ‚ãÆ  ‚ãÆ  ‚ã±  ‚ãÆ ‚é•\u000A‚é£ 0 0 ‚ãØ 1 ‚é¶"
            }
            return M[key];
        } else {
            return spaceCommand(defaultDict[key]);
        };
    };
};

function toReplaceCommand(key) {
    // Used in completion
    // Changes what the user sees when the completion popup is opened
    if (typeof defaultDict[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[]{}";
        } else if (key == "\\frac") {
            return "\\frac{}{}";
        } else if (key == "\\frac*") {
            return "\\frac*{}{}";
        } else {
            return key + "{}";
        };
    } else {
        return key
    };
};


//-----------------------------------------------------//


/** Convert text **/


// Main functions

function tokenize(fullText, mathmode) {
    // This function takes the text as entered by the user, and outputs a list of tokens
    // For instance "curl written as $\nabla \times \mathbf{F}$" will output
    //  [c,u,r,l, ,w,r,i,t,t,e,n, ,a,s, ,STARTMM,\nabla, ,\times, ,\mathbf,STARTARG,F,ENDARG,ENDMM]
    const brackets = ["[", "]"];
    const commandStoppers = [" ", "\u000A", ",", "/", "-", "+", "<", ">", "|", "?", "(", ")"]; 
    // N.B. Brackets also stops commands (most of the time)
    const potentialCommandStoppers = [":" , ";" , "~", ".", "!", "'", '"', "=", "%", "#"];
    const startMathmode = mathmode;
    let outTokens = [];
    let temporaryBox = [];      // Stores characters that are in command (e.g. \int -> ['\', 'i', 'n', 't'])
    let trigger = false;        // true if a command has begun (e.g. input: '\' -> true)
    let mathmodeStarter = "";   // e.g. if mathmode is started with $$, then "$$" will be mathmodeStarter
    let char, i;

    if (startMathmode) {
        outTokens.push(specialTokens.startMathmode);
    };

    for (i=0; i<fullText.length; i++) {
        if (trigger) {
            if (commandStoppers.includes(fullText[i])) {
                outTokens.push(temporaryBox.join(""));
                outTokens.push(fullText[i]);
                trigger = false;
                temporaryBox = [];
            } else if (potentialCommandStoppers.includes(fullText[i])) {
                if (fullText[i-1] === "\\") {
                    temporaryBox.push(fullText[i]);
                } else {
                    outTokens.push(temporaryBox.join(""));
                    outTokens.push(fullText[i]);
                    trigger = false;
                    temporaryBox = [];
                };
            } else if (brackets.includes(fullText[i])) {
                if (fullText[i-1] === "\\") {
                    if (mathmode) {
                        if ((fullText[i] === "]") && (mathmodeStarter === "\\[")) {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.endMathmode);
                        } else {
                            outTokens.push(temporaryBox.join("") + fullText[i]);
                        };
                    } else {
                        if (fullText[i] === "[") {
                            mathmode = true;
                            mathmodeStarter = "\\[";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.startMathmode);
                        } else {
                            outTokens.push(temporaryBox.join("") + fullText[i]);
                        };
                    };
                    trigger = false;
                    temporaryBox = [];
                } else {
                    if (temporaryBox.slice(0,5).join("") === "\\sqrt") {
                        temporaryBox.push(fullText[i]);
                    } else {
                        outTokens.push(temporaryBox.join(""));
                        outTokens.push(fullText[i]);
                        trigger = false;
                        temporaryBox = [];
                    };
                };
            } else if (fullText[i] === "{") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                } else {
                    outTokens.push(temporaryBox.join(""));
                    outTokens.push(specialTokens.startArgument);
                };
                trigger = false;
                temporaryBox = [];
            } else if (fullText[i] === "}") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                } else {
                    outTokens.push(temporaryBox.join(""));
                    outTokens.push(specialTokens.endArgument);
                };
                trigger = false;
                temporaryBox = [];
            } else if (fullText[i] === "$") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                } else {
                    if (mathmode) {
                        if (mathmodeStarter === "$") {
                            if (fullText[i-1] === "$") {
                                mathmodeStarter = "$$";
                                outTokens.push("\\\\");
                            } else {
                                mathmode = false;
                                mathmodeStarter = "";
                                outTokens.push(temporaryBox.join(""));
                                outTokens.push(specialTokens.endMathmode);
                            };
                        } else if ((fullText[i-1] === "$") && (mathmodeStarter === "$$")) {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.endMathmode);
                        } else if (fullText[i+1] === "$") {
                            outTokens.push(temporaryBox.join(""));
                            continue;
                        } else {
                            outTokens.push(temporaryBox.join(""));
                            outTokens.push(fullText[i]);
                        };
                    } else {
                        mathmode = true;
                        mathmodeStarter = "$";
                        outTokens.push(temporaryBox.join(""));
                        outTokens.push(specialTokens.startMathmode);
                    };
                };
                trigger = false;
                temporaryBox = [];
            } else if (fullText[i] === "\\") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                    trigger = false;
                    temporaryBox = [];
                } else {
                    outTokens.push(temporaryBox.join(""));
                    temporaryBox = [fullText[i]];
                };
            } else if ((fullText[i] === "^") || (fullText[i] === "_")) {
                if (fullText[i-1] === "\\") {
                    if (mathmode) {
                        outTokens.push(temporaryBox.join("") + fullText[i]);
                        trigger = false;
                        temporaryBox = [];
                    } else {
                        temporaryBox.push(fullText[i]);
                    };
                } else {
                    outTokens.push(temporaryBox.join(""));
                    temporaryBox = [fullText[i]];
                };
            } else {
                temporaryBox.push(fullText[i]);
            };
        } else {
            if (fullText[i] === "\\") {
                trigger = true;
                temporaryBox.push(fullText[i]);
            } else if ((fullText[i] === "^") || (fullText[i] === "_")) {
                if (mathmode) {
                    trigger = true;
                    temporaryBox.push(fullText[i]);
                } else {
                    outTokens.push(fullText[i]);
                };
            } else if (fullText[i] === "$") {
                if (mathmode) {
                    if (mathmodeStarter === "$") {
                        if (fullText[i-1] === "$") {
                            mathmodeStarter = "$$";
                            outTokens.push("\\\\");
                        } else if (fullText[i+1] === "$") {
                            continue;
                        } else {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push(specialTokens.endMathmode);
                        };
                    } else if (mathmodeStarter === "$$") {
                        if (fullText[i-1] === "$") {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.endMathmode);
                        };
                    }¬†else {
                        outTokens.push(fullText[i]);
                    };
                } else {
                    mathmode = true;
                    mathmodeStarter = "$";
                    outTokens.push(specialTokens.startMathmode);
                };
            } else if (fullText[i] === "}") {
                outTokens.push(specialTokens.endArgument);
            } else if (fullText[i] === "{") {
                outTokens.push(specialTokens.startArgument);
            } else {
                char = fullText[i].normalize("NFD").split("");
                outTokens.push(...char);
            };
        };
    };

    if (startMathmode) {
        outTokens.push(specialTokens.endMathmode);
    };
    return outTokens;
};

function tokensToText(tokens, dictMM, dictOut, adjustSpacing) {
    // Takes a list of tokens as input and uses the dictonary to convert them to symbols
    
    // The basic idea of the algorithm is:
    // Loop on tokens
    //     If token is STARTARG
    //         push to argStack
    //     If token is ENDARG
    //         pop from fctStack and argStack
    //         add the corresponding symbol to outText or mathmodeText
    //     Else
    //         push token to outText, mathmodeText, fctStack or the last index of argStack depending on token

    // Ex. If the input is: \f0{args0\f1{args1}}
    // Then at first, fctStack = [f0, f1] and argStack = [[args0], [args1]]
    // and then fctStack = [f0] and argStack = [[args0\f1{args1}]].

    let command;                 // Used to check if a command is a function or a symbol
    let fct;
    let fctStack = [];           // Stores the functions until they are used
    let callingFct;              // Might be different from fct (e.g. \\sqrt[3] is called with \\sqrt)
    let arg = [];
    let argStack = [];           // Stores the function arguments until they are used
    let outText = "";            // The text that will be returned
    let mathmodeText = "";       // Intermediary string that holds the text inside mathmode until the spaces are ajusted
    let mathmode = false;        // true if in mathmode, false if not
    let dict;                    // dictMM (mathmode) or dictOut (out of mathmode) depending if in mathmode or not
    let mathmodeOccurence = 0;   // Counts the number of times one enters and leaves mathmode
    let argDepth = 0;            // Add +1 if startArgument and -1 if endArgument
    let currentArgCount = [];    // Number of arguments per function
    let argNum;                  // Stores the number of arguments for the current function
    let i, j;

    for (i=0; i<tokens.length; i++) {
        dict = (mathmode) ? dictMM : dictOut;
        if (Object.values(specialTokens).includes(tokens[i])) {
            if (tokens[i] === specialTokens.startArgument) {
                argStack.push([]);
                argDepth += 1;
                if (tokens[i-1] !== specialTokens.endArgument) {
                    currentArgCount.push(1);
                };
            } else if (tokens[i] === specialTokens.endArgument) {
                argDepth -= 1;
                if (tokens[i+1] === specialTokens.startArgument) {
                    currentArgCount[currentArgCount.length-1] += 1;
                } else {
                    if (fctStack.length > 0) {
                        fct = fctStack.pop();
                        if (argStack.length > 0) {
                            argNum = currentArgCount.pop();
                            for (j=0; j<argNum; j++) {
                                arg.unshift(argStack.pop());
                            };
                            if (fct.substring(0,5) === "\\sqrt") {
                                callingFct = fct.replace(/\[.*\]/g, "")
                            } else {
                                callingFct = fct;
                            };
                            if (argStack.length > 0) {
                                argStack[argStack.length-1].push(...dict[callingFct](arg, fct));
                            } else {
                                if (mathmode) {
                                    mathmodeText += str(dict[callingFct](arg, fct).join(""));
                                } else {
                                    outText += str(dict[callingFct](arg, fct).join(""));
                                };
                            };
                        } else {
                            if (mathmode) {
                                mathmodeText += mistakes(fct+"{}", undefined, "Can't find an argument");
                            } else {
                                outText += mistakes("Out of math mode", undefined, "Can't find an argument for " + fct + "{}");
                            };
                        };
                        arg = [];
                    } else {
                        while (argStack.length > 0) {
                            arg.unshift(argStack.pop());
                        };
                        if (mathmode) {
                            mathmodeText += str(mathord(arg, "{}").join(""));
                        } else {
                            outText += mistakes("Out of math mode", undefined, "Can't find a function for {" + arg.join("") + "}" + ". Use '\\{' or '\\}' to output a curly bracket");
                        };
                        arg = [];
                    };
                };
            // TODO: Empty stacks
            } else if (tokens[i] === specialTokens.startMathmode) {
                mathmodeOccurence += 1;
                mathmode = true;
            } else if (tokens[i] === specialTokens.endMathmode) {
                mathmodeOccurence += 1;
                mathmode = false;
                outText += adjustSpacing(mathmodeText);
                mathmodeText = "";
            };
        } else {
            if (tokens[i].substring(0,5) === "\\sqrt") {
                command = dict[tokens[i].replace(/\[.*\]/g, "")];
            } else {
                command = dict[tokens[i]];
            };
            if (typeof command == "function") {
                if (tokens[i+1] === specialTokens.startArgument) {
                    fctStack.push(tokens[i]);
                } else if (tokens.slice(i+1).filter(x => x !== " ")[0] === specialTokens.startArgument) {
                    if (mathmode) {
                        mathmodeText += mistakes(tokens[i]+" {}", undefined, "Remove extra spaces");
                    } else {
                        outText += mistakes("Out of math mode: "+tokens[i]+" {}", undefined, "Remove extra spaces");
                    };
                } else {
                    if (mathmode) {
                        if (command === sqrt) {
                            if (argStack.length > 0) {
                                argStack[argStack.length-1].push(...sqrt([], tokens[i]));
                            } else {
                                if (mathmode) {
                                    mathmodeText += str(sqrt([], tokens[i]).join(""));
                                    mistakes(tokens[i], sqrt([], tokens[i]).join(""));
                                } else {
                                    outText += str(sqrt([], tokens[i]).join(""));
                                    mistakes("Out of math mode", sqrt([], tokens[i]), tokens[i]);
                                };
                            };
                        } else {
                            mathmodeText += mistakes(tokens[i]+"{}", undefined, "Can't find an argument");
                        };
                    } else {
                        outText += mistakes("Out of math mode", undefined, "Can't find an argument for "+tokens[i]+"{}");
                    };
                };
            } else {
                if (argStack.length > 0) {
                    argStack[argStack.length-1].push(...dict[tokens[i]]);
                } else {
                    if (mathmode) {
                        mathmodeText += str(dict[tokens[i]]);
                        mistakes(tokens[i], dict[tokens[i]]);
                    } else {
                        outText += str(dict[tokens[i]]);
                        mistakes("Out of math mode", dict[tokens[i]], tokens[i]);
                    };
                };
            };
        };
    };
    if (mathmodeOccurence % 2 !== 0) {
        mistakes("Math mode was not closed", undefined);
    };
    if (argDepth > 0) {
        mistakes("Unbalanced curly brackets ('{', '}')", undefined, "Too many '{'");
    } else if (argDepth < 0) {
        mistakes("Unbalanced curly brackets ('{', '}')", undefined, "Too many '}'");
    };
    return spaceCommand(outText);
};


// Used by main functions

function replaceLetters(letters, dict, initialCommand, checkMistakes=true) {
    // Used by a lot of functions to convert every letter in a string of characters
    dict = {...dict, ...accents};
    let newtext = [];
    for (let c in letters) {
        newtext.push(addSymbol(dict[letters[c]]));
        if (checkMistakes) {
            mistakes(initialCommand + "{" + letters.join("") + "}", dict[letters[c]], (letters[c] !== errSymbol) ? letters[c] : "A symbol does not exist or can't be shown");
        };
    };
    return newtext;
};

function combineSymbols(arg, initialCommand, symbol, forTwo=undefined) {
    // Appends a 'combining symbol' to a regular symbol to create a new one (e.g. 'e' + '¬¥' -> √©)
    let textComb = [];
    if ((arg.length === 2) && (forTwo !== undefined)) {
        textComb.push(str(arg[0]) + forTwo + str(arg[1]));
        mistakes(initialCommand + "{" + errSymbol + str(arg[1]) + "}", arg[0], "Argument doesn't exist");
        mistakes(initialCommand + "{" + str(arg[0]) + errSymbol + "}", arg[1], "Argument doesn't exist");
    } else {
        let err = [];
        for (let c in arg) {
            if (arg[c] !== undefined) {
                textComb.push(arg[c] + symbol);
                err.push(arg[c]);
            } else {
                textComb.push(errSymbol);
                err.push(errSymbol);
            };
        };
        if (err.includes(errSymbol)) {
            mistakes(initialCommand + "{" + err.join("") + "}", undefined, "Argument doesn't exist");
        };
    };
    return textComb;
};

function addSymbol(command, keepArray=false) {
    // Return the command if it's defined, if not it returns a bold "err" with two "x" under it
    if ((typeof command == "object") && !(keepArray)) {
        // Changes an array of characters into a string
        command = command.join("");
    };
    return (command !== undefined) ? command : errSymbol;
};

function addSymbolArray(args, command, checkMistakes=true) {
    // Differs from the function above as it takes in an array instead of a string
    let output = [];
    for (let i in args) {
        output.push((args[i] !== undefined) ? args[i] : errSymbol);
        if (checkMistakes) {
            mistakes(command, ((args[i] === errSymbol) ||¬†(args[i] === undefined)) ? undefined : args[i], "A symbol does not exist or can't be shown");
        };
    };
    return output.join("");
};

function str(command) {
    // Make sure the command is a string
    return (typeof command === "string") ? command : errSymbol;
};

function extraArgs(args, initialCommand) {
    // If the user enters to many arguments in a function, the extras will be sent to this function
    // e.g. \mathbf{A}{B} will result in \mathbf{A}\mathord{B}
    return mathord(args, initialCommand);
};


//-----------------------------------------------------//

/** Check mistakes **/

function mistakes(textInput, textOutput, letter="") {
    // Writes every errors in a box, so it's easier for the user to find them

    const text = "\u{1D404}\u{1D42B}\u{1D42B}\u{1D428}\u{1D42B}\u{1D42C}: \r\n";  // "Errors" in bold
    if (textOutput === undefined) {
        if (letter !== "") {
            if (letter !== errSymbol) {  // Only add to errorsList once
                if (letter.includes("\u2710")) {  // i.e. Spaces
                    if (textInput.substring(0,5) === "\\text") {
                        errorsList += spaceCommand(textInput + " \u2192 Spaces are kept inside '" + textInput.replace(/{.*}/g, "") + "{}', no need for a spacing command") + "\r\n";
                    } else if ((textInput[0] === "^") || (textInput[0] === "_") || (textInput.substring(0,5) == "\\frac")) {
                        const initialSpaceCommand = ["\\:", "\\;", "\\quad", "\\qquad"];
                        errorsList += spaceCommand(textInput + " \u2192 Replace '" + initialSpaceCommand[letter.length-1] + "' by '\\hspace{" + letter.length + "}'") + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                } else if ((textInput[0] === "^") || (textInput[0] === "_")) {
                    if (letter.indexOf("Can't find an argument") !== -1) {
                        const example = (textInput[0] === "^") ? "‚Åø" : "‚Çô";
                        errorsList += "For '" + textInput[0] + "' alone: \\" + textInput[0] + " \u2192 " + textInput[0] + 
                        "  |  To use '" + textInput[0] + "' as a command: " + textInput[0] + "{n} \u2192 " + example + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                } else {
                    errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                };
            };
        } else {
            if ((textInput[0] === "^") || (textInput[0] === "_")) {
                if (textInput[1] === "{") {
                    errorsList += '"' + textInput + '" \u2192 ' + "Argument does not exists" + '\r\n';
                } else {
                    errorsList += '"' + textInput + '" \u2192 ' + "try: " + textInput[0] + "{" + textInput.slice(1) + "}" + '\r\n';
                };
            } else {
                errorsList += '"' + textInput + '" \r\n';
            };
        };
    };
    if (errorsList.length > 0) {
        mistakesBox.textContent = text + errorsList;
    };
    return errSymbol;
};


//-----------------------------------------------------//

/** Matrix document class **/

function matrix(text) {
    // If the keyword !matrix is used as the first word of the input text, this function is called
    // Converts arrays into a matrix (i.e. !matrix [a,b,c][1,2,3] will be converted to a matrix 2x3)
    text = text.replace(/ /g, "");
    let matrixText = "";
    let i, x;
    let cpt = 0;
    let rceil = 0;
    let lceil = 0;
    let lfloor = 0;
    let rfloor = 0;

    for (x in text) {
        if (text[x] == "[" || text[x] == "]") {
            cpt += 1;
        };
    };
    if (cpt == 2) {
        // vector (ie single line matrix)
        matrixText = text.replace(/ /g, "");
        matrixText = matrixText.replace(/\[/g, "[ ");
        matrixText = matrixText.replace(/\]/g, " ]");
        matrixText = matrixText.replace(/,/g, "\u2710");
        return spaceCommand(matrixText);
    } else {
        for (i in text) {
            if (text[i] == "[" && rceil == 0) {
                matrixText += "\u23A1 ";
                rceil += 1;
            } else if (text[i] == "]" && lceil == 0) {
                matrixText += " \u23A4\u000A";
                lceil += 1;
            } else if (text[i] == "]") {
                matrixText += " \u23A5\u000A";
            } else if (text[i] == "[") {
                matrixText += "\u23A2 ";
            } else {
                matrixText += text[i];
            }
        };
        for (let n = matrixText.length; n > 0; n--) {
            if (matrixText[n] == "\u23A5" && n > rfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A6";
                matrixText[n+1] = "";  // removes "\u000A" since it's the last line
                matrixText = matrixText.join("");
                rfloor = n;
            } else if (matrixText[n] == "\u23A2" && n > lfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A3";
                matrixText = matrixText.join("");
                lfloor = n;
            };
        };
    };
    matrixText = matrixCols(matrixText);  // Adjusts columns width
    matrixText = matrixText.replace(/,/g, " ");  // Add spaces between characters
    if ((cpt % 2 != 0) || (cpt == 0)) {
        matrixText = "";
        mistakes('Wrong arguments given" \r\n \r\nExample: "!matrix [a,b,c] [d,e,f] [1,2,3]', undefined);
    };
    return spaceCommand(matrixText);
};

function matrixCols(matrix) {
    // Adjusts columns length for !matrix package
    // So, if the input is [100,10,1][0,0,0], the output should still be a 2x3 matrix with the elements aligned
    let positionLength = 0;
    let posLengths = [];
    let matrixPositions = [];
    let matrixPos = 0;
    let realPositions = [];
    for (let i in matrix) {
        if (matrix[i] == ",") {
            matrixPositions.push(matrixPos);
            matrixPos += 1;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-1);
        } else if ((matrix[i] == "\u23A4") || (matrix[i] == "\u23A5") || (matrix[i] == "\u23A6")) {  // right bracket
            matrixPositions.push(matrixPos);
            matrixPos = 0;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-2);
        } else if ((matrix[i] == "\u23A1") || (matrix[i] == "\u23A2") || (matrix[i] == "\u23A3") || (matrix[i] == " ") || (matrix[i] == "\u000A")) {  // left bracket and spaces
            continue;
        } else {
            positionLength += 1;
        };
    };
    // Add spaces to adjust columns length
    let spacesAdded = 1;
    for (let i in posLengths) {
        for (let n in matrixPositions) {
            if (matrixPositions[i] == matrixPositions[n]) {
                matrix = matrix.split("");
                while (posLengths[i] < posLengths[n]) {
                    matrix.splice(realPositions[i] + spacesAdded, 0, " ");
                    posLengths[i] += 1;
                    spacesAdded += 1;
                };
                matrix = matrix.join("");
            };
        };
    };
    return matrix;
};


//-----------------------------------------------------//

/** Automatic spacing **/

function spaceCommand(text) {
    // Add spaces ("\:" command)
    // Internally, spaces that are kept even if 'Adjust spaces' is on are represented as \u2710
    // this function changes them back to spaces
    text = text.replace(/\u2710/g, " ")

    // Also, it removes a space around the command \! (and the command itself)
            .replace(/\u270E /g, "")
            .replace(/ \u270E/g, "")
            .replace(/\u270E/g, "");
    return text;
};

function adjustSpacesCommon(input, symbolSpaced, conditionalSpaces) {
    // Removes spaces and add some depending on surrounding symbols
    // Used if 'Adjust space' is on

    /* 
        TODO: Spacing around symbols like '+' should depend of context
        For instance f(y+2) should return f(y+2), but 3x¬≤+4y should return 3x¬≤ + 4y 
        Also, a_{i}-x should return a_{i} - x, but \sum_{i}-x should return \sum_{i}-x (as in \sum_{i}(-x) or -\sum_{i}x)
        Again, it should take the context in consideration
    */

    if ((spacesButton.checked == true) && (input.length > 2)) {
        const noSpaceSymbols = Object.values(Subscript).concat(Object.values(Above), Object.values(Below)).filter(x => {return x !== "\u2710";});
        // noSpaceSymbols is a list of all the symbols (subscript and combined symbol, without spaces) that delay a space to be added.
        // For instance, the spaces in 'x \equiv_{2} 0 \def x \equiv 0 (mod 2)' should be kept the same and therefore 'delay' the space
        // to be added from \equiv because of the subscript.
        const spacedChar = characters.concat(noSpaceSymbols, Object.values(Superscript));  // Add space around 'conditionalSpaces' if the previous symbol is in spacedChar
        let output = "";
        input = input.replace(/ /g, "");
        let delayedSpace = false;
        let spaceStored = [];
        for (let i in input) {
            delayedSpace = noSpaceSymbols.includes(input[parseInt(i)+1]);
            if (symbolSpaced.includes(input[i])) {
                if ((output[output.length - 1] !== " ") &&¬†(output[output.length - 1] !== undefined)) {
                    if (delayedSpace) {
                        output += " " + input[i];
                        spaceStored.push(" ");
                    } else {
                        output += " " + input[i] + " ";
                    }
                } else {
                    if (delayedSpace) {
                        output += input[i];
                        spaceStored.push(" ");
                    } else {
                        output += input[i] + " ";
                    };
                };
            } else if (conditionalSpaces.includes(input[i])) {
                if ((output[output.length - 1] !== " ") &&¬†(output[output.length - 1] !== undefined) && (spacedChar.includes(output[output.length - 1]))) {
                    if (delayedSpace) {
                        output += " " + input[i];
                    } else {
                        output += " " + input[i] + " ";
                    };
                } else {
                    output += input[i];
                };
            } else {
                if (delayedSpace) {
                    output += input[i];
                } else {
                    if (spaceStored.length >= 1) {
                        output += input[i] + " ";
                        spaceStored = [];
                    }
                    else {
                        output += input[i];
                    };
                };
            };
        };
        return spaceCommand(output);
    } else {
        return spaceCommand(input);
    };
};

function adjustSpaces(input) {
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    const symbolSpaced = ["\u003D", "\u003C", "\u003E", "\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
                          "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
                          "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
                          "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
                          "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
                          "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2261", "\u2A67", "\u2263",
                          "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
                          "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
                          "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2226",
                          "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u2250", "\u2A66",
                          "\u00D7", "\u22CA", "\u22C9", "\u225D", "\u2254", "\u2255"];
    const conditionalSpaces = ["\u002B", "\u2212", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};

function adjustSpaceChem(input) {
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    const symbolSpaced = ["\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", "\u003C", "\u003E",
                          "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
                          "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
                          "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
                          "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
                          "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2A67", "\u2250", "\u2A66",
                          "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
                          "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
                          "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2226", 
                          "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u00D7", "\u22CA",
                          "\u22C9", "\u225D", "\u2254", "\u2255"];
    const conditionalSpaces = ["\u002B", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};


//-----------------------------------------------------//

/** Main **/

function convert(fullText) {
    // Takes text and convert it based on the documentclass (or package)
    const dictOutMathmode = {...lettersOutMathMode, ...accents, ...textCommands};
    const firstWord = fullText.split(" ")[0];
    let fullDict;
    if (firstWord === "!chem") {
        // Chemistry package, differs in the automatic conversion of letters and spacing adjustments
        fullDict = makeDict(firstWord);
        fullText = fullText.replace("!chem", "");
        fullText = tokensToText(tokenize(fullText, changeModeButton.checked), fullDict, dictOutMathmode, adjustSpaceChem);
    } else if (firstWord === "!matrix") {
        // Matrix package, the input should be of the form [a,b,c][d,e,f]
        fullDict = makeDict(firstWord);
        fullText = fullText.replace("!matrix", "");
        fullText = tokensToText(tokenize(fullText, true), fullDict, dictOutMathmode, adjustSpaces);
        fullText = matrix(fullText);
        if (changeFontButton.checked) {
            mistakes("!matrix", undefined, "Works better with 'Mathematical font' unchecked");
        };
    } else {
        // Default package
        fullDict = makeDict("default");
        fullText = tokensToText(tokenize(fullText, changeModeButton.checked), fullDict, dictOutMathmode, adjustSpaces);
    };
    return fullText;
};

function makeDict(documentClass) {
    // Returns the full dictionary (in mathmode) with all the commands, letters, etc. based on documentclass and font choice
    const greek = (changeFontButton.checked) ? stdGreek : noStyleGreek;
    let letters;  // lettersMath or lettersNoFont
    if (documentClass === "!chem") {
        letters = lettersNoFont;  // Works better to "draw" molecules with lewis notation
    } else if (documentClass === "!matrix") {
        letters = (changeFontButton.checked) ? lettersMath : lettersNoFont;
    } else {  // documentClass === "default"
        letters = (changeFontButton.checked) ? lettersMath : lettersNoFont;
    };
    return buildAllCommands({...mathDictionary, ...greek, ...letters, ...accents});
};

function main() {
    // Takes the original text (input) and outputs the new one, with the converted symbols

    let fullText = textIn.value;
    
    mistakesBox.textContent = "";  // Starts with an empty box for errors
    errorsList = "";  // Makes sure it starts empty

    fullText = convert(fullText + " ");

    textOut.value = fullText;
    textOut.disabled = false;
};