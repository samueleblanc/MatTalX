/*
    The main purpose of this program is to take a text as input (mostly LaTeX commands), 
    to convert them into the desired symbol (UTF) and finally to display them so they can 
    be copied and sent via Messenger, Instagram, Twitter, etc.
*/


/*
    CODE STRUCTURE
    
    N.B. Every section header has the format: /// NAME /// and every subsection: * Name *


    /// GLOBALS ///  -> All the global variables
    â”‚
    â”œâ”€ Functions (as const)
    â”œâ”€ Dictionaries
    â”œâ”€ HTMLElements
    â”œâ”€ Other
    â”‚
    /// FUNCTIONS ///  -> All the functions
    â”‚
    â”œâ”€ Front-end
    â”œâ”€ Suggestion box (or completion)
    â”œâ”€ Convert text
    â”‚   â”œâ”€ Main functions
    â”‚   â””â”€ Used by main functions
    â”œâ”€ Check mistakes
    â”œâ”€ Matrix document class
    â”œâ”€ Automatic spacing
    â””â”€ Main
*/


/**************************************************************************************/

"use strict";

/// GLOBALS ///


/** Functions (as const) **/

const mathbb = (arg, initialCommand) => {
    // mathbb stands for math blackboard-bold
    // This function converts the list of characters to the corresponding blackboard-bold character
    const symbols = {
        "A" : "\u{1D538}",
        "B" : "\u{1D539}",
        "C" : "\u2102",
        "D" : "\u{1D53B}",
        "E" : "\u{1D53C}",
        "F" : "\u{1D53D}",
        "G" : "\u{1D53E}",
        "H" : "\u210D",
        "I" : "\u{1D540}",
        "J" : "\u{1D541}",
        "K" : "\u{1D542}",
        "L" : "\u{1D543}",
        "M" : "\u{1D544}",
        "N" : "\u2115",
        "O" : "\u{1D546}",
        "P" : "\u2119",
        "Q" : "\u211A",
        "R" : "\u211D",
        "S" : "\u{1D54A}",
        "T" : "\u{1D54B}",
        "U" : "\u{1D54C}",
        "V" : "\u{1D54D}",
        "W" : "\u{1D54E}",
        "X" : "\u{1D54F}",
        "Y" : "\u{1D550}",
        "Z" : "\u2124",
        "a" : "\u{1D552}",
        "b" : "\u{1D553}",
        "c" : "\u{1D554}",
        "d" : "\u{1D555}",
        "e" : "\u{1D556}",
        "f" : "\u{1D557}",
        "g" : "\u{1D558}",
        "h" : "\u{1D559}",
        "i" : "\u{1D55A}",
        "j" : "\u{1D55B}",
        "k" : "\u{1D55C}",
        "l" : "\u{1D55D}",
        "m" : "\u{1D55E}",
        "n" : "\u{1D55F}",
        "o" : "\u{1D560}",
        "p" : "\u{1D561}",
        "q" : "\u{1D562}",
        "r" : "\u{1D563}",
        "s" : "\u{1D564}",
        "t" : "\u{1D565}",
        "u" : "\u{1D566}",
        "v" : "\u{1D567}",
        "w" : "\u{1D568}",
        "x" : "\u{1D569}",
        "y" : "\u{1D56A}",
        "z" : "\u{1D56B}",

        "ğ´" : "\u{1D538}",
        "ğµ" : "\u{1D539}",
        "ğ¶" : "\u2102",
        "ğ·" : "\u{1D53B}",
        "ğ¸" : "\u{1D53C}",
        "ğ¹" : "\u{1D53D}",
        "ğº" : "\u{1D53E}",
        "ğ»" : "\u210D",
        "ğ¼" : "\u{1D540}",
        "ğ½" : "\u{1D541}",
        "ğ¾" : "\u{1D542}",
        "ğ¿" : "\u{1D543}",
        "ğ‘€" : "\u{1D544}",
        "ğ‘" : "\u2115",
        "ğ‘‚" : "\u{1D546}",
        "ğ‘ƒ" : "\u2119",
        "ğ‘„" : "\u211A",
        "ğ‘…" : "\u211D",
        "ğ‘†" : "\u{1D54A}",
        "ğ‘‡" : "\u{1D54B}",
        "ğ‘ˆ" : "\u{1D54C}",
        "ğ‘‰" : "\u{1D54D}",
        "ğ‘Š" : "\u{1D54E}",
        "ğ‘‹" : "\u{1D54F}",
        "ğ‘Œ" : "\u{1D550}",
        "ğ‘" : "\u2124",
        "ğ‘" : "\u{1D552}",
        "ğ‘" : "\u{1D553}",
        "ğ‘" : "\u{1D554}",
        "ğ‘‘" : "\u{1D555}",
        "ğ‘’" : "\u{1D556}",
        "ğ‘“" : "\u{1D557}",
        "ğ‘”" : "\u{1D558}",
        "â„" : "\u{1D559}",
        "ğ‘–" : "\u{1D55A}",
        "ğ‘—" : "\u{1D55B}",
        "ğ‘˜" : "\u{1D55C}",
        "ğ‘™" : "\u{1D55D}",
        "ğ‘š" : "\u{1D55E}",
        "ğ‘›" : "\u{1D55F}",
        "ğ‘œ" : "\u{1D560}",
        "ğ‘" : "\u{1D561}",
        "ğ‘" : "\u{1D562}",
        "ğ‘Ÿ" : "\u{1D563}",
        "ğ‘ " : "\u{1D564}",
        "ğ‘¡" : "\u{1D565}",
        "ğ‘¢" : "\u{1D566}",
        "ğ‘£" : "\u{1D567}",
        "ğ‘¤" : "\u{1D568}",
        "ğ‘¥" : "\u{1D569}",
        "ğ‘¦" : "\u{1D56A}",
        "ğ‘§" : "\u{1D56B}",
        
        "ğ›¾" : "\u213D",
        "ğ›¤" : "\u213E",
        "ğ›±" : "\u213F",
        "ğœ‹" : "\u213C",
        "ğ›´" : "\u2140",
        "Î£" : "\u2140",
        "Î " : "\u213F",
        "Ï€" : "\u213C",
        "Î³" : "\u213D",
        "Î“" : "\u213E",

        "0" : "\u{1D7D8}",
        "1" : "\u{1D7D9}",
        "2" : "\u{1D7DA}",
        "3" : "\u{1D7DB}",
        "4" : "\u{1D7DC}",
        "5" : "\u{1D7DD}",
        "6" : "\u{1D7DE}",
        "7" : "\u{1D7DF}",
        "8" : "\u{1D7E0}",
        "9" : "\u{1D7E1}",

        "(" : "â¦…",
        "{" : "â¦ƒ",
        "[" : "âŸ¦",
        "]" : "âŸ§",
        "}" : "â¦„",
        ")" : "â¦†",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathbf = (arg, initialCommand) => {
    // mathbf stands for math bold font
    // This function converts the list of characters to the corresponding bold font character
    const symbols = {
        "A" : "\u{1D468}",
        "a" : "\u{1D482}",
        "B" : "\u{1D469}",
        "b" : "\u{1D483}",
        "C" : "\u{1D46A}",
        "c" : "\u{1D484}",
        "D" : "\u{1D46B}",
        "d" : "\u{1D485}",
        "E" : "\u{1D46C}",
        "e" : "\u{1D486}",
        "F" : "\u{1D46D}",
        "f" : "\u{1D487}",
        "G" : "\u{1D46E}",
        "g" : "\u{1D488}",
        "H" : "\u{1D46F}",
        "h" : "\u{1D489}",
        "I" : "\u{1D470}",
        "i" : "\u{1D48A}",
        "J" : "\u{1D471}",
        "j" : "\u{1D48B}",
        "K" : "\u{1D472}",
        "k" : "\u{1D48C}",
        "L" : "\u{1D473}",
        "l" : "\u{1D48D}",
        "M" : "\u{1D474}",
        "m" : "\u{1D48E}",
        "N" : "\u{1D475}",
        "n" : "\u{1D48F}",
        "O" : "\u{1D476}",
        "o" : "\u{1D490}",
        "P" : "\u{1D477}",
        "p" : "\u{1D491}",
        "Q" : "\u{1D478}",
        "q" : "\u{1D492}",
        "R" : "\u{1D479}",
        "r" : "\u{1D493}",
        "S" : "\u{1D47A}",
        "s" : "\u{1D494}",
        "T" : "\u{1D47B}",
        "t" : "\u{1D495}",
        "U" : "\u{1D47C}",
        "u" : "\u{1D496}",
        "V" : "\u{1D47D}",
        "v" : "\u{1D497}",
        "W" : "\u{1D47E}",
        "w" : "\u{1D498}",
        "X" : "\u{1D47F}",
        "x" : "\u{1D499}",
        "Y" : "\u{1D480}",
        "y" : "\u{1D49A}",
        "Z" : "\u{1D481}",
        "z" : "\u{1D49B}",

        "ğ´" : "\u{1D468}",
        "ğ‘" : "\u{1D482}",
        "ğµ" : "\u{1D469}",
        "ğ‘" : "\u{1D483}",
        "ğ¶" : "\u{1D46A}",
        "ğ‘" : "\u{1D484}",
        "ğ·" : "\u{1D46B}",
        "ğ‘‘" : "\u{1D485}",
        "ğ¸" : "\u{1D46C}",
        "ğ‘’" : "\u{1D486}",
        "ğ¹" : "\u{1D46D}",
        "ğ‘“" : "\u{1D487}",
        "ğº" : "\u{1D46E}",
        "ğ‘”" : "\u{1D488}",
        "ğ»" : "\u{1D46F}",
        "â„" : "\u{1D489}",
        "ğ¼" : "\u{1D470}",
        "ğ‘–" : "\u{1D48A}",
        "ğ½" : "\u{1D471}",
        "ğ‘—" : "\u{1D48B}",
        "ğ¾" : "\u{1D472}",
        "ğ‘˜" : "\u{1D48C}",
        "ğ¿" : "\u{1D473}",
        "ğ‘™" : "\u{1D48D}",
        "ğ‘€" : "\u{1D474}",
        "ğ‘š" : "\u{1D48E}",
        "ğ‘" : "\u{1D475}",
        "ğ‘›" : "\u{1D48F}",
        "ğ‘‚" : "\u{1D476}",
        "ğ‘œ" : "\u{1D490}",
        "ğ‘ƒ" : "\u{1D477}",
        "ğ‘" : "\u{1D491}",
        "ğ‘„" : "\u{1D478}",
        "ğ‘" : "\u{1D492}",
        "ğ‘…" : "\u{1D479}",
        "ğ‘Ÿ" : "\u{1D493}",
        "ğ‘†" : "\u{1D47A}",
        "ğ‘ " : "\u{1D494}",
        "ğ‘‡" : "\u{1D47B}",
        "ğ‘¡" : "\u{1D495}",
        "ğ‘ˆ" : "\u{1D47C}",
        "ğ‘¢" : "\u{1D496}",
        "ğ‘‰" : "\u{1D47D}",
        "ğ‘£" : "\u{1D497}",
        "ğ‘Š" : "\u{1D47E}",
        "ğ‘¤" : "\u{1D498}",
        "ğ‘‹" : "\u{1D47F}",
        "ğ‘¥" : "\u{1D499}",
        "ğ‘Œ" : "\u{1D480}",
        "ğ‘¦" : "\u{1D49A}",
        "ğ‘" : "\u{1D481}",
        "ğ‘§" : "\u{1D49B}",

        "0" : "\u{1D7CE}",
        "1" : "\u{1D7CF}",
        "2" : "\u{1D7D0}",
        "3" : "\u{1D7D1}",
        "4" : "\u{1D7D2}",
        "5" : "\u{1D7D3}",
        "6" : "\u{1D7D4}",
        "7" : "\u{1D7D5}",
        "8" : "\u{1D7D6}",
        "9" : "\u{1D7D7}",

        "âˆ‚" : "\u{1D789}",

        // Greek
        "ğ›¢" : "\u{1D71C}",
        "ğ›¼" : "\u{1D736}",
        "ğ›£" : "\u{1D71D}",
        "ğ›½" : "\u{1D737}",
        "ğ›¤" : "\u{1D71E}",
        "ğ›¾" : "\u{1D738}",
        "Î”" : "\u{1D6AB}",
        "ğ›¥" : "\u{1D71F}",
        "ğ›¿" : "\u{1D739}",
        "ğ›¦" : "\u{1D720}",
        "Ïµ" : "\u{1D6DC}",
        "Îµ" : "\u{1D6C6}",
        "ğ›§" : "\u{1D721}",
        "ğœ" : "\u{1D73B}",
        "ğ›¨" : "\u{1D722}",
        "ğœ‚" : "\u{1D73C}",
        "Î˜" : "\u{1D6BD}",
        "ğœƒ" : "\u{1D73D}",
        "ğœ—" : "\u{1D751}",
        "ğ›ª" : "\u{1D724}",
        "ğœ„" : "\u{1D73E}",
        "ğ›«" : "\u{1D725}",
        "ğœ…" : "\u{1D73F}",
        "ğœ˜" : "\u{1D752}",
        "ğ›¬" : "\u{1D726}",
        "ğœ†" : "\u{1D740}",
        "ğ›­" : "\u{1D727}",
        "ğœ‡" : "\u{1D741}",
        "ğ›®" : "\u{1D728}",
        "ğœˆ" : "\u{1D742}",
        "Î" : "\u{1D6B5}",
        "ğœ‰" : "\u{1D743}",
        "ğ›°" : "\u{1D72A}",
        "ğœŠ" : "\u{1D744}",
        "ğ›±" : "\u{1D72B}",
        "ğœ‹" : "\u{1D745}",
        "ğœ›" : "\u{1D755}",
        "ğ›²" : "\u{1D72C}",
        "ğœŒ" : "\u{1D746}",
        "ğœš" : "\u{1D754}",
        "ğ›´" : "\u{1D72E}",
        "ğœ" : "\u{1D748}",
        "ğœ" : "\u{1D747}",
        "ğ›µ" : "\u{1D72F}",
        "ğœ" : "\u{1D749}",
        "ğ›¶" : "\u{1D730}",
        "ğœ" : "\u{1D74A}",
        "Î¦" : "\u{1D6BD}",
        "ğœ™" : "\u{1D753}",
        "ğœ‘" : "\u{1D74B}",
        "ğ›¸" : "\u{1D732}",
        "ğœ’" : "\u{1D74C}",
        "ğ›¹" : "\u{1D733}",
        "ğœ“" : "\u{1D74D}",
        "â„¦" : "\u{1D6C0}",
        "ğœ”" : "\u{1D74E}",

        "Î‘" : "\u{1D756}",
        "Î±" : "\u{1D770}",
        "Î’" : "\u{1D757}",
        "Î²" : "\u{1D771}",
        "Î“" : "\u{1D758}",
        "Î³" : "\u{1D772}",
        "Î´" : "\u{1D6C5}",
        "Î•" : "\u{1D75A}",
        "Î–" : "\u{1D75B}",
        "Î¶" : "\u{1D775}",
        "Î—" : "\u{1D75C}",
        "Î·" : "\u{1D776}",
        "Î¸" : "\u{1D6C9}",
        "Ï‘" : "\u{1D6DD}",
        "Î™" : "\u{1D75E}",
        "Î¹" : "\u{1D6CA}",
        "Îš" : "\u{1D75F}",
        "Îº" : "\u{1D779}",
        "Ï°" : "\u{1D78C}",
        "Î›" : "\u{1D760}",
        "Î»" : "\u{1D77A}",
        "Îœ" : "\u{1D761}",
        "Î¼" : "\u{1D77B}",
        "Î" : "\u{1D762}",
        "Î½" : "\u{1D77C}",
        "Î¾" : "\u{1D77D}",
        "ÎŸ" : "\u{1D764}",
        "Î¿" : "\u{1D77E}",
        "Î " : "\u{1D765}",
        "Ï€" : "\u{1D77F}",
        "Ï–" : "\u{1D78F}",
        "Î¡" : "\u{1D766}",
        "Ï" : "\u{1D780}",
        "Ï±" : "\u{1D78E}",
        "Î£" : "\u{1D768}",
        "Ïƒ" : "\u{1D782}",
        "Ï‚" : "\u{1D781}",
        "Î¤" : "\u{1D769}",
        "Ï„" : "\u{1D783}",
        "Î¥" : "\u{1D76A}",
        "Ï…" : "\u{1D784}",
        "Ï•" : "\u{1D78D}",
        "Ï†" : "\u{1D785}",
        "Î§" : "\u{1D76C}",
        "Ï‡" : "\u{1D786}",
        "Î¨" : "\u{1D76D}",
        "Ïˆ" : "\u{1D787}",
        "Î©" : "\u{1D76E}",
        "Ï‰" : "\u{1D788}",

        // mathcal
        "ğ’œ" : "\u{1D4D0}",
        "ğ’¶" : "\u{1D4EA}",
        "â„¬" : "\u{1D4D1}",
        "ğ’·" : "\u{1D4EB}",
        "ğ’" : "\u{1D4D2}",
        "ğ’¸" : "\u{1D4EC}",
        "ğ’Ÿ" : "\u{1D4D3}",
        "ğ’¹" : "\u{1D4ED}",
        "â„°" : "\u{1D4D4}",
        "â„¯" : "\u{1D4EE}",
        "â„±" : "\u{1D4D5}",
        "ğ’»" : "\u{1D4EF}",
        "ğ’¢" : "\u{1D4D6}",
        "â„Š" : "\u{1D4F0}",
        "â„‹" : "\u{1D4D7}",
        "ğ’½" : "\u{1D4F1}",
        "â„" : "\u{1D4D8}",
        "ğ’¾" : "\u{1D4F2}",
        "ğ’¥" : "\u{1D4D9}",
        "ğ’¿" : "\u{1D4F3}",
        "ğ’¦" : "\u{1D4DA}",
        "ğ“€" : "\u{1D4F4}",
        "â„’" : "\u{1D4DB}",
        "ğ“" : "\u{1D4F5}",
        "â„³" : "\u{1D4DC}",
        "ğ“‚" : "\u{1D4F6}",
        "ğ’©" : "\u{1D4DD}",
        "ğ“ƒ" : "\u{1D4F7}",
        "ğ’ª" : "\u{1D4DE}",
        "â„´" : "\u{1D4F8}",
        "ğ’«" : "\u{1D4DF}",
        "ğ“…" : "\u{1D4F9}",
        "ğ’¬" : "\u{1D4E0}",
        "ğ“†" : "\u{1D4FA}",
        "â„›" : "\u{1D4E1}",
        "ğ“‡" : "\u{1D4FB}",
        "ğ’®" : "\u{1D4E2}",
        "ğ“ˆ" : "\u{1D4FC}",
        "ğ’¯" : "\u{1D4E3}",
        "ğ“‰" : "\u{1D4FD}",
        "ğ’°" : "\u{1D4E4}",
        "ğ“Š" : "\u{1D4FE}",
        "ğ’±" : "\u{1D4E5}",
        "ğ“‹" : "\u{1D4FF}",
        "ğ’²" : "\u{1D4E6}",
        "ğ“Œ" : "\u{1D500}",
        "ğ’³" : "\u{1D4E7}",
        "ğ“" : "\u{1D501}",
        "ğ’´" : "\u{1D4E8}",
        "ğ“" : "\u{1D502}",
        "ğ’µ" : "\u{1D4E9}",
        "ğ“" : "\u{1D503}",

        // mathfrak
        "ğ”„" : "\u{1D56C}",
        "ğ”" : "\u{1D586}",
        "ğ”…" : "\u{1D56D}",
        "ğ”Ÿ" : "\u{1D587}",
        "â„­" : "\u{1D56E}",
        "ğ” " : "\u{1D588}",
        "ğ”‡" : "\u{1D56F}",
        "ğ”¡" : "\u{1D589}",
        "ğ”ˆ" : "\u{1D570}",
        "ğ”¢" : "\u{1D58A}",
        "ğ”‰" : "\u{1D571}",
        "ğ”£" : "\u{1D58B}",
        "ğ”Š" : "\u{1D572}",
        "ğ”¤" : "\u{1D58C}",
        "â„Œ" : "\u{1D573}",
        "ğ”¥" : "\u{1D58D}",
        "â„‘" : "\u{1D574}",
        "ğ”¦" : "\u{1D58E}",
        "ğ”" : "\u{1D575}",
        "ğ”§" : "\u{1D58F}",
        "ğ”" : "\u{1D576}",
        "ğ”¨" : "\u{1D590}",
        "ğ”" : "\u{1D577}",
        "ğ”©" : "\u{1D591}",
        "ğ”" : "\u{1D578}",
        "ğ”ª" : "\u{1D592}",
        "ğ”‘" : "\u{1D579}",
        "ğ”«" : "\u{1D593}",
        "ğ”’" : "\u{1D57A}",
        "ğ”¬" : "\u{1D594}",
        "ğ”“" : "\u{1D57B}",
        "ğ”­" : "\u{1D595}",
        "ğ””" : "\u{1D57C}",
        "ğ”®" : "\u{1D596}",
        "â„œ" : "\u{1D57D}",
        "ğ”¯" : "\u{1D597}",
        "ğ”–" : "\u{1D57E}",
        "ğ”°" : "\u{1D598}",
        "ğ”—" : "\u{1D57F}",
        "ğ”±" : "\u{1D599}",
        "ğ”˜" : "\u{1D580}",
        "ğ”²" : "\u{1D59A}",
        "ğ”™" : "\u{1D581}",
        "ğ”³" : "\u{1D59B}",
        "ğ”š" : "\u{1D582}",
        "ğ”´" : "\u{1D59C}",
        "ğ”›" : "\u{1D583}",
        "ğ”µ" : "\u{1D59D}",
        "ğ”œ" : "\u{1D584}",
        "ğ”¶" : "\u{1D59E}",
        "â„¨" : "\u{1D585}",
        "ğ”·" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathcal = (arg, initialCommand) => {
    // mathcal stands for math calligraphic
    // This function converts the list of characters to the corresponding calligraphic character
    const symbols = {
        "A" : "\u{1D49C}",
        "a" : "\u{1D4B6}",
        "B" : "\u212C",
        "b" : "\u{1D4B7}",
        "C" : "\u{1D49E}",
        "c" : "\u{1D4B8}",
        "D" : "\u{1D49F}",
        "d" : "\u{1D4B9}",
        "E" : "\u2130",
        "e" : "\u212F",
        "F" : "\u2131",
        "f" : "\u{1D4BB}",
        "G" : "\u{1D4A2}",
        "g" : "\u210A",
        "H" : "\u210B",
        "h" : "\u{1D4BD}",
        "I" : "\u2110",
        "i" : "\u{1D4BE}",
        "J" : "\u{1D4A5}",
        "j" : "\u{1D4BF}",
        "K" : "\u{1D4A6}",
        "k" : "\u{1D4C0}",
        "L" : "\u2112",
        "l" : "\u{1D4C1}",
        "M" : "\u2133",
        "m" : "\u{1D4C2}",
        "N" : "\u{1D4A9}",
        "n" : "\u{1D4C3}",
        "O" : "\u{1D4AA}",
        "o" : "\u2134",
        "P" : "\u{1D4AB}",
        "p" : "\u{1D4C5}",
        "Q" : "\u{1D4AC}",
        "q" : "\u{1D4C6}",
        "R" : "\u211B",
        "r" : "\u{1D4C7}",
        "S" : "\u{1D4AE}",
        "s" : "\u{1D4C8}",
        "T" : "\u{1D4AF}",
        "t" : "\u{1D4C9}",
        "U" : "\u{1D4B0}",
        "u" : "\u{1D4CA}",
        "V" : "\u{1D4B1}",
        "v" : "\u{1D4CB}",
        "W" : "\u{1D4B2}",
        "w" : "\u{1D4CC}",
        "X" : "\u{1D4B3}",
        "x" : "\u{1D4CD}",
        "Y" : "\u{1D4B4}",
        "y" : "\u{1D4CE}",
        "Z" : "\u{1D4B5}",
        "z" : "\u{1D4CF}",

        "ğ´" : "\u{1D49C}",
        "ğ‘" : "\u{1D4B6}",
        "ğµ" : "\u212C",
        "ğ‘" : "\u{1D4B7}",
        "ğ¶" : "\u{1D49E}",
        "ğ‘" : "\u{1D4B8}",
        "ğ·" : "\u{1D49F}",
        "ğ‘‘" : "\u{1D4B9}",
        "ğ¸" : "\u2130",
        "ğ‘’" : "\u212F",
        "ğ¹" : "\u2131",
        "ğ‘“" : "\u{1D4BB}",
        "ğº" : "\u{1D4A2}",
        "ğ‘”" : "\u210A",
        "ğ»" : "\u210B",
        "â„" : "\u{1D4BD}",
        "ğ¼" : "\u2110",
        "ğ‘–" : "\u{1D4BE}",
        "ğ½" : "\u{1D4A5}",
        "ğ‘—" : "\u{1D4BF}",
        "ğ¾" : "\u{1D4A6}",
        "ğ‘˜" : "\u{1D4C0}",
        "ğ¿" : "\u2112",
        "ğ‘™" : "\u{1D4C1}",
        "ğ‘€" : "\u2133",
        "ğ‘š" : "\u{1D4C2}",
        "ğ‘" : "\u{1D4A9}",
        "ğ‘›" : "\u{1D4C3}",
        "ğ‘‚" : "\u{1D4AA}",
        "ğ‘œ" : "\u2134",
        "ğ‘ƒ" : "\u{1D4AB}",
        "ğ‘" : "\u{1D4C5}",
        "ğ‘„" : "\u{1D4AC}",
        "ğ‘" : "\u{1D4C6}",
        "ğ‘…" : "\u211B",
        "ğ‘Ÿ" : "\u{1D4C7}",
        "ğ‘†" : "\u{1D4AE}",
        "ğ‘ " : "\u{1D4C8}",
        "ğ‘‡" : "\u{1D4AF}",
        "ğ‘¡" : "\u{1D4C9}",
        "ğ‘ˆ" : "\u{1D4B0}",
        "ğ‘¢" : "\u{1D4CA}",
        "ğ‘‰" : "\u{1D4B1}",
        "ğ‘£" : "\u{1D4CB}",
        "ğ‘Š" : "\u{1D4B2}",
        "ğ‘¤" : "\u{1D4CC}",
        "ğ‘‹" : "\u{1D4B3}",
        "ğ‘¥" : "\u{1D4CD}",
        "ğ‘Œ" : "\u{1D4B4}",
        "ğ‘¦" : "\u{1D4CE}",
        "ğ‘" : "\u{1D4B5}",
        "ğ‘§" : "\u{1D4CF}",

        "ğ‘¨" : "\u{1D4D0}",
        "ğ’‚" : "\u{1D4EA}",
        "ğ‘©" : "\u{1D4D1}",
        "ğ’ƒ" : "\u{1D4EB}",
        "ğ‘ª" : "\u{1D4D2}",
        "ğ’„" : "\u{1D4EC}",
        "ğ‘«" : "\u{1D4D3}",
        "ğ’…" : "\u{1D4ED}",
        "ğ‘¬" : "\u{1D4D4}",
        "ğ’†" : "\u{1D4EE}",
        "ğ‘­" : "\u{1D4D5}",
        "ğ’‡" : "\u{1D4EF}",
        "ğ‘®" : "\u{1D4D6}",
        "ğ’ˆ" : "\u{1D4F0}",
        "ğ‘¯" : "\u{1D4D7}",
        "ğ’‰" : "\u{1D4F1}",
        "ğ‘°" : "\u{1D4D8}",
        "ğ’Š" : "\u{1D4F2}",
        "ğ‘±" : "\u{1D4D9}",
        "ğ’‹" : "\u{1D4F3}",
        "ğ‘²" : "\u{1D4DA}",
        "ğ’Œ" : "\u{1D4F4}",
        "ğ‘³" : "\u{1D4DB}",
        "ğ’" : "\u{1D4F5}",
        "ğ‘´" : "\u{1D4DC}",
        "ğ’" : "\u{1D4F6}",
        "ğ‘µ" : "\u{1D4DD}",
        "ğ’" : "\u{1D4F7}",
        "ğ‘¶" : "\u{1D4DE}",
        "ğ’" : "\u{1D4F8}",
        "ğ‘·" : "\u{1D4DF}",
        "ğ’‘" : "\u{1D4F9}",
        "ğ‘¸" : "\u{1D4E0}",
        "ğ’’" : "\u{1D4FA}",
        "ğ‘¹" : "\u{1D4E1}",
        "ğ’“" : "\u{1D4FB}",
        "ğ‘º" : "\u{1D4E2}",
        "ğ’”" : "\u{1D4FC}",
        "ğ‘»" : "\u{1D4E3}",
        "ğ’•" : "\u{1D4FD}",
        "ğ‘¼" : "\u{1D4E4}",
        "ğ’–" : "\u{1D4FE}",
        "ğ‘½" : "\u{1D4E5}",
        "ğ’—" : "\u{1D4FF}",
        "ğ‘¾" : "\u{1D4E6}",
        "ğ’˜" : "\u{1D500}",
        "ğ‘¿" : "\u{1D4E7}",
        "ğ’™" : "\u{1D501}",
        "ğ’€" : "\u{1D4E8}",
        "ğ’š" : "\u{1D502}",
        "ğ’" : "\u{1D4E9}",
        "ğ’›" : "\u{1D503}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathfrak = (arg, initialCommand) => {
    // mathfrak stands for math fraktur
    // This function converts the list of characters to the corresponding fraktur character
    const symbols = {
        "A" : "\u{1D504}",
        "a" : "\u{1D51E}",
        "B" : "\u{1D505}",
        "b" : "\u{1D51F}",
        "C" : "\u212D",
        "c" : "\u{1D520}",
        "D" : "\u{1D507}",
        "d" : "\u{1D521}",
        "E" : "\u{1D508}",
        "e" : "\u{1D522}",
        "F" : "\u{1D509}",
        "f" : "\u{1D523}",
        "G" : "\u{1D50A}",
        "g" : "\u{1D524}",
        "H" : "\u210C",
        "h" : "\u{1D525}",
        "I" : "\u2111",
        "i" : "\u{1D526}",
        "J" : "\u{1D50D}",
        "j" : "\u{1D527}",
        "K" : "\u{1D50E}",
        "k" : "\u{1D528}",
        "L" : "\u{1D50F}",
        "l" : "\u{1D529}",
        "M" : "\u{1D510}",
        "m" : "\u{1D52A}",
        "N" : "\u{1D511}",
        "n" : "\u{1D52B}",
        "O" : "\u{1D512}",
        "o" : "\u{1D52C}",
        "P" : "\u{1D513}",
        "p" : "\u{1D52D}",
        "Q" : "\u{1D514}",
        "q" : "\u{1D52E}",
        "R" : "\u211C",
        "r" : "\u{1D52F}",
        "S" : "\u{1D516}",
        "s" : "\u{1D530}",
        "T" : "\u{1D517}",
        "t" : "\u{1D531}",
        "U" : "\u{1D518}",
        "u" : "\u{1D532}",
        "V" : "\u{1D519}",
        "v" : "\u{1D533}",
        "W" : "\u{1D51A}",
        "w" : "\u{1D534}",
        "X" : "\u{1D51B}",
        "x" : "\u{1D535}",
        "Y" : "\u{1D51C}",
        "y" : "\u{1D536}",
        "Z" : "\u2128",
        "z" : "\u{1D537}",

        "ğ´" : "\u{1D504}",
        "ğ‘" : "\u{1D51E}",
        "ğµ" : "\u{1D505}",
        "ğ‘" : "\u{1D51F}",
        "ğ¶" : "\u212D",
        "ğ‘" : "\u{1D520}",
        "ğ·" : "\u{1D507}",
        "ğ‘‘" : "\u{1D521}",
        "ğ¸" : "\u{1D508}",
        "ğ‘’" : "\u{1D522}",
        "ğ¹" : "\u{1D509}",
        "ğ‘“" : "\u{1D523}",
        "ğº" : "\u{1D50A}",
        "ğ‘”" : "\u{1D524}",
        "ğ»" : "\u210C",
        "â„" : "\u{1D525}",
        "ğ¼" : "\u2111",
        "ğ‘–" : "\u{1D526}",
        "ğ½" : "\u{1D50D}",
        "ğ‘—" : "\u{1D527}",
        "ğ¾" : "\u{1D50E}",
        "ğ‘˜" : "\u{1D528}",
        "ğ¿" : "\u{1D50F}",
        "ğ‘™" : "\u{1D529}",
        "ğ‘€" : "\u{1D510}",
        "ğ‘š" : "\u{1D52A}",
        "ğ‘" : "\u{1D511}",
        "ğ‘›" : "\u{1D52B}",
        "ğ‘‚" : "\u{1D512}",
        "ğ‘œ" : "\u{1D52C}",
        "ğ‘ƒ" : "\u{1D513}",
        "ğ‘" : "\u{1D52D}",
        "ğ‘„" : "\u{1D514}",
        "ğ‘" : "\u{1D52E}",
        "ğ‘…" : "\u211C",
        "ğ‘Ÿ" : "\u{1D52F}",
        "ğ‘†" : "\u{1D516}",
        "ğ‘ " : "\u{1D530}",
        "ğ‘‡" : "\u{1D517}",
        "ğ‘¡" : "\u{1D531}",
        "ğ‘ˆ" : "\u{1D518}",
        "ğ‘¢" : "\u{1D532}",
        "ğ‘‰" : "\u{1D519}",
        "ğ‘£" : "\u{1D533}",
        "ğ‘Š" : "\u{1D51A}",
        "ğ‘¤" : "\u{1D534}",
        "ğ‘‹" : "\u{1D51B}",
        "ğ‘¥" : "\u{1D535}",
        "ğ‘Œ" : "\u{1D51C}",
        "ğ‘¦" : "\u{1D536}",
        "ğ‘" : "\u2128",
        "ğ‘§" : "\u{1D537}",

        "ğ‘¨" : "\u{1D56C}",
        "ğ’‚" : "\u{1D586}",
        "ğ‘©" : "\u{1D56D}",
        "ğ’ƒ" : "\u{1D587}",
        "ğ‘ª" : "\u{1D56E}",
        "ğ’„" : "\u{1D588}",
        "ğ‘«" : "\u{1D56F}",
        "ğ’…" : "\u{1D589}",
        "ğ‘¬" : "\u{1D570}",
        "ğ’†" : "\u{1D58A}",
        "ğ‘­" : "\u{1D571}",
        "ğ’‡" : "\u{1D58B}",
        "ğ‘®" : "\u{1D572}",
        "ğ’ˆ" : "\u{1D58C}",
        "ğ‘¯" : "\u{1D573}",
        "ğ’‰" : "\u{1D58D}",
        "ğ‘°" : "\u{1D574}",
        "ğ’Š" : "\u{1D58E}",
        "ğ‘±" : "\u{1D575}",
        "ğ’‹" : "\u{1D58F}",
        "ğ‘²" : "\u{1D576}",
        "ğ’Œ" : "\u{1D590}",
        "ğ‘³" : "\u{1D577}",
        "ğ’" : "\u{1D591}",
        "ğ‘´" : "\u{1D578}",
        "ğ’" : "\u{1D592}",
        "ğ‘µ" : "\u{1D579}",
        "ğ’" : "\u{1D593}",
        "ğ‘¶" : "\u{1D57A}",
        "ğ’" : "\u{1D594}",
        "ğ‘·" : "\u{1D57B}",
        "ğ’‘" : "\u{1D595}",
        "ğ‘¸" : "\u{1D57C}",
        "ğ’’" : "\u{1D596}",
        "ğ‘¹" : "\u{1D57D}",
        "ğ’“" : "\u{1D597}",
        "ğ‘º" : "\u{1D57E}",
        "ğ’”" : "\u{1D598}",
        "ğ‘»" : "\u{1D57F}",
        "ğ’•" : "\u{1D599}",
        "ğ‘¼" : "\u{1D580}",
        "ğ’–" : "\u{1D59A}",
        "ğ‘½" : "\u{1D581}",
        "ğ’—" : "\u{1D59B}",
        "ğ‘¾" : "\u{1D582}",
        "ğ’˜" : "\u{1D59C}",
        "ğ‘¿" : "\u{1D583}",
        "ğ’™" : "\u{1D59D}",
        "ğ’€" : "\u{1D584}",
        "ğ’š" : "\u{1D59E}",
        "ğ’" : "\u{1D585}",
        "ğ’›" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : "\u2710",
        "\u2710\u2710" : "\u2710\u2710",
        "\u2710\u2710\u2710" : "\u2710\u2710\u2710",
        "\u2710\u2710\u2710\u2710" : "\u2710\u2710\u2710\u2710",
        "\u270E" : "\u270E",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const superscript = (arg, initialCommand, forFrac=false) => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg, Superscript, initialCommand, !forFrac);
    if ((output.indexOf(errSymbol) === -1) || (forFrac)) {
        return output;
    } else {
        return "^(" + arg.join("") + ")";
    };
};

const subscript = (arg, initialCommand, forFrac=false) => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg, Subscript, initialCommand, !forFrac);
    if ((output.indexOf(errSymbol) === -1) || (forFrac)) {
        return output;
    } else {
        return "_(" + arg.join("") + ")";
    };
};

const textbf = (arg, initialCommand) => {
    // textbf stands for text bold font
    // This function converts the list of characters to the corresponding (text) bold font character
	const symbols = {
        "A" : "\u{1D5D4}",
        "a" : "\u{1D5EE}",
        "B" : "\u{1D5D5}",
        "b" : "\u{1D5EF}",
        "C" : "\u{1D5D6}",
        "c" : "\u{1D5F0}",
        "D" : "\u{1D5D7}",
        "d" : "\u{1D5F1}",
        "E" : "\u{1D5D8}",
        "e" : "\u{1D5F2}",
        "F" : "\u{1D5D9}",
        "f" : "\u{1D5F3}",
        "G" : "\u{1D5DA}",
        "g" : "\u{1D5F4}",
        "H" : "\u{1D5DB}",
        "h" : "\u{1D5F5}",
        "I" : "\u{1D5DC}",
        "i" : "\u{1D5F6}",
        "J" : "\u{1D5DD}",
        "j" : "\u{1D5F7}",
        "K" : "\u{1D5DE}",
        "k" : "\u{1D5F8}",
        "L" : "\u{1D5DF}",
        "l" : "\u{1D5F9}",
        "M" : "\u{1D5E0}",
        "m" : "\u{1D5FA}",
        "N" : "\u{1D5E1}",
        "n" : "\u{1D5FB}",
        "O" : "\u{1D5E2}",
        "o" : "\u{1D5FC}",
        "P" : "\u{1D5E3}",
        "p" : "\u{1D5FD}",
        "Q" : "\u{1D5E4}",
        "q" : "\u{1D5FE}",
        "R" : "\u{1D5E5}",
        "r" : "\u{1D5FF}",
        "S" : "\u{1D5E6}",
        "s" : "\u{1D600}",
        "T" : "\u{1D5E7}",
        "t" : "\u{1D601}",
        "U" : "\u{1D5E8}",
        "u" : "\u{1D602}",
        "V" : "\u{1D5E9}",
        "v" : "\u{1D603}",
        "W" : "\u{1D5EA}",
        "w" : "\u{1D604}",
        "X" : "\u{1D5EB}",
        "x" : "\u{1D605}",
        "Y" : "\u{1D5EC}",
        "y" : "\u{1D606}",
        "Z" : "\u{1D5ED}",
        "z" : "\u{1D607}",

        "ğ´" : "\u{1D5D4}",
        "ğ‘" : "\u{1D5EE}",
        "ğµ" : "\u{1D5D5}",
        "ğ‘" : "\u{1D5EF}",
        "ğ¶" : "\u{1D5D6}",
        "ğ‘" : "\u{1D5F0}",
        "ğ·" : "\u{1D5D7}",
        "ğ‘‘" : "\u{1D5F1}",
        "ğ¸" : "\u{1D5D8}",
        "ğ‘’" : "\u{1D5F2}",
        "ğ¹" : "\u{1D5D9}",
        "ğ‘“" : "\u{1D5F3}",
        "ğº" : "\u{1D5DA}",
        "ğ‘”" : "\u{1D5F4}",
        "ğ»" : "\u{1D5DB}",
        "â„" : "\u{1D5F5}",
        "ğ¼" : "\u{1D5DC}",
        "ğ‘–" : "\u{1D5F6}",
        "ğ½" : "\u{1D5DD}",
        "ğ‘—" : "\u{1D5F7}",
        "ğ¾" : "\u{1D5DE}",
        "ğ‘˜" : "\u{1D5F8}",
        "ğ¿" : "\u{1D5DF}",
        "ğ‘™" : "\u{1D5F9}",
        "ğ‘€" : "\u{1D5E0}",
        "ğ‘š" : "\u{1D5FA}",
        "ğ‘" : "\u{1D5E1}",
        "ğ‘›" : "\u{1D5FB}",
        "ğ‘‚" : "\u{1D5E2}",
        "ğ‘œ" : "\u{1D5FC}",
        "ğ‘ƒ" : "\u{1D5E3}",
        "ğ‘" : "\u{1D5FD}",
        "ğ‘„" : "\u{1D5E4}",
        "ğ‘" : "\u{1D5FE}",
        "ğ‘…" : "\u{1D5E5}",
        "ğ‘Ÿ" : "\u{1D5FF}",
        "ğ‘†" : "\u{1D5E6}",
        "ğ‘ " : "\u{1D600}",
        "ğ‘‡" : "\u{1D5E7}",
        "ğ‘¡" : "\u{1D601}",
        "ğ‘ˆ" : "\u{1D5E8}",
        "ğ‘¢" : "\u{1D602}",
        "ğ‘‰" : "\u{1D5E9}",
        "ğ‘£" : "\u{1D603}",
        "ğ‘Š" : "\u{1D5EA}",
        "ğ‘¤" : "\u{1D604}",
        "ğ‘‹" : "\u{1D5EB}",
        "ğ‘¥" : "\u{1D605}",
        "ğ‘Œ" : "\u{1D5EC}",
        "ğ‘¦" : "\u{1D606}",
        "ğ‘" : "\u{1D5ED}",
        "ğ‘§" : "\u{1D607}",

        "ğ˜ˆ" : "\u{1D63C}",
        "ğ˜¢" : "\u{1D656}",
        "ğ˜‰" : "\u{1D63D}",
        "ğ˜£" : "\u{1D657}",
        "ğ˜Š" : "\u{1D63E}",
        "ğ˜¤" : "\u{1D658}",
        "ğ˜‹" : "\u{1D63F}",
        "ğ˜¥" : "\u{1D659}",
        "ğ˜Œ" : "\u{1D640}",
        "ğ˜¦" : "\u{1D65A}",
        "ğ˜" : "\u{1D641}",
        "ğ˜§" : "\u{1D65B}",
        "ğ˜" : "\u{1D642}",
        "ğ˜¨" : "\u{1D65C}",
        "ğ˜" : "\u{1D643}",
        "ğ˜©" : "\u{1D65D}",
        "ğ˜" : "\u{1D644}",
        "ğ˜ª" : "\u{1D65E}",
        "ğ˜‘" : "\u{1D645}",
        "ğ˜«" : "\u{1D65F}",
        "ğ˜’" : "\u{1D646}",
        "ğ˜¬" : "\u{1D660}",
        "ğ˜“" : "\u{1D647}",
        "ğ˜­" : "\u{1D661}",
        "ğ˜”" : "\u{1D648}",
        "ğ˜®" : "\u{1D662}",
        "ğ˜•" : "\u{1D649}",
        "ğ˜¯" : "\u{1D663}",
        "ğ˜–" : "\u{1D64A}",
        "ğ˜°" : "\u{1D664}",
        "ğ˜—" : "\u{1D64B}",
        "ğ˜±" : "\u{1D665}",
        "ğ˜˜" : "\u{1D64C}",
        "ğ˜²" : "\u{1D666}",
        "ğ˜™" : "\u{1D64D}",
        "ğ˜³" : "\u{1D667}",
        "ğ˜š" : "\u{1D64E}",
        "ğ˜´" : "\u{1D668}",
        "ğ˜›" : "\u{1D64F}",
        "ğ˜µ" : "\u{1D669}",
        "ğ˜œ" : "\u{1D650}",
        "ğ˜¶" : "\u{1D66A}",
        "ğ˜" : "\u{1D651}",
        "ğ˜·" : "\u{1D66B}",
        "ğ˜" : "\u{1D652}",
        "ğ˜¸" : "\u{1D66C}",
        "ğ˜Ÿ" : "\u{1D653}",
        "ğ˜¹" : "\u{1D66D}",
        "ğ˜ " : "\u{1D654}",
        "ğ˜º" : "\u{1D66E}",
        "ğ˜¡" : "\u{1D655}",
        "ğ˜»" : "\u{1D66F}",

        "0" : "\u{1D7EC}",
        "1" : "\u{1D7ED}",
        "2" : "\u{1D7EE}",
        "3" : "\u{1D7EF}",
        "4" : "\u{1D7F0}",
        "5" : "\u{1D7F1}",
        "6" : "\u{1D7F2}",
        "7" : "\u{1D7F3}",
        "8" : "\u{1D7F4}",
        "9" : "\u{1D7F5}",

        // These symbols don't exist in textbf, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
		" " : "\u2710"
	};
	return replaceLetters(arg, symbols, initialCommand);
};

const textit = (arg, initialCommand) => {
    // textit stands for text italic
    // This function converts the list of characters to the corresponding italic character
    const symbols = {
        "A" : "\u{1D608}",
        "a" : "\u{1D622}",
        "B" : "\u{1D609}",
        "b" : "\u{1D623}",
        "C" : "\u{1D60A}",
        "c" : "\u{1D624}",
        "D" : "\u{1D60B}",
        "d" : "\u{1D625}",
        "E" : "\u{1D60C}",
        "e" : "\u{1D626}",
        "F" : "\u{1D60D}",
        "f" : "\u{1D627}",
        "G" : "\u{1D60E}",
        "g" : "\u{1D628}",
        "H" : "\u{1D60F}",
        "h" : "\u{1D629}",
        "I" : "\u{1D610}",
        "i" : "\u{1D62A}",
        "J" : "\u{1D611}",
        "j" : "\u{1D62B}",
        "K" : "\u{1D612}",
        "k" : "\u{1D62C}",
        "L" : "\u{1D613}",
        "l" : "\u{1D62D}",
        "M" : "\u{1D614}",
        "m" : "\u{1D62E}",
        "N" : "\u{1D615}",
        "n" : "\u{1D62F}",
        "O" : "\u{1D616}",
        "o" : "\u{1D630}",
        "P" : "\u{1D617}",
        "p" : "\u{1D631}",
        "Q" : "\u{1D618}",
        "q" : "\u{1D632}",
        "R" : "\u{1D619}",
        "r" : "\u{1D633}",
        "S" : "\u{1D61A}",
        "s" : "\u{1D634}",
        "T" : "\u{1D61B}",
        "t" : "\u{1D635}",
        "U" : "\u{1D61C}",
        "u" : "\u{1D636}",
        "V" : "\u{1D61D}",
        "v" : "\u{1D637}",
        "W" : "\u{1D61E}",
        "w" : "\u{1D638}",
        "X" : "\u{1D61F}",
        "x" : "\u{1D639}",
        "Y" : "\u{1D620}",
        "y" : "\u{1D63A}",
        "Z" : "\u{1D621}",
        "z" : "\u{1D63B}",

        "ğ´" : "\u{1D608}",
        "ğ‘" : "\u{1D622}",
        "ğµ" : "\u{1D609}",
        "ğ‘" : "\u{1D623}",
        "ğ¶" : "\u{1D60A}",
        "ğ‘" : "\u{1D624}",
        "ğ·" : "\u{1D60B}",
        "ğ‘‘" : "\u{1D625}",
        "ğ¸" : "\u{1D60C}",
        "ğ‘’" : "\u{1D626}",
        "ğ¹" : "\u{1D60D}",
        "ğ‘“" : "\u{1D627}",
        "ğº" : "\u{1D60E}",
        "ğ‘”" : "\u{1D628}",
        "ğ»" : "\u{1D60F}",
        "â„" : "\u{1D629}",
        "ğ¼" : "\u{1D610}",
        "ğ‘–" : "\u{1D62A}",
        "ğ½" : "\u{1D611}",
        "ğ‘—" : "\u{1D62B}",
        "ğ¾" : "\u{1D612}",
        "ğ‘˜" : "\u{1D62C}",
        "ğ¿" : "\u{1D613}",
        "ğ‘™" : "\u{1D62D}",
        "ğ‘€" : "\u{1D614}",
        "ğ‘š" : "\u{1D62E}",
        "ğ‘" : "\u{1D615}",
        "ğ‘›" : "\u{1D62F}",
        "ğ‘‚" : "\u{1D616}",
        "ğ‘œ" : "\u{1D630}",
        "ğ‘ƒ" : "\u{1D617}",
        "ğ‘" : "\u{1D631}",
        "ğ‘„" : "\u{1D618}",
        "ğ‘" : "\u{1D632}",
        "ğ‘…" : "\u{1D619}",
        "ğ‘Ÿ" : "\u{1D633}",
        "ğ‘†" : "\u{1D61A}",
        "ğ‘ " : "\u{1D634}",
        "ğ‘‡" : "\u{1D61B}",
        "ğ‘¡" : "\u{1D635}",
        "ğ‘ˆ" : "\u{1D61C}",
        "ğ‘¢" : "\u{1D636}",
        "ğ‘‰" : "\u{1D61D}",
        "ğ‘£" : "\u{1D637}",
        "ğ‘Š" : "\u{1D61E}",
        "ğ‘¤" : "\u{1D638}",
        "ğ‘‹" : "\u{1D61F}",
        "ğ‘¥" : "\u{1D639}",
        "ğ‘Œ" : "\u{1D620}",
        "ğ‘¦" : "\u{1D63A}",
        "ğ‘" : "\u{1D621}",
        "ğ‘§" : "\u{1D63B}",

        "ğ—”" : "\u{1D63C}",
        "ğ—®" : "\u{1D656}",
        "ğ—•" : "\u{1D63D}",
        "ğ—¯" : "\u{1D657}",
        "ğ—–" : "\u{1D63E}",
        "ğ—°" : "\u{1D658}",
        "ğ——" : "\u{1D63F}",
        "ğ—±" : "\u{1D659}",
        "ğ—˜" : "\u{1D640}",
        "ğ—²" : "\u{1D65A}",
        "ğ—™" : "\u{1D641}",
        "ğ—³" : "\u{1D65B}",
        "ğ—š" : "\u{1D642}",
        "ğ—´" : "\u{1D65C}",
        "ğ—›" : "\u{1D643}",
        "ğ—µ" : "\u{1D65D}",
        "ğ—œ" : "\u{1D644}",
        "ğ—¶" : "\u{1D65E}",
        "ğ—" : "\u{1D645}",
        "ğ—·" : "\u{1D65F}",
        "ğ—" : "\u{1D646}",
        "ğ—¸" : "\u{1D660}",
        "ğ—Ÿ" : "\u{1D647}",
        "ğ—¹" : "\u{1D661}",
        "ğ— " : "\u{1D648}",
        "ğ—º" : "\u{1D662}",
        "ğ—¡" : "\u{1D649}",
        "ğ—»" : "\u{1D663}",
        "ğ—¢" : "\u{1D64A}",
        "ğ—¼" : "\u{1D664}",
        "ğ—£" : "\u{1D64B}",
        "ğ—½" : "\u{1D665}",
        "ğ—¤" : "\u{1D64C}",
        "ğ—¾" : "\u{1D666}",
        "ğ—¥" : "\u{1D64D}",
        "ğ—¿" : "\u{1D667}",
        "ğ—¦" : "\u{1D64E}",
        "ğ˜€" : "\u{1D668}",
        "ğ—§" : "\u{1D64F}",
        "ğ˜" : "\u{1D669}",
        "ğ—¨" : "\u{1D650}",
        "ğ˜‚" : "\u{1D66A}",
        "ğ—©" : "\u{1D651}",
        "ğ˜ƒ" : "\u{1D66B}",
        "ğ—ª" : "\u{1D652}",
        "ğ˜„" : "\u{1D66C}",
        "ğ—«" : "\u{1D653}",
        "ğ˜…" : "\u{1D66D}",
        "ğ—¬" : "\u{1D654}",
        "ğ˜†" : "\u{1D66E}",
        "ğ—­" : "\u{1D655}",
        "ğ˜‡" : "\u{1D66F}",

        "ğŸ¬" : "ğŸ¬",
        "ğŸ­" : "ğŸ­",
        "ğŸ®" : "ğŸ®",
        "ğŸ¯" : "ğŸ¯",
        "ğŸ°" : "ğŸ°",
        "ğŸ±" : "ğŸ±",
        "ğŸ²" : "ğŸ²",
        "ğŸ³" : "ğŸ³",
        "ğŸ´" : "ğŸ´",
        "ğŸµ" : "ğŸµ",

        // These symbols don't exist in textit, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",
        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
        " " : "\u2710"
	};
	return replaceLetters(arg, symbols, initialCommand);
};

const texttt = (arg, initialCommand) => {
    // texttt stands for text typewriter
    // This function converts the list of characters to the corresponding typewriter character
    const symbols = {
        "A" : "\u{1D670}",
        "a" : "\u{1D68A}",
        "B" : "\u{1D671}",
        "b" : "\u{1D68B}",
        "C" : "\u{1D672}",
        "c" : "\u{1D68C}",
        "D" : "\u{1D673}",
        "d" : "\u{1D68D}",
        "E" : "\u{1D674}",
        "e" : "\u{1D68E}",
        "F" : "\u{1D675}",
        "f" : "\u{1D68F}",
        "G" : "\u{1D676}",
        "g" : "\u{1D690}",
        "H" : "\u{1D677}",
        "h" : "\u{1D691}",
        "I" : "\u{1D678}",
        "i" : "\u{1D692}",
        "J" : "\u{1D679}",
        "j" : "\u{1D693}",
        "K" : "\u{1D67A}",
        "k" : "\u{1D694}",
        "L" : "\u{1D67B}",
        "l" : "\u{1D695}",
        "M" : "\u{1D67C}",
        "m" : "\u{1D696}",
        "N" : "\u{1D67D}",
        "n" : "\u{1D697}",
        "O" : "\u{1D67E}",
        "o" : "\u{1D698}",
        "P" : "\u{1D67F}",
        "p" : "\u{1D699}",
        "Q" : "\u{1D680}",
        "q" : "\u{1D69A}",
        "R" : "\u{1D681}",
        "r" : "\u{1D69B}",
        "S" : "\u{1D682}",
        "s" : "\u{1D69C}",
        "T" : "\u{1D683}",
        "t" : "\u{1D69D}",
        "U" : "\u{1D684}",
        "u" : "\u{1D69E}",
        "V" : "\u{1D685}",
        "v" : "\u{1D69F}",
        "W" : "\u{1D686}",
        "w" : "\u{1D6A0}",
        "X" : "\u{1D687}",
        "x" : "\u{1D6A1}",
        "Y" : "\u{1D688}",
        "y" : "\u{1D6A2}",
        "Z" : "\u{1D689}",
        "z" : "\u{1D6A3}",

        "ğ´" : "\u{1D670}",
        "ğ‘" : "\u{1D68A}",
        "ğµ" : "\u{1D671}",
        "ğ‘" : "\u{1D68B}",
        "ğ¶" : "\u{1D672}",
        "ğ‘" : "\u{1D68C}",
        "ğ·" : "\u{1D673}",
        "ğ‘‘" : "\u{1D68D}",
        "ğ¸" : "\u{1D674}",
        "ğ‘’" : "\u{1D68E}",
        "ğ¹" : "\u{1D675}",
        "ğ‘“" : "\u{1D68F}",
        "ğº" : "\u{1D676}",
        "ğ‘”" : "\u{1D690}",
        "ğ»" : "\u{1D677}",
        "â„" : "\u{1D691}",
        "ğ¼" : "\u{1D678}",
        "ğ‘–" : "\u{1D692}",
        "ğ½" : "\u{1D679}",
        "ğ‘—" : "\u{1D693}",
        "ğ¾" : "\u{1D67A}",
        "ğ‘˜" : "\u{1D694}",
        "ğ¿" : "\u{1D67B}",
        "ğ‘™" : "\u{1D695}",
        "ğ‘€" : "\u{1D67C}",
        "ğ‘š" : "\u{1D696}",
        "ğ‘" : "\u{1D67D}",
        "ğ‘›" : "\u{1D697}",
        "ğ‘‚" : "\u{1D67E}",
        "ğ‘œ" : "\u{1D698}",
        "ğ‘ƒ" : "\u{1D67F}",
        "ğ‘" : "\u{1D699}",
        "ğ‘„" : "\u{1D680}",
        "ğ‘" : "\u{1D69A}",
        "ğ‘…" : "\u{1D681}",
        "ğ‘Ÿ" : "\u{1D69B}",
        "ğ‘†" : "\u{1D682}",
        "ğ‘ " : "\u{1D69C}",
        "ğ‘‡" : "\u{1D683}",
        "ğ‘¡" : "\u{1D69D}",
        "ğ‘ˆ" : "\u{1D684}",
        "ğ‘¢" : "\u{1D69E}",
        "ğ‘‰" : "\u{1D685}",
        "ğ‘£" : "\u{1D69F}",
        "ğ‘Š" : "\u{1D686}",
        "ğ‘¤" : "\u{1D6A0}",
        "ğ‘‹" : "\u{1D687}",
        "ğ‘¥" : "\u{1D6A1}",
        "ğ‘Œ" : "\u{1D688}",
        "ğ‘¦" : "\u{1D6A2}",
        "ğ‘" : "\u{1D689}",
        "ğ‘§" : "\u{1D6A3}",

        "0" : "\u{1D7F6}",
        "1" : "\u{1D7F7}",
        "2" : "\u{1D7F8}",
        "3" : "\u{1D7F9}",
        "4" : "\u{1D7FA}",
        "5" : "\u{1D7FB}",
        "6" : "\u{1D7FC}",
        "7" : "\u{1D7FD}",
        "8" : "\u{1D7FE}",
        "9" : "\u{1D7FF}",

        // These symbols don't exist in texttt, but don't output errors
        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
        " " : "\u2710"
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const text = (arg, initialCommand) => {
    // This function doesn't change the output (i.e. "abc" -> "abc")
    const symbols = {
        "A" : "A",
        "Ã€" : "Ã€",
        "Ã " : "Ã ",
        "a" : "a",
        "B" : "B",
        "b" : "b",
        "C" : "C",
        "Ã‡" : "Ã‡",
        "c" : "c",
        "Ã§" : "Ã§",
        "D" : "D",
        "d" : "d",
        "E" : "E",
        "Ã‰" : "Ã‰",
        "Ãˆ" : "Ãˆ",
        "ÃŠ" : "ÃŠ",
        "Ã‹" : "Ã‹",
        "e" : "e",
        "Ã©" : "Ã©",
        "Ã¨" : "Ã¨",
        "Ãª" : "Ãª",
        "Ã«" : "Ã«",
        "F" : "F",
        "f" : "f",
        "G" : "G",
        "g" : "g",
        "H" : "H",
        "h" : "h",
        "I" : "I",
        "i" : "i",
        "J" : "J",
        "j" : "j",
        "K" : "K",
        "k" : "k",
        "L" : "L",
        "l" : "l",
        "M" : "M",
        "m" : "m",
        "N" : "N",
        "n" : "n",
        "O" : "O",
        "Ã”" : "Ã”",
        "o" : "o",
        "Ã´" : "Ã´",
        "P" : "P",
        "p" : "p",
        "Q" : "Q",
        "q" : "q",
        "R" : "R",
        "r" : "r",
        "S" : "S",
        "s" : "s",
        "T" : "T",
        "t" : "t",
        "U" : "U",
        "u" : "u",
        "Ã™" : "Ã™",
        "Ã¹" : "Ã¹",
        "V" : "V",
        "v" : "v",
        "W" : "W",
        "w" : "w",
        "X" : "X",
        "x" : "x",
        "Y" : "Y",
        "y" : "y",
        "Z" : "Z",
        "z" : "z",

        "ğ´" : "A",
        "ğ´Ì€" : "Ã€",
        "ğ‘" : "a",
        "ğ‘Ì€" : "Ã ",
        "ğµ" : "B",
        "ğ‘" : "b",
        "ğ¶" : "C",
        "ğ‘" : "c",
        "ğ·" : "D",
        "ğ‘‘" : "d",
        "ğ¸" : "E",
        "ğ¸Ì€" : "Ãˆ",
        "ğ¸Ìˆ" : "Ã‹",
        "ğ¸Ì" : "Ã‰",
        "ğ¸Ì‚" : "ÃŠ",
        "ğ‘’Ì‚" : "Ãª",
        "ğ‘’Ì" : "Ã©",
        "ğ‘’Ìˆ" : "Ã«",
        "ğ‘’Ì€" : "Ã¨",
        "ğ‘’" : "e",
        "ğ¹" : "F",
        "ğ‘“" : "f",
        "ğº" : "G",
        "ğ‘”" : "g",
        "ğ»" : "H",
        "â„" : "h",
        "ğ¼" : "I",
        "ğ‘–" : "i",
        "ğ½" : "J",
        "ğ‘—" : "j",
        "ğ¾" : "K",
        "ğ‘˜" : "k",
        "ğ¿" : "L",
        "ğ‘™" : "l",
        "ğ‘€" : "M",
        "ğ‘š" : "m",
        "ğ‘" : "N",
        "ğ‘›" : "n",
        "ğ‘‚" : "O",
        "ğ‘œ" : "o",
        "ğ‘ƒ" : "P",
        "ğ‘" : "p",
        "ğ‘„" : "Q",
        "ğ‘" : "q",
        "ğ‘…" : "R",
        "ğ‘Ÿ" : "r",
        "ğ‘†" : "S",
        "ğ‘ " : "s",
        "ğ‘‡" : "T",
        "ğ‘¡" : "t",
        "ğ‘ˆ" : "U",
        "ğ‘¢" : "u",
        "ğ‘¢Ì€" : "Ã¹",
        "ğ‘‰" : "V",
        "ğ‘£" : "v",
        "ğ‘Š" : "W",
        "ğ‘¤" : "w",
        "ğ‘‹" : "X",
        "ğ‘¥" : "x",
        "ğ‘Œ" : "Y",
        "ğ‘¦" : "y",
        "ğ‘" : "Z",
        "ğ‘§" : "z",

        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : "\u2710",
        "\u270E" : "\u270E",
        " " : "\u2710"
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const hspace = (arg, initialCommand) => {
    // hspace stands for horizontal space
    // Adds the number of space specified in 'arg'
    let spaces = "";
    const num = arg.join("");
    if (num * 0 !== 0) {
        spaces = mistakes(initialCommand + "{" + num + "}", undefined, "Argument must be a number");
    } else {
        for (let i=0; i<parseInt(num); i++) {
            spaces += "\u2710";
        };
    };
    return spaces;
};

const vskip = (arg, initialCommand) => {
    // vskip stands for vertical skip
    // Adds the number of linebreaks specified in 'arg'
    let skips = "";
    const num = arg.join("");
    if (num * 0 !== 0) {
        skips = mistakes(initialCommand + "{" + num + "}", undefined, "Argument must be a number");
    } else {
        for (let i=0; i<parseInt(num); i++) {
            skips += "\u000A";
        };
    };
    return skips;
};

const phantom = (arg, initialCommand) => {
    let spaces = "";
    for (let i=0; i<arg.length; i++) {
        spaces += "\u2710";
    };
    if (arg.includes(errSymbol)) {
        mistakes(initialCommand + "{" + arg.join("") + "}", undefined, "Undefined argument");
    };
    return spaces;
};

const sqrt = (arg, initialCommand) => {
    // sqrt stands for square root
    const numStart = parseInt(initialCommand.indexOf("["));
    const numEnd = parseInt(initialCommand.indexOf("]"));
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]{x}", undefined, "â¿âˆšğ‘¥");
            return addSymbol(undefined);
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output = "";
    switch (rootNum) {
        // There's already a unicode symbol for square root, cube root and 4th root
        // If rootNum is different than those, the symbol is built
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(mathDictionary["^"](rootNum.toString().split(""), initialCommand)) + "\u221A";
    };
    if (arg.length >= 2) {
        output += "(" + addSymbolArray(arg, initialCommand + "{" + arg.join("") + "}") + ")";
    } else {
        output += addSymbolArray(arg, initialCommand + "{" + arg.join("") + "}");
    };
    return output;
};


const sqrtNoArg = (arg, initialCommand) => {
    // Compared with sqrt, this function only takes the root as parameter, not the argument
    // For instance the 'cube root of two' would be in sqrt, but simply the 'cube root' would be parsed here 
    if (arg !== undefined) {
        mistakes(initialCommand + " does not take in arguments and should take the form \\sqrt[n]*", undefined, "â¿âˆš  (use \\sqrt[n]{x} to get â¿âˆšğ‘¥)");
        return addSymbol(undefined);
    };
    const numStart = parseInt(initialCommand.indexOf("["));
    const numEnd = parseInt(initialCommand.indexOf("]"));
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]*", undefined, "â¿âˆš");
            return addSymbol(undefined);
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output = "";
    switch (rootNum) {
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(mathDictionary["^"](rootNum.toString().split(""), initialCommand)) + "\u221A";
    };
    return output;
};

const frac = (arg, initialCommand) => {
    // Used to make a fraction
    // If a character doesn't exist in superscript or subscript, it outputs the fraction in the format f(x)/g(x)
    let output = "";
    let nume = [];
    let deno = [];
    let numerator = true;
    for (let i in arg) {
        if (numerator) {
            if (arg[i] === "}") {
                numerator = false;
            } else {
                nume.push(arg[i]);
            };
        } else {
            if (arg[i] === "{") {
                if (arg[i - 1] === "}") {
                    output += addSymbol(mathDictionary["^"](nume, initialCommand, true)) + "\u2215";
                } else {
                    deno.push(arg[i]);
                };
            } else {
                deno.push(arg[i]);
            };
        };
    };
    output += addSymbol(mathDictionary["_"](deno, initialCommand, true));
    if (output.indexOf(errSymbol) === -1) {
        return output;
    } else {
        if (arg.join("").includes("\u2710")) {
            const spaces = arg.filter(c => {return c.includes("\u2710")});
            for (let i in spaces) {
                mistakes(initialCommand + "{" + arg.join("") + "}", undefined, spaces[i]);
            };
        };
        output = "";
        numerator = true;
        nume = [];
        deno = [];
        for (let i in arg) {
            if (numerator) {
                if (arg[i] === "}") {
                    numerator = false;
                } else {
                    nume.push(arg[i]);
                };
            } else {
                if (arg[i] === "{") {
                    if (arg[i - 1] === "}") {
                        output += "(" + addSymbolArray(nume, "\\frac{" + arg.join("") + "}") + "/";
                    } else {
                        deno.push(arg[i]);
                    };
                } else {
                    deno.push(arg[i]);
                };
            };
        };
        output += addSymbolArray(deno, "\\frac{" + arg.join("") + "}") + ")";
        return output;
    };
};

const singleCharFrac = (arg, initialCommand) => {
    // Some fractions already exists as unicode symbols they can be accessed via this function
    let noSpaceArg = arg.join("").replace(/ /g, "");
    const fractions = {
        "1}{2" : "\u00BD",
        "1}{7" : "â…",
        "1}{9" : "â…‘",
        "1}{10" : "â…’",
        "1}{3"  :"â…“",
        "2}{3" : "â…”",
        "1}{5" : "â…•",
        "2}{5" : "â…–",
        "3}{5" : "â…—",
        "4}{5" : "â…˜",
        "1}{6" : "â…™",
        "5}{6" : "â…š",
        "1}{8" : "â…›",
        "3}{8" : "â…œ",
        "5}{8" : "â…",
        "7}{8" : "â…",
        "a}{c" : "\u2100",
        "a}{s" : "\u2101",
        "c}{o" : "\u2105",
        "c}{u" : "\u2106"
    };
    let output = fractions[noSpaceArg];
    return (output !== undefined) ? output : frac(arg, initialCommand);
};

const pmod = (arg, initialCommand) => {
    // returns ' (mod arg)'
    return "\u2710(mod\u2710" + arg.join("") + ")";
};

// These functions call combineSymbols with a predetermined symbol

const overline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0305")};

const underline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0332")};

const vec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D7")};

const hvec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D1")};

const overfrown = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0361", "\u0361")};

const oversmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035D", "\u035D")};

const undersmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035C", "\u035C")};

const hat = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0302")};

const not = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0338")};

const tilde = (arg, initialCommand) => {if ((arg == "\u27F6") ||Â (arg == "\u2192")) {return ["\u2972"]} else {return combineSymbols(arg, initialCommand, "\u0303", "\u0360")}};

const dot = (arg, initialCommand) => {if ((arg == "=") || (arg == "\u003D")) {return ["\u2250"]} else if (arg == "\u2261") {return ["\u2A67"]} else {return combineSymbols(arg, initialCommand, "\u0307")}};

const ddot = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0308")};

const underarrow = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0362", "\u0362")};

const underharpoon = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20EC")};

const acute = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0301")};

const grave = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0300")};

const bar = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0304")};

const breve = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0306")};

const caron = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030C")};

const doubleAccute = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030B")};

const ringAbove = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030A")};

const cedilla = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0327")};

const dotBelow = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0323")};

const ogonek = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0328")};

const above = (arg, initialCommand) => {
    // Returns the symbol to be put above the preceding character in the input text
    if (arg.length > 1) {
        return mistakes(initialCommand + "{" + arg.join("") + "}", undefined, "Only one argument accepted");
    };
    mistakes(initialCommand + "{" + arg.join("") + "}", Above[arg[0]], (arg[0] !== undefined) ? arg[0] : "Argument doesn't exist");
    return Above[arg[0]];
};

const below = (arg, initialCommand) => {
    // Returns the symbol to be put below the preceding character in the input text
    if (arg.length > 1) {
        return mistakes(initialCommand + "{" + arg.join("") + "}", undefined, "Only one argument accepted");
    };
    mistakes(initialCommand + "{" + arg.join("") + "}", Below[arg[0]], (arg[0] !== undefined) ? arg[0] : "Argument doesn't exist");
    return Below[arg[0]];
};


//-----------------------------------------------------//


/** Dictionaries **/

// mathDictionary is the main dict for converting commands into symbols
const mathDictionary = {
    // Math operators
    "\\times" : "\u00D7",
    "\\rtimes" : "\u22CA",
    "\\ltimes" : "\u22C9",
    "\\div" : "\u00F7",
    "\\longdiv" : "\u27CC",
    "\\int" : "\u222B",
    "\\iint" : "\u222C",
    "\\iiint" : "\u222D",
    "\\iiiint" : "\u2A0C",
    "\\oint" : "\u222E",
    "\\oiint" : "\u222F",
    "\\oiiint" : "\u2230",
    "\\intclockwise" : "\u2231",
    "\\ointclockwise" : "\u2232",
    "\\ointctrclockwise" : "\u2233",
    "\\sqint" : "\u2A16",
    "\\fint" : "\u2A0F",
    "\\cupint" : "\u2A1A",
    "\\capint" : "\u2A19",
    "\\overbarint" : "\u2A1B",
    "\\underbarint" : "\u2A1C",
    "\\cupplus" : "\u228E",
    "\\timesint" : "\u2A18",
    "\\ast" : "\u2217",
    "\\star" : "\u22C6",
    "\\partial" : "\u2202",
    "\\nabla" : "\u2207",
    "\\sqrt2" : "\u221A",
    "\\sqrt3" : "\u221B",
    "\\sqrt4" : "\u221C",
    "\\circ" : "\u2218",
    "\\sum" : "\u2211",
    "\\osum" : "\u2A0A",
    "\\sumint" : "\u2A0B",
    "\\prod" : "\u220F",
    "\\cdot" : "\u00B7",
    "\\cdotp" : "\u22C5",
    "\\pm" : "\u00B1",
    "\\mp" : "\u2213",
    "\\emptyset" : "\u2205",
    "\\sin" : "sin",
    "\\cos" : "cos",
    "\\tan" : "tan",
    "\\arcsin" : "arcsin",
    "\\arccos" : "arccos",
    "\\arctan" : "arctan",
    "\\cot" : "cot",
    "\\csc" : "csc",
    "\\sec" : "sec",
    "\\arccot" : "arccot",
    "\\arccsc" : "arccsc",
    "\\arcsec" : "arcsec",
    "\\*" : "*",
    "\\det" : "det",
    "\\rank" : "rank",
    "\\log" : "log",
    "\\ln" : "ln",
    "\\lim" : "lim",
    "\\mod" : "\u2710\u2710mod\u2710",  // 2 spaces + 'mod' + 1 space
    "\\bmod" : "\u2710mod\u2710",  // 1 space + 'mod' + 1 space
    "\\pmod" : pmod,  // 1 space + '(mod' + 1 space + arg + ')'
    "\\cup" : "\u222A",
    "\\Cup" : "\u22D3",
    "\\sqcup" : "\u2294",
    "\\sqCup" : "\u2A4F",
    "\\cap" : "\u2229",
    "\\Cap" : "\u22D2",
    "\\sqcap" : "\u2293",
    "\\sqCap" : "\u2A4E",
    "\\uplus" : "\u228E",
    "\\def" : "\u225D",
    "\\coloneqq" : "\u2254",
    "\\eqqcolon" : "\u2255",
    "\\vee" : "\u2228",
    "\\doublevee" : "\u2A56",
    "\\wedge" : "\u2227",
    "\\doublewedge" : "\u2A55",
    "\\curlyvee" : "\u22CE",
    "\\curlywedge" : "\u22CF",
    "\\diamond" : "\u22C4",
    "\\wr" : "\u2240",
    "\\oplus" : "\u2295",
    "\\ominus" : "\u2296",
    "\\otimes" : "\u2297",
    "\\oslash" : "\u2298",
    "\\odot" : "\u2299",
    "\\obullet" : "\u29BF",
    "\\ocirc" : "\u29BE",
    "\\operp" : "\u29B9",
    "\\oparallel" : "\u29B7",
    "\\oast" : "\u229B",
    "\\oeq" : "\u229C",
    "\\opluslhrim" : "\u2A2D",
    "\\oplusrhrim" : "\u2A2E",
    "\\otimeslhrim" : "\u2A34",
    "\\otimesrhrim" : "\u2A35",
    "\\boxplus" : "\u229E",
    "\\boxminus" : "\u229F",
    "\\boxtimes" : "\u22A0",
    "\\boxdot" : "\u22A1",
    "\\amalg" : "\u2210",
    "\\tprime" : "\u2034",
    "\\lthree" : "\u22CB",
    "\\rthree" : "\u22CC",
    "\\pitchfork" : "\u22D4",
    "\\topfork" : "\u2ADA",
    "\\invamp" : "\u214B",
    "\\originalof" : "\u22B6",
    "\\imageof" : "\u22B7",
    "\\multimap" : "\u22B8",
    "\\leftmultimap" : "\u27DC",
    "\\uptack" : "\u27DF",
    "\\xor" : "\u22BB",
    "\\nand" : "\u22BC",
    "\\nor" : "\u22BD",
    "\\divideontimes" : "\u22C7",
    "\\smashtimes" : "\u2A33",
    "\\fracline" : "\u2215",  // Better suited for superscript over subscript

    // Relations
    "\\forall" : "\u2200",
    "\\exists" : "\u2203",
    "\\nexists" : "\u2204",
    "\\land" : "\u2227",
    "\\lor" : "\u2228",
    "\\sqland" : "\u27CE",
    "\\sqlor" : "\u27CF",
    "\\in" : "\u2208",
    "\\notin" : "\u2209",
    "\\ni" : "\u220B",
    "\\subset" : "\u2282",
    "\\nsubset" : "\u2284",
    "\\subseteq" : "\u2286",
    "\\nsubseteq" : "\u2288",
    "\\supset" : "\u2283",
    "\\nsupset" : "\u2285",
    "\\supseteq" : "\u2287",
    "\\nsupseteq" : "\u2289",
    "\\sqsubset" : "\u228F",
    "\\sqsupset" : "\u2290",
    "\\sqsubseteq" : "\u2291",
    "\\sqsupseteq" : "\u2292",
    "\\Subset" : "\u22D0",
    "\\Supset" : "\u22D1",
    "\\subsetplus" : "\u2ABF",
    "\\supsetplus" : "\u2AC0",
    "\\osubset" : "\u27C3",
    "\\osupset" : "\u27C4",
    "\\setminus" : "\u2216",
    "\\cong" : "\u2245",
    "\\ncong" : "\u2247",
    "\\propto" : "\u221D",
    "\\equiv" : "\u2261",
    "\\dotequiv" : "\u2A67",
    "\\superequiv" : "\u2263",
    "\\tbond" : "\u2261",
    "\\qbond" : "\u2263",
    "\\doteq" : "\u2250",
    "\\eqdot" : "\u2A66",
    "\\neq" : "\u2260",
    "\\approx" : "\u2248",
    "\\sim" : "\u223C",
    "\\simeq" : "\u224C",
    "\\nsim" : "\u2241",
    "\\nless" : "\u226E",
    "\\ngtr" : "\u226F",
    "\\leq" : "\u2264",
    "\\leqslant" : "\u2A7D",
    "\\geq" : "\u2265",
    "\\geqslant" : "\u2A7E",
    "\\nleq" : "\u2270",
    "\\ngeq" : "\u2271",
    "\\lneq" : "\u2A87",
    "\\lneqq" : "\u2268",
    "\\gneq" : "\u2A88",
    "\\gneqq" : "\u2269",
    "\\lnapprox" : "\u2A89",
    "\\gnapprox" : "\u2A8A",
    "\\lnsim" : "\u22E6",
    "\\gnsim" : "\u22E7",
    "\\ll" : "\u226A",
    "\\lll" : "\u22D8",
    "\\gg" : "\u226B",
    "\\ggg" : "\u22D9",
    "\\prec" : "\u227A",
    "\\succ" : "\u227B",
    "\\nprec" : "\u2280",
    "\\nsucc" : "\u2281",
    "\\preceq" : "\u227C",
    "\\succeq" : "\u227D",
    "\\precneqq" : "\u2AB5",
    "\\succneqq" : "\u2AB6",
    "\\precnapprox" : "\u2AB9",
    "\\succnapprox" : "\u2ABA",
    "\\precnsim" : "\u22E8",
    "\\succnsim" : "\u22E9",
    "\\perp" : "\u27C2",
    "\\Perp" : "\u2AEB",
    "\\parallel" : "\u2225",
    "\\nparallel" : "\u2226",
    "\\vvvert" : "\u2AF4",
    "\\nvvvert" : "\u2AF5",
    "\\mid" : "|",
    "\\nmid" : "\u2224",
    "\\asymp" : "\u224D",
    "\\neg" : "\u00AC",
    "\\bowtie" : "\u2A1D",
    "\\vdash" : "\u22A2",
    "\\nvdash" : "\u22AC",
    "\\dashv" : "\u22A3",
    "\\vDash" : "\u22A8",
    "\\Dashv" : "\u2AE4",
    "\\nvDash" : "\u22AD",
    "\\Vdash" : "\u22A9",
    "\\dashV" : "\u2AE3",
    "\\nVdash" : "\u22AE",
    "\\VDash" : "\u22AB",
    "\\DashV" : "\u2AE5",
    "\\nVDash" : "\u22AF",
    "\\triangleleft" : "\u22B2",
    "\\ntriangleleft" : "\u22EA",
    "\\triangleright" : "\u22B3",
    "\\ntriangleright" : "\u22EB",
    "\\ntrianglelefteq" : "\u22EC",
    "\\ntrianglerighteq" : "\u22ED",
    "\\trianglelefteq" : "\u22B4",
    "\\trianglerighteq" : "\u22B5",
    "\\triangleq" : "\u225C",
    "\\equest" : "\u225F",
    "\\lquest" : "\u2A7B",
    "\\rquest" : "\u2A7C",
    "\\mquest" : "\u225E",
    "\\vdots" : "\u22EE",
    "\\cdots" : "\u22EF",
    "\\udots" : "\u22F0",
    "\\ddots" : "\u22F1",
    "\\ldots" : "\u2026",
    "\\top" : "\u22A4",
    "\\bot" : "\u22A5",
    "\\between" : "\u226C",
    "\\therefore" : "\u2234",
    "\\because" : "\u2235",
    "\\squaredots" : "\u2237",
    "\\dotminus" : "\u2238",
    "\\max" : "max",
    "\\min" : "min",
    "\\grad" : "grad",
    "\\curl" : "curl",
    "\\ratio" : "\u2236",  // Same as ":", except with "!chem"

    // Arrows
    "\\Rightarrow" : "\u21D2",
    "\\Leftarrow" : "\u21D0",
    "\\nLeftarrow" : "\u21CD",
    "\\nRightarrow" : "\u21CF",
    "\\nLeftrightarrow" : "\u21CE",
    "\\Uparrow" : "\u21D1",
    "\\Downarrow" : "\u21D3",
    "\\Updownarrow" : "\u21D5",
    "\\rightarrow" : "\u2192",
    "\\longrightarrow" : "\u27F6",
    "\\leftarrow" : "\u2190",
    "\\longleftarrow" : "\u27F5",
    "\\leftrightarrow" : "\u2194",
    "\\nleftrightarrow" : "\u21AE",
    "\\uparrow" : "\u2191",
    "\\downarrow" : "\u2193",
    "\\updownarrow" : "\u2195",
    "\\nleftarrow" : "\u219A",
    "\\nrightarrow" : "\u219B",
    "\\Longleftarrow" : "\u27F8",
    "\\implies" : "\u27F9",
    "\\Longrightarrow" : "\u27F9",
    "\\Leftrightarrow" : "\u21D4",
    "\\iff" : "\u27FA",
    "\\mapsto" : "\u27FC",
    "\\rightleftharpoons" : "\u21CC",
    "\\leftrightharpoons" : "\u21CB",
    "\\rightharpoonup" : "\u21C0",
    "\\rightharpoondown" : "\u21C1",
    "\\leftharpoonup" : "\u21BC",
    "\\leftharpoondown" : "\u21BD",
    "\\upharpoonleft" : "\u21BF",
    "\\upharpoonright" : "\u21BE",
    "\\downharpoonleft" : "\u21C3",
    "\\downharpoonright" : "\u21C2", 
    "\\hookleftarrow" : "\u21A9",
    "\\hookrightarrow" : "\u21AA",
    "\\nearrow" : "\u2197",
    "\\searrow" : "\u2198",
    "\\swarrow" : "\u2199",
    "\\nwarrow" : "\u2196",
    "\\Nearrow" : "\u21D7",
    "\\Searrow" : "\u21D8",
    "\\Swarrow" : "\u21D9",
    "\\Nwarrow" : "\u21D6",
    "\\twoheadleftarrow" : "\u219E",
    "\\twoheadrightarrow" : "\u21A0",
    "\\twoheaduparrow" : "\u219F",
    "\\twoheaddownarrow" : "\u21A1",
    "\\Lsh" : "\u21B0",
    "\\Rsh" : "\u21B1",
    "\\leftleftarrows" : "\u21C7",
    "\\rightrightarrows" : "\u21C9",
    "\\rightrightrightarrows" : "\u21F6",
    "\\upuparrows" : "\u21C8",
    "\\downdownarrows" : "\u21CA",
    "\\leftrightarrows" : "\u21C6",
    "\\rightleftarrows" : "\u21C4",
    "\\Lleftarrow" : "\u21DA",
    "\\Rrightarrow" : "\u21DB",
    "\\Uuparrow" : "\u290A",
    "\\Ddownarrow" : "\u290B",
    "\\leftarrowtail" : "\u21A2",
    "\\rightarrowtail" : "\u21A3",
    "\\leftsquigarrow" : "\u21DC",
    "\\rightsquigarrow" : "\u21DD",
    "\\leftrightsquigarrow" : "\u21AD",
    "\\longrightsquiglearrow" : "\u27FF",
    "\\looparrowleft" : "\u21AB",
    "\\looparrowright" : "\u21AC",
    "\\circlearrowleft" : "\u21BA",
    "\\circlearrowright" : "\u21BB",
    "\\curvearrowleft" : "\u21B6",
    "\\curvearrowright" : "\u21B7",
    "\\leftdasharrow" : "\u21E0",
    "\\rightdasharrow" : "\u21E2",
    "\\updasharrow" : "\u21E1",
    "\\downdasharrow" : "\u21E3",
    "\\tildeabovearrow" : "\u2972",
    "\\tildebelowarrow" : "\u2974",
    "\\equalabovearrow" : "\u2971",

    // Hebrew alphabet
    "\\aleph" : "\u2135",
    "\\beth" : "\u2136",
    "\\gimel" : "\u2137",
    "\\dalet" : "\u2138",

    // Convert text
    "\\mathbb" : mathbb,
    "\\mathbf" : mathbf,
    "\\mathcal" : mathcal,
    "\\mathfrak" : mathfrak,
    "^" : superscript,
    "_" : subscript,
    "\\mathrm" : text,
    "\\text" : text,
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,

    // Spaces
    "\\hspace" : hspace,
    "\\vskip" : vskip,
    "\\phantom" : phantom,

    // Square root and fractions
    "\\sqrt" : sqrt,
    "\\sqrt*" : sqrtNoArg,
    "\\frac" : frac,
    "\\frac*" : singleCharFrac,

    // Combining symbols
    "\\overline" : overline,
    "\\underline" : underline,
    "\\underarrow" : underarrow,
    "\\underharpoon" : underharpoon,
    "\\overfrown" : overfrown,
    "\\oversmile" : oversmile,
    "\\undersmile" : undersmile,
    "\\hat" : hat,
    "\\not" : not,
    "\\tilde" : tilde,
    "\\vec" : vec,
    "\\hvec" : hvec,
    "\\dot" : dot,
    "\\ddot" : ddot,
    "\\acute" : acute,
    "\\grave" : grave,
    "\\above" : above,
    "\\below" : below,
    "\\check" : caron,
    "\\breve" : breve,
    "\\bar" : bar,

    // For Lewis Notation
    "\\mdot" : "\u2E31",
    "\\mddot" : "\u003A",

    // Chess
    "\\wking" : "\u2654",
    "\\wqueen" : "\u2655",
    "\\wrook" : "\u2656",
    "\\wbishop" : "\u2657",
    "\\wknight" :"\u2658",
    "\\wpawn" : "\u2659",
    "\\bking" : "\u265A",
    "\\bqueen" : "\u265B",
    "\\brook" : "\u265C",
    "\\bbishop" : "\u265D",
    "\\bknight" :"\u265E",
    "\\bpawn" : "\u265F",

    // Card games
    "\\bspade" : "\u2660",
    "\\wheart" : "\u2661",
    "\\wdiamond" : "\u2662",
    "\\bclub" : "\u2663",
    "\\wspade" : "\u2664",
    "\\bheart" : "\u2665",
    "\\bdiamond" : "\u2666",
    "\\wclub" : "\u2667",

    // Money
    "\\dollar" : "\u0024",
    "\\cent" : "\u00A2",
    "\\pound" : "\u00A3",
    "\\yen" : "\u00A5",
    "\\franc" : "\u20A3",
    "\\euro" : "\u20AC",
    "\\peso" : "\u20B1",
    "\\bitcoin" : "\u20BF",
    "\\austral" : "\u20B3",
    "\\ruble" : "\u20BD",
    "\\hryvnia" : "\u20B4",
    "\\rupee" : "\u20B9",
    "\\lira" : "\u20AA",
    "\\tlira" : "\u20A9",
    "\\won" : "\u20A9",
    "\\baht" : "\u0E3F",

    // Non italic letters
    "\\A" : "A",
    "\\Ã€" : "Ã€",
    "\\a" : "a",
    "\\Ã " : "Ã ",
    "\\B" : "B",
    "\\b" : "b",
    "\\C" : "C",
    "\\Ã‡" : "Ã‡",
    "\\c" : "c",
    "\\Ã§" : "Ã§",
    "\\D" : "D",
    "\\d" : "d",
    "\\E" : "E",
    "\\Ã‰" : "Ã‰",
    "\\Ãˆ" : "Ãˆ",
    "\\e" : "e",
    "\\Ã©" : "Ã©",
    "\\Ã¨" : "Ã¨",
    "\\F" : "F",
    "\\f" : "f",
    "\\G" : "G",
    "\\g" : "g",
    "\\H" : "H",
    "\\h" : "h",
    "\\I" : "I",
    "\\i" : "i",
    "\\J" : "J",
    "\\j" : "j",
    "\\K" : "K",
    "\\k" : "k",
    "\\L" : "L",
    "\\l" : "l",
    "\\M" : "M",
    "\\m" : "m",
    "\\N" : "N",
    "\\n" : "n",
    "\\O" : "O",
    "\\o" : "o",
    "\\P" : "P",
    "\\p" : "p",
    "\\Q" : "Q",
    "\\q" : "q",
    "\\R" : "R",
    "\\r" : "r",
    "\\S" : "S",
    "\\s" : "s",
    "\\T" : "T",
    "\\t" : "t",
    "\\U" : "U",
    "\\u" : "u",
    "\\Ã™" : "Ã™",
    "\\Ã¹" : "Ã¹",
    "\\V" : "V",
    "\\v" : "v",
    "\\W" : "W",
    "\\w" : "w",
    "\\X" : "X",
    "\\x" : "x",
    "\\Y" : "Y",
    "\\y" : "y",
    "\\Z" : "Z",
    "\\z" : "z",

    "\\^" : "^",
    "\\_" : "_",

    // Matrix
    "\\id1" : "[1]",
    "\\id2" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u23A4 \u000A \u23A3 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id3" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id4" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 0 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\idn" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u22EF \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 \u22EF \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 \u2710 \u22EE \u2710 \u2710 \u22EE \u2710 \u2710 \u22F1 \u2710 \u2710 \u22EE \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 \u22EF \u2710 1 \u2710 \u23A6",
    
    // To build your own
    "\\mlceil" : "\u23A1",
    "\\mrceil" : "\u23A4",
    "\\mlmid" : "\u23A2",
    "\\mrmid" : "\u23A5",
    "\\mlfloor" : "\u23A3",
    "\\mrfloor" : "\u23A6",

    // Music
    "\\flat" : "\u{1D12C}",
    "\\natural" : "\u{1D12E}",
    "\\sharp" : "\u{1D130}",
    "\\eightnote" : "\u{1D160}",
    "\\sixteenthnote" : "\u{1D161}",
    "\\halfnote" : "\u{1D15E}",
    "\\quarternote" : "\u{1D15F}",
    "\\fullnote" : "\u{1D15D}",
    "\\doublenote" : "\u266B",
    "\\trebleclef" : "\u{1D11E}",
    
    // Box drawing
    "\\boxh" : "\u2500",
    "\\boxbfh" : "\u2501",
    "\\boxH" : "\u2550",
    "\\boxv" : "\u2502",
    "\\boxbfv" : "\u2503",
    "\\boxV" : "\u2551",
    "\\boxdr" : "\u250C",
    "\\boxbfdr" : "\u250F",
    "\\boxDR" : "\u2554",
    "\\boxdl" : "\u2510",
    "\\boxbfdl" : "\u2513",
    "\\boxDL" : "\u2557",
    "\\boxur" : "\u2514",
    "\\boxbfur" : "\u2517",
    "\\boxUR" : "\u255A",
    "\\boxul" : "\u2518",
    "\\boxbful" : "\u251B",
    "\\boxUL" : "\u255D",
    "\\boxvr" : "\u251C",
    "\\boxbfvr" : "\u2523",
    "\\boxVR" : "\u2560",
    "\\boxvl" : "\u2524",
    "\\boxbfvl" : "\u252B",
    "\\boxVL" : "\u2563",
    "\\boxdh" : "\u252C",
    "\\boxbfdh" : "\u2533",
    "\\boxDH" : "\u2566",
    "\\boxuh" : "\u2534",
    "\\boxbfuh" : "\u253B",
    "\\boxUH" : "\u2569",
    "\\boxvh" : "\u253C",
    "\\boxbfvh" : "\u254B",
    "\\boxVH" : "\u256C",

    // Other symbols
    "\\LaTeX" : "ğ¿á´¬ğ‘‡á´‡ğ‘‹",
    "\\TeX" : "ğ‘‡á´‡ğ‘‹",
    "\\MatTalX" : "ğ‘€á´€á´›ğ‘‡á´€ÊŸğ‘‹",
    "\\CaMuS" : "ğ¶á´¬ğ‘€á´œğ‘†",  // http://camus.math.usherbrooke.ca/index.html
    "\\infty" : "\u221E",
    "\\iinfin" : "\u29DC",
    "\\tieinfty" : "\u29DD",
    "\\nvinfty" : "\u29DE",
    "\\acidfree" : "\u267E",
    "\\radioactive" : "\u2622",
    "\\biohazard" : "\u2623",
    "\\atom" : "\u269B",
    "\\angle" : "\u2220",
    "\\measuredangle" : "\u2221",
    "\\sphericalangle" : "\u2222",
    "\\rightangle" : "\u299C",
    "\\hbar" : "\u210F",
    "\\ell" : "\u2113",
    "\\dagger" : "\u2020",
    "\\ddagger" : "\u2021",
    "\\hermitian" : "\u22B9",
    "\\qc" : "\u269C",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\wp" : "\u2118",
    "\\laplace" : "\u2112",
    "\\bloch" : "\u212C",
    "\\im" : "\u2111",
    "\\fourier" : "\u2131",
    "\\angstrom" : "\u212B",
    "\\emdash" : "\u2014",
    "\\bullet" : "\u2219",
    "\\textbullet" : "\u2022",
    "\\bigbullet" : "\u25CF",
    "\\langle" : "\u27E8",
    "\\rangle" : "\u27E9",
    "\\llangle" : "\u27EA",
    "\\rrangle" : "\u27EB",
    "\\lceil" : "\u2308",
    "\\rceil" : "\u2309",
    "\\lfloor" : "\u230A",
    "\\rfloor" : "\u230B",
    "\\lBrace" : "\u2983",
    "\\rBrace" : "\u2984",
    "\\%" : "%",
    "\\{" : "{",
    "\\}" : "}",
    "\\(" : "(",
    "\\)" : ")",
    "\\$" : "$",
    "\\backslash" : "\\",
    "\\llbracket" : "\u27E6",
    "\\rrbracket" : "\u27E7",
    "\\llparenthesis" : "\u2985",
    "\\rrparenthesis" : "\u2986",
    "\\frown" : "\u2322",
    "\\smile" : "\u2323",
    "\\qed" : "\u220E",
    "\\blacksquare" : "\u25A0",
    "\\square" : "\u25A1",
    "\\lightning" : "\u21AF",
    "\\male" : "\u2642",
    "\\female" : "\u2640",
    "\\Hermaphrodite" : "\u26A5",
    "\\neuter" : "\u26B2",
    "\\malemale" : "\u26A3",
    "\\femalefemale" : "\u26A2",
    "\\femalemale" : "\u26A4",
    "\\" : "\\",
    "\\:" : "\u2710",  // Space (internally represented with \u2710 (âœ), but switched to a real space before output)
    "\\;" : "\u2710\u2710",  // Double space
    "\\quad" : "\u2710\u2710\u2710",
    "\\qquad" : "\u2710\u2710\u2710\u2710",
    "\\!" : "\u270E",  // Remove space (if there's one surrounding \!) \u270E (âœ) will be removed before the output
    "\\colon" : "\u003A",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009"
};

// Standard dict for greek letters
const stdGreek = {
    "\\Alpha" : "\u{1D6E2}",
    "\\alpha" : "\u{1D6FC}",
    "\\Beta" : "\u{1D6E3}",
    "\\beta" : "\u{1D6FD}",
    "\\Gamma" : "\u{1D6E4}",
    "\\gamma" : "\u{1D6FE}",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u{1D6FF}",
    "\\Epsilon" : "\u{1D6E6}",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u{1D6E7}",
    "\\zeta" : "\u{1D701}",
    "\\Eta" : "\u{1D6E8}",
    "\\eta" : "\u{1D702}",
    "\\Theta" : "\u0398",
    "\\theta" : "\u{1D703}",
    "\\vartheta" : "\u{1D717}",
    "\\Iota" : "\u{1D6EA}",
    "\\iota" : "\u{1D704}",
    "\\Kappa" : "\u{1D6EB}",
    "\\kappa" : "\u{1D705}",
    "\\varkappa" : "\u{1D718}",
    "\\Lambda" : "\u{1D6EC}",
    "\\lambda" : "\u{1D706}",
    "\\Mu" : "\u{1D6ED}",
    "\\mu" : "\u{1D707}",
    "\\Nu" : "\u{1D6EE}",
    "\\nu" : "\u{1D708}",
    "\\Xi" : "\u039E",
    "\\xi" : "\u{1D709}",
    "\\Omicron" : "\u{1D6F0}",
    "\\omicron" : "\u{1D70A}",
    "\\Pi" : "\u{1D6F1}",
    "\\pi" : "\u{1D70B}",
    "\\varpi" : "\u{1D71B}",
    "\\Rho" : "\u{1D6F2}",
    "\\rho" : "\u{1D70C}",
    "\\varrho" : "\u{1D71A}",
    "\\Sigma" : "\u{1D6F4}",
    "\\sigma" : "\u{1D70E}",
    "\\varsigma" : "\u{1D70D}",
    "\\Tau" : "\u{1D6F5}",
    "\\tau" : "\u{1D70F}",
    "\\Upsilon" : "\u{1D6F6}",
    "\\upsilon" : "\u{1D710}",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u{1D719}",
    "\\varphi" : "\u{1D711}",
    "\\Chi" : "\u{1D6F8}",
    "\\chi" : "\u{1D712}",
    "\\Psi" : "\u{1D6F9}",
    "\\psi" : "\u{1D713}",
    "\\Omega" : "\u2126",
    "\\omega" : "\u{1D714}"
};

// Greek letters if the user wants basic UTF-8 characters (nostyle)
const noStyleGreek = {
    "\\Alpha" : "\u0391",
    "\\alpha" : "\u03B1",
    "\\Beta" : "\u0392",
    "\\beta" : "\u03B2",
    "\\Gamma" : "\u0393",
    "\\gamma" : "\u03B3",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u03B4",
    "\\Epsilon" : "\u0395",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u0396",
    "\\zeta" : "\u03B6",
    "\\Eta" : "\u0397",
    "\\eta" : "\u03B7",
    "\\Theta" : "\u0398",
    "\\theta" : "\u03B8",
    "\\vartheta" : "\u03D1",
    "\\Iota" : "\u0399",
    "\\iota" : "\u03B9",
    "\\Kappa" : "\u039A",
    "\\kappa" : "\u03BA",
    "\\varkappa" : "\u03F0",
    "\\Lambda" : "\u039B",
    "\\lambda" : "\u03BB",
    "\\Mu" : "\u039C",
    "\\mu" : "\u03BC",
    "\\Nu" : "\u039D",
    "\\nu" : "\u03BD",
    "\\Xi" : "\u039E",
    "\\xi" : "\u03BE",
    "\\Omicron" : "\u039F",
    "\\omicron" : "\u03BF",
    "\\Pi" : "\u03A0",
    "\\pi" : "\u03C0",
    "\\varpi" : "\u03D6",
    "\\Rho" : "\u03A1",
    "\\rho" : "\u03C1",
    "\\varrho" : "\u03F1",
    "\\Sigma" : "\u03A3",
    "\\sigma" : "\u03C3",
    "\\varsigma" : "\u03C2",
    "\\Tau" : "\u03A4",
    "\\tau" : "\u03C4",
    "\\Upsilon" : "\u03A5",
    "\\upsilon" : "\u03C5",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u03D5",
    "\\varphi" : "\u03C6",
    "\\Chi" : "\u03A7",
    "\\chi" : "\u03C7",
    "\\Psi" : "\u03A8",
    "\\psi" : "\u03C8",
    "\\Omega" : "\u03A9",
    "\\omega" : "\u03C9"
};

// Default dict (in math mode), used in the suggestion popup
const defaultDict = {...mathDictionary, ...stdGreek};

const textCommands = {
    "\\^" : "^",
    "\\_" : "_",
    "\\LaTeX" : "ğ¿á´¬ğ‘‡á´‡ğ‘‹",
    "\\TeX" : "ğ‘‡á´‡ğ‘‹",
    "\\MatTalX" : "ğ‘€á´€á´›ğ‘‡á´€ÊŸğ‘‹",
    "\\CaMuS" : "ğ¶á´¬ğ‘€á´œğ‘†",  // http://camus.math.usherbrooke.ca/index.html
    "\\textbullet" : "\u2022",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\%" : "%",
    "\\#" : "#",
    "\\{" : "{",
    "\\}" : "}",
    "\\$" : "$",
    "\\backslash" : "\\",
    "\\textbackslash" : "\\",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009",
    "\\!" : "\u270E",
    "\\O" : "\u00D8",
    "\\o" : "\u00F8",
    "\\i" : "\u0131",
    "\\j" : "\u0237",
    "\\L" : "\u0141",
    "\\l" : "\u0142",
    "\\OE" : "\u0152",
    "\\oe" : "\u0153",
    "\\AE" : "\u00C6",
    "\\ae" : "\u00E6",
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,
    "\\hspace" : hspace,
    "\\vskip" : vskip,
    "\\`" : grave,
    "\\'" : acute,
    "\\^" : hat,
    '\\"' : ddot,
    "\\H" : doubleAccute,
    "\\~" : tilde,
    "\\c" : cedilla,
    "\\k" : ogonek,
    "\\=" : bar,
    "\\b" : underline,
    "\\." : dot,
    "\\d" : dotBelow,
    "\\r" : ringAbove,
    "\\u" : breve,
    "\\v" : caron
};

// Superscript is used (by the superscript function) to convert characters to the corresponding superscript character
const Superscript = {
    "0" : "\u2070",
    "1" : "\u00B9",
    "2" : "\u00B2",
    "3" : "\u00B3",
    "4" : "\u2074",
    "5" : "\u2075",
    "6" : "\u2076",
    "7" : "\u2077",
    "8" : "\u2078",
    "9" : "\u2079",

    "+" : "\u207A",
    "-" : "\u207B",
    "\u2212" : "\u207B",
    "=" : "\u207C",
    "(" : "\u207D",
    ")" : "\u207E",
    "\\" : "á ",
    "/" : "áŸ",
    "." : "á§",
    "," : "\u02D2",
    "$" : "á™š",

    "A" : "á´¬",
    "a" : "áµƒ",
    "B" : "á´®",
    "b" : "áµ‡",
    "C" : "á¶œ",
    "c" : "á¶œ",
    "D" : "á´°",
    "d" : "áµˆ",
    "E" : "á´±",
    "e" : "áµ‰",
    "f" : "á¶ ",
    "G" : "á´³",
    "g" : "áµ",
    "H" : "á´´",
    "h" : "Ê°",
    "I" : "á´µ",
    "i" : "â±",
    "J" : "á´¶",
    "j" : "Ê²",
    "K" : "á´·",
    "k" : "áµ",
    "L" : "á´¸",
    "l" : "Ë¡",
    "M" : "á´¹",
    "m" : "áµ",
    "N" : "á´º",
    "n" : "â¿",
    "O" : "á´¼",
    "o" : "áµ’",
    "P" : "á´¾",
    "p" : "áµ–",
    "R" : "á´¿",
    "r" : "Ê³",
    "S" : "Ë¢",
    "s" : "Ë¢",
    "T" : "áµ€",
    "t" : "áµ—",
    "U" : "áµ",
    "u" : "áµ˜",
    "V" : "â±½",
    "v" : "áµ›",
    "W" : "áµ‚",
    "w" : "Ê·",
    "X" : "Ë£",
    "x" : "Ë£",
    "y" : "Ê¸",
    "Z" : "á¶»",
    "z" : "á¶»",

    "ğ´" : "á´¬",
    "ğ‘" : "áµƒ",
    "ğµ" : "á´®",
    "ğ‘" : "áµ‡",
    "ğ¶" : "á¶œ",
    "ğ‘" : "á¶œ",
    "ğ·" : "á´°",
    "ğ‘‘" : "áµˆ",
    "ğ¸" : "á´±",
    "ğ‘’" : "áµ‰",
    "ğ‘“" : "á¶ ",
    "ğº" : "á´³",
    "ğ‘”" : "áµ",
    "ğ»" : "á´´",
    "â„" : "Ê°",
    "ğ¼" : "á´µ",
    "ğ‘–" : "â±",
    "ğ½" : "á´¶",
    "ğ‘—" : "Ê²",
    "ğ¾" : "á´·",
    "ğ‘˜" : "áµ",
    "ğ¿" : "á´¸",
    "ğ‘™" : "Ë¡",
    "ğ‘€" : "á´¹",
    "ğ‘š" : "áµ",
    "ğ‘" : "á´º",
    "ğ‘›" : "â¿",
    "ğ‘‚" : "á´¼",
    "ğ‘œ" : "áµ’",
    "ğ‘ƒ" : "á´¾",
    "ğ‘" : "áµ–",
    "ğ‘…" : "á´¿",
    "ğ‘Ÿ" : "Ê³",
    "ğ‘†" : "Ë¢",
    "ğ‘ " : "Ë¢",
    "ğ‘‡" : "áµ€",
    "ğ‘¡" : "áµ—",
    "ğ‘ˆ" : "áµ",
    "ğ‘¢" : "áµ˜",
    "ğ‘‰" : "â±½",
    "ğ‘£" : "áµ›",
    "ğ‘Š" : "áµ‚",
    "ğ‘¤" : "Ê·",
    "ğ‘‹" : "Ë£",
    "ğ‘¥" : "Ë£",
    "ğ‘¦" : "Ê¸",
    "ğ‘" : "á¶»",
    "ğ‘§" : "á¶»",

    "ğ›½" : "\u1D5D",
    "ğ›¤" : "á£˜",
    "ğ›¾" : "\u1D5E",
    "Î”" : "á",
    "Î´" : "\u1D5F",
    "Ïµ" : "áµ‹",
    "Î›" : "á£”",
    "ğœƒ" : "\u1DBF",
    "ğœ„" : "á¶¥",
    "ğœˆ" : "á¶¹",
    "Ïƒ" : "á£™",
    "ğœ™" : "á¶²",
    "ğœ‘" : "\u1D60",
    "ğœŒ" : "á£–",
    "ğœ’" : "\u1D61",

    "âˆ«" : "á¶´",
    "â‰ " : "á™¾",
    "âˆ˜" : "Â°",
    "$" : "á™š",
    "âˆ" : "\u2710\u1AB2\u2710",  // Only works on certain website/apps
    "âˆ…" : "\u{1D1A9}",
    "*" : "*",

    "\u2710" : "\u2710",
    "\u270E" : "\u270E",
    " " : " "
};

// Subscript is used (by the subscript function) to convert characters to the corresponding subscript character
const Subscript = {
    "0" : "\u2080",
    "1" : "\u2081",
    "2" : "\u2082",
    "3" : "\u2083",
    "4" : "\u2084",
    "5" : "\u2085",
    "6" : "\u2086",
    "7" : "\u2087",
    "8" : "\u2088",
    "9" : "\u2089",

    "+" : "\u208A",
    "-" : "\u208B",
    "\u2212" : "\u208B",
    "=" : "\u208C",
    "(" : "\u208D",
    ")" : "\u208E",
    "," : "\u2710\u0326\u2710",
    "." : "\u2710\u0323\u2710",

    "a" : "\u2090",
    "e" : "\u2091",
    "h" : "\u2095",
    "i" : "\u1D62",
    "j" : "â±¼",
    "k" : "\u2096",
    "l" : "\u2097",
    "m" : "\u2098",
    "n" : "\u2099",
    "O" : "\u2092",
    "o" : "\u2092",
    "p" : "\u209A",
    "r" : "áµ£",
    "S" : "\u209B",
    "s" : "\u209B",
    "t" : "\u209C",
    "u" : "áµ¤",
    "V" : "áµ¥",
    "v" : "áµ¥",
    "X" : "\u2093",
    "x" : "\u2093",

    "ğ‘" : "\u2090",
    "ğ‘’" : "\u2091",
    "â„" : "\u2095",
    "ğ‘–" : "\u1D62",
    "ğ‘—" : "â±¼",
    "ğ‘˜" : "\u2096",
    "ğ‘™" : "\u2097",
    "ğ‘š" : "\u2098",
    "ğ‘›" : "\u2099",
    "ğ‘‚" : "\u2092",
    "ğ‘œ" : "\u2092",
    "ğ‘" : "\u209A",
    "ğ‘Ÿ" : "áµ£",
    "ğ‘†" : "\u209B",
    "ğ‘ " : "\u209B",
    "ğ‘¡" : "\u209C",
    "ğ‘¢" : "áµ¤",
    "ğ‘‰" : "áµ¥",
    "ğ‘£" : "áµ¥",
    "ğ‘‹" : "\u2093",
    "ğ‘¥" : "\u2093",

    "ğ›½" : "\u1D66",
    "ğ›¾" : "\u1D67",
    "ğœŒ" : "\u1D68",
    "ğœ‘" : "\u1D69",
    "ğœ™" : "\u1D69",
    "ğœ’" : "\u1D6A",

    "â†’" : "\u2710\u2710\u0362\u2710\u2710",
    "âˆ" : "\u2710\u035A\u2710",

    "\u2710" : "\u2710",
    "\u270E" : "\u270E",
    " " : " "
};

// Dict with characters and their corresponding symbol that can be combined and put above another symbol
const Above = {
    "." : "\u0307",
    ":" : "\u0308",
    "\u2236" : "\u0308",
    "-" : "\u0305",
    "âˆ’" : "\u0305",
    "`" : "\u0300",
    "Â´" : "\u0301",
    "^" : "\u0302",
    "=" : "\u033F",
    "âˆ¼" : "\u0303",
    "âˆ" : "\u1AB2", // Only works on certain website/apps
    "âˆ˜" : "\u030A",
    "Â°" : "\u030A",
    "a" : "\u0363",
    "ğ‘" : "\u0363",
    "b" : "\u1DE8",
    "ğ‘" : "\u1DE8",
    "c" : "\u0368",
    "ğ‘" : "\u0368",
    "d" : "\u0369",
    "ğ‘‘" : "\u0369",
    "e" : "\u0364",
    "ğ‘’" : "\u0364",
    "f" : "\u1DEB",
    "ğ‘“" : "\u1DEB",
    "h" : "\u036A",
    "â„" : "\u036A",
    "i" : "\u0365",
    "ğ‘–" : "\u0365",
    "k" : "\u1DDC",  // Only works on certain website/apps
    "ğ‘˜" : "\u1DDC",
    "m" : "\u036B",
    "ğ‘š" : "\u036B",
    "N" : "\u1DE1",
    "ğ‘" : "\u1DE1",
    "n" : "\u1DE0",  // Only works on certain website/apps
    "ğ‘›" : "\u1DE0",
    "o" : "\u0366",
    "ğ‘œ" : "\u0366",
    "p" : "\u1DEE",
    "ğ‘" : "\u1DEE",
    "R" : "\u1DE2",
    "ğ‘…" : "\u1DE2",
    "r" : "\u036C",
    "ğ‘Ÿ" : "\u036C",
    "t" : "\u036D",
    "ğ‘¡" : "\u036D",
    "u" : "\u0367",
    "ğ‘¢" : "\u0367",
    "v" : "\u036E",
    "ğ‘£" : "\u036E",
    "x" : "\u036F",
    "ğ‘¥" : "\u036F",

    "ğ›¼" : "\u1DE7",
    "ğ›½" : "\u1DE9",

    "â†¼" : "\u20D0",
    "â‡€" : "\u20D1",
    "â†”" : "\u20E1",
    "â†¶" : "\u20D4",
    "â†·" : "\u20D5",
    "â†" : "\u20D6",
    "â†’" : "\u20D7",
    "â†“" : "\u1AB3",
    "âˆ´" : "\u1AB4",
    "â‹¯" : "\u20DB",
    "â€¦" : "\u20DB",
    " " : " "
};

// Dict with characters and their corresponding symbol that can be combined and put below another symbol
const Below = {
    "." : "\u0323",
    ":" : "\u0324",
    "\u2236" : "\u0324",
    "-" : "\u0332",
    "âˆ’" : "\u0332",
    "=" : "\u0333",
    "m" : "\u1AC0",
    "ğ‘š" : "\u1AC0",
    "x" : "\u0353",
    "ğ‘¥" : "\u0353",
    "w" : "\u1ABF",
    "ğ‘¤" : "\u1ABF",
    "â†½" : "\u20ED",
    "â‡" : "\u20EC",
    "â†" : "\u20EE",
    "â†’" : "\u20EF",
    "â†”" : "\u034D",
    " " : " "
};

// Regular dict used to convert characters that are not a command
// Automatically convert text into a mathematical font
const lettersMath = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "Â°" : "Â°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "*" : "*",
    "@" : "@",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "\u003C",
    ">" : "\u003E",
    "%" : "%",
    "#" : "#",
    "~" : "~",
    "Â¬" : "Â¬",
    ":" : "\u2236",
    ";" : ";",
    "â€¦" : "â€¦",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9",
    "A" : "\u{1D434}",
    "Ã€" : "\u{1D434}\u0300",
    "a" : "\u{1D44E}",
    "Ã " : "\u{1D44E}\u0300",
    "B" : "\u{1D435}",
    "b" : "\u{1D44F}",
    "C" : "\u{1D436}",
    "c" : "\u{1D450}",
    "D" : "\u{1D437}",
    "d" : "\u{1D451}",
    "E" : "\u{1D438}",
    "Ã‰" : "\u{1D438}\u0301",
    "e" : "\u{1D452}",
    "Ã©" : "\u{1D452}\u0301",
    "F" : "\u{1D439}",
    "f" : "\u{1D453}",
    "G" : "\u{1D43A}",
    "g" : "\u{1D454}",
    "H" : "\u{1D43B}",
    "h" : "\u210E",
    "I" : "\u{1D43C}",
    "i" : "\u{1D456}",
    "J" : "\u{1D43D}",
    "j" : "\u{1D457}",
    "K" : "\u{1D43E}",
    "k" : "\u{1D458}",
    "L" : "\u{1D43F}",
    "l" : "\u{1D459}",
    "M" : "\u{1D440}",
    "m" : "\u{1D45A}",
    "N" : "\u{1D441}",
    "n" : "\u{1D45B}",
    "O" : "\u{1D442}",
    "o" : "\u{1D45C}",
    "P" : "\u{1D443}",
    "p" : "\u{1D45D}",
    "Q" : "\u{1D444}",
    "q" : "\u{1D45E}",
    "R" : "\u{1D445}",
    "r" : "\u{1D45F}",
    "S" : "\u{1D446}",
    "s" : "\u{1D460}",
    "T" : "\u{1D447}",
    "t" : "\u{1D461}",
    "U" : "\u{1D448}",
    "Ã™" : "\u{1D448}\u0300",
    "u" : "\u{1D462}",
    "Ã¹" : "\u{1D462}\u0300",
    "V" : "\u{1D449}",
    "v" : "\u{1D463}",
    "W" : "\u{1D44A}",
    "w" : "\u{1D464}",
    "X" : "\u{1D44B}",
    "x" : "\u{1D465}",
    "Y" : "\u{1D44C}",
    "y" : "\u{1D466}",
    "Z" : "\u{1D44D}",
    "z" : "\u{1D467}",
    "\u2710" : " ",
    " " : " "
};

// Dict used to convert characters that are not a command if the keyword !chem is used as the fist word of the text input
const lettersNoFont = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "Â°" : "Â°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "\u003C",
    ">" : "\u003E",
    "%" : "%",
    "*" : "*",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "Â¬" : "Â¬",
    ":" : ":",  // Same as "\colon", use "\ratio" instead to get the same as without "!chem"
    ";" : ";",
    "â€¦" : "â€¦",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "Ã€" : "Ã€",
    "a" : "a",
    "Ã " : "Ã ",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "Ã‡" : "Ã‡",
    "c" : "c",
    "Ã§" : "Ã§",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "Ã‰" : "Ã‰",
    "Ãˆ" : "Ãˆ",
    "e" : "e",
    "Ã©" : "Ã©",
    "Ã¨" : "Ã¨",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "i" : "i",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "o" : "o",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "Ã™" : "Ã™",
    "Ã¹" : "Ã¹",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    "\u2710" : " ",
    " " : " "
};

const lettersOutMathMode = {
    "+" : "+",
    "-" : "-",
    "=" : "=",
    "'" : "'",
    '"' : '"',
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "Â°" : "Â°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "<",
    ">" : ">",
    "%" : "%",
    "*" : "*",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "Â¬" : "Â¬",
    ":" : ":",
    ";" : ";",
    "â€¦" : "â€¦",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "Ã€" : "Ã€",
    "Ã‚" : "Ã‚",
    "a" : "a",
    "Ã " : "Ã ",
    "Ã¢" : "Ã¢",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "Ã‡" : "Ã‡",
    "c" : "c",
    "Ã§" : "Ã§",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "Ã‰" : "Ã‰",
    "Ãˆ" : "Ãˆ",
    "ÃŠ" : "ÃŠ",
    "Ã‹" : "Ã‹",
    "e" : "e",
    "Ã©" : "Ã©",
    "Ã¨" : "Ã¨",
    "Ãª" : "Ãª",
    "Ã«" : "Ã«",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "Ã" : "Ã",
    "i" : "i",
    "Ã¯" : "Ã¯",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "Ã–" : "Ã–",
    "Ã”" : "Ã”",
    "o" : "o",
    "Ã¶" : "Ã¶",
    "Ã´" : "Ã´",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "Ã™" : "Ã™",
    "Ã¹" : "Ã¹",
    "Ã›" : "Ã›",
    "Ã»" : "Ã»",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    "\u2710" : " ",
    " " : " "
};


//-----------------------------------------------------//


/** HTMLElements **/

// Submit button ('Convert' is what's seen by the users)
const submit = document.getElementById("convert");
submit.onclick = function() {main()};

// Copy button
const copyButton = document.getElementById("copy");
copyButton.onclick = function() {copyTextOut()};

// Clear button
const resetButton = document.getElementById("reset");
resetButton.onclick = function() {clear()};

// Button to open the suggestions popup
const suggestionsBtn = document.getElementById("suggestionsBtn");
suggestionsBtn.onclick = function() {getSuggestion()};

// Originally hidden
// Can be accessed with a keyboard shortcut (Alt+S or Alt+C on chrome or firefox respectively) or by clicking the button (android)
const suggestionsPopup = document.getElementById("suggestions");

// Adjust spaces button
const spacesButton = document.getElementById("adjust");

// Mathematical font button
const changeFontButton = document.getElementById("mathFont");

// Math mode button
const changeModeButton = document.getElementById("mathMode");

// First and second text box
const textIn = document.getElementById("text_in");
const textOut = document.getElementById("text_out");

const mistakesBox = document.getElementById("mistakes");


//-----------------------------------------------------//


/** Other **/

// Used in the subsection 'Suggestion box (or completion)' to recognize on which word is the cursor
const wordsDelimiters = [" ", "", "\u000A", "\\", "^", "_", "(", ")", "[", "]", "{", "}", ".", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"];
const wordsDelimitersWOB = [" ", "", "\u000A", "^", "_", "(", ")", "[", "]", "{", "}", ".", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"]; // Without backslash

// Used in adjustSpacesCommon to chose which symbols to surround with spaces (if touched by a specific symbol like '=')
const characters = "AÃ€Ã‚BCÃ‡DEÃ‰ÃˆÃ‹ÃŠFGHIJKLMNOÃ”Ã–PQRSTUÃ™Ã›VWXYZaÃ Ã¢bcÃ§deÃ©Ã¨ÃªÃ«fghijklmnoÃ´Ã¶pqrstuÃ¹Ã»vwxyz0123456789"+
                   "ğ´ğµğ¶ğ·ğ¸ğ¹ğºğ»ğ¼ğ½ğ¾ğ¿ğ‘€ğ‘ğ‘‚ğ‘ƒğ‘„ğ‘…ğ‘†ğ‘‡ğ‘ˆğ‘‰ğ‘Šğ‘‹ğ‘Œğ‘ğ‘ğ‘ğ‘ğ‘‘ğ‘’ğ‘“ğ‘”â„ğ‘–ğ‘—ğ‘˜ğ‘™ğ‘šğ‘›ğ‘œğ‘ğ‘ğ‘Ÿğ‘ ğ‘¡ğ‘¢ğ‘£ğ‘¤ğ‘¥ğ‘¦ğ‘§"+
                   "ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«ğŸ˜ğŸ™ğŸšğŸ›ğŸœğŸğŸğŸŸğŸ ğŸ¡"+
                   "ğ‘¨ğ‘©ğ‘ªğ‘«ğ‘¬ğ‘­ğ‘®ğ‘¯ğ‘°ğ‘±ğ‘²ğ‘³ğ‘´ğ‘µğ‘¶ğ‘·ğ‘¸ğ‘¹ğ‘ºğ‘»ğ‘¼ğ‘½ğ‘¾ğ‘¿ğ’€ğ’ğ’‚ğ’ƒğ’„ğ’…ğ’†ğ’‡ğ’ˆğ’‰ğ’Šğ’‹ğ’Œğ’ğ’ğ’ğ’ğ’‘ğ’’ğ’“ğ’”ğ’•ğ’–ğ’—ğ’˜ğ’™ğ’šğ’›"+
                   "ğ’œâ„¬ğ’ğ’Ÿâ„°â„±ğ’¢â„‹â„ğ’¥ğ’¦â„’â„³ğ’©ğ’ªğ’«ğ’¬â„›ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µğ’¶ğ’·ğ’¸ğ’¹â„¯ğ’»â„Šğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒâ„´ğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“"+
                   "ğ”„ğ”…â„­ğ”‡ğ”ˆğ”‰ğ”Šâ„Œâ„‘ğ”ğ”ğ”ğ”ğ”‘ğ”’ğ”“ğ””â„œğ”–ğ”—ğ”˜ğ”™ğ”šğ”›ğ”œâ„¨ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·"+
                   "ğ•¬ğ•­ğ•®ğ•¯ğ•°ğ•±ğ•²ğ•³ğ•´ğ•µğ•¶ğ•·ğ•¸ğ•¹ğ•ºğ•»ğ•¼ğ•½ğ•¾ğ•¿ğ–€ğ–ğ–‚ğ–ƒğ–„ğ–…ğ–†ğ–‡ğ–ˆğ–‰ğ–Šğ–‹ğ–Œğ–ğ–ğ–ğ–ğ–‘ğ–’ğ–“ğ–”ğ–•ğ––ğ–—ğ–˜ğ–™ğ–šğ–›ğ–œğ–ğ–ğ–Ÿ"+
                   "ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ"+
                   "ğ—”ğ—•ğ—–ğ——ğ—˜ğ—™ğ—šğ—›ğ—œğ—ğ—ğ—Ÿğ— ğ—¡ğ—¢ğ—£ğ—¤ğ—¥ğ—¦ğ—§ğ—¨ğ—©ğ—ªğ—«ğ—¬ğ—­ğ—®ğ—¯ğ—°ğ—±ğ—²ğ—³ğ—´ğ—µğ—¶ğ—·ğ—¸ğ—¹ğ—ºğ—»ğ—¼ğ—½ğ—¾ğ—¿ğ˜€ğ˜ğ˜‚ğ˜ƒğ˜„ğ˜…ğ˜†ğ˜‡ğŸ¬ğŸ­ğŸ®ğŸ¯ğŸ°ğŸ±ğŸ²ğŸ³ğŸ´ğŸµ"+
                   "ğ˜ˆğ˜‰ğ˜Šğ˜‹ğ˜Œğ˜ğ˜ğ˜ğ˜ğ˜‘ğ˜’ğ˜“ğ˜”ğ˜•ğ˜–ğ˜—ğ˜˜ğ˜™ğ˜šğ˜›ğ˜œğ˜ğ˜ğ˜Ÿğ˜ ğ˜¡ğ˜¢ğ˜£ğ˜¤ğ˜¥ğ˜¦ğ˜§ğ˜¨ğ˜©ğ˜ªğ˜«ğ˜¬ğ˜­ğ˜®ğ˜¯ğ˜°ğ˜±ğ˜²ğ˜³ğ˜´ğ˜µğ˜¶ğ˜·ğ˜¸ğ˜¹ğ˜ºğ˜»"+
                   "ğ™°ğ™±ğ™²ğ™³ğ™´ğ™µğ™¶ğ™·ğ™¸ğ™¹ğ™ºğ™»ğ™¼ğ™½ğ™¾ğ™¿ğš€ğšğš‚ğšƒğš„ğš…ğš†ğš‡ğšˆğš‰ğšŠğš‹ğšŒğšğšğšğšğš‘ğš’ğš“ğš”ğš•ğš–ğš—ğš˜ğš™ğššğš›ğšœğšğšğšŸğš ğš¡ğš¢ğš£ğŸ¶ğŸ·ğŸ¸ğŸ¹ğŸºğŸ»ğŸ¼ğŸ½ğŸ¾ğŸ¿"+
                   "ğ˜¼ğ˜½ğ˜¾ğ˜¿ğ™€ğ™ğ™‚ğ™ƒğ™„ğ™…ğ™†ğ™‡ğ™ˆğ™‰ğ™Šğ™‹ğ™Œğ™ğ™ğ™ğ™ğ™‘ğ™’ğ™“ğ™”ğ™•ğ™–ğ™—ğ™˜ğ™™ğ™šğ™›ğ™œğ™ğ™ğ™Ÿğ™ ğ™¡ğ™¢ğ™£ğ™¤ğ™¥ğ™¦ğ™§ğ™¨ğ™©ğ™ªğ™«ğ™¬ğ™­ğ™®ğ™¯"+
                   "ğ›¢ğ›¼ğ›£ğ›½ğ›¤ğ›¾Î”ğ›¥ğ›¿ğ›¦ÏµÎµğ›§ğœğ›¨ğœ‚Î˜ğœƒğœ—ğ›ªğœ„ğ›«ğœ…ğœ˜ğ›¬ğœ†ğ›­ğœ‡ğ›®ğœˆÎ¦ğœ™ğœ‘Îğœ‰ğ›°ğœŠğ›±ğœ‹ğœ›ğ›²ğœŒÏ±ğ›´ğœğœğ›µğœğ›¶ğœğ›¸ğœ’ğ›¹ğœ“â„¦ğœ”"+
                   "ğœœğœ¶ğœğœ·ğœğœ¸ğš«ğœŸğœ¹ğœ ğ›œğ›†ğœ¡ğœ»ğœ¢ğœ¼ğš½ğœ½ğ‘ğœ¤ğœ¾ğœ¥ğœ¿ğ’ğœ¦ğ€ğœ§ğğœ¨ğ‚ğš½ğ“ğ‹ğšµğƒğœªğ„ğœ«ğ…ğ•ğœ¬ğ†ğ› ğœ®ğ›”ğ‡ğœ¯ğ‰ğœ°ğŠğœ²ğŒğœ³ğğ›€ğ"+ 
                   "Î‘Î±Î’Î²Î“Î³Î´Î–Î¶Î—Î·Î¸Ï‘Î™Î¹ÎšÎºÏ°Î›Î»ÎœÎ¼ÎÎ½Î¾ÎŸÎ¿Î Ï€Ï–Î¡ÏÏ±Î£ÏƒÏ‚Î¤Ï„Î¥Ï…Ï•Ï†Î§Ï‡Î¨ÏˆÎ©Ï‰" + 
                   "ğ–ğ°ğ—ğ±ğ˜ğ²ğ›…ğ›ğµğœğ¶ğ›‰ğ›ğğ›ŠğŸğ¹ğŒğ ğºğ¡ğ»ğ¢ğ¼ğ½ğ¤ğ¾ğ¥ğ¿ğğ¦ğ€ğğ¨ğ‚ğğ©ğƒğªğ„ğğ…ğ¬ğ†ğ­ğ‡ğ®ğˆ" +
                   "â„¾â„½â„¿â„¼â…€" + 
                   "()[]{}â¦…â¦†âŸ¦âŸ§â¦ƒâ¦„";

// Symbol for an error
const errSymbol = "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";  // bold "err" with two "x" under it

// Every undefined commands
let errorsList = "";

// Recognize if the device is screen only
const touchScreen = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);


/**************************************************************************************/


/// FUNCTIONS ///

/** Front-end **/

function copyTextOut() {
    // Copy second box (output) to clipboard
    if (textOut.disabled === false) {
        navigator.clipboard.writeText(textOut.value);
        copyButton.value = "Copied!";
        setTimeout(() => {
            copyButton.value = "Copy text";
        }, 2500)  // Returns to initial copyButton
    };
};

function copyTextIn() {
    // Copy first box (input) to clipboard
    navigator.clipboard.writeText(textIn.value);
};

function clear() {
    // Clears everything
    copyButton.value = "Copy text";
    mistakesBox.textContent = "";
    textOut.disabled = true;
    suggestionsPopup.style.display = "none";
    suggestionsPopup.textContent = "";
};

// Show suggestion button and hide shortcuts if the device is screen only
if (touchScreen) {
    suggestionsBtn.style.display = "inline-block";
    document.getElementsByClassName("shortcuts").style.display = "none";
};


//-----------------------------------------------------//


/** Suggestion box (or completion) **/

function closeSuggestions() {
    // Close and empties the suggestion popup
    suggestionsPopup.style.display = "none";
    suggestionsPopup.textContent = "";
};

function getSuggestion() {
    // Calls suggestions() with the word touching the cursor if the popup is closed, else it closes the popup
    if (suggestionsPopup.style.display !== "inline-block") { 
        suggestionsPopup.textContent = "";
        let word = findWord(textIn.value, textIn.selectionEnd - 1);
        suggestionsPopup.style.display = "inline-block";
        suggestions(word);
    } else {
        closeSuggestions();
    };
};

function findWord(text, cursorPosition, addedLetter="") {
    // Used in the suggestion / completion popup
    // Finds the word that is touched by the cursor
    if (addedLetter.length === 1) {  // ie a letter
        text = text.split("");
        text[cursorPosition] += addedLetter;
        text = text.join("");
    } else if (addedLetter === "Backspace") {
        text = text.split("");
        text[cursorPosition] = "";
        text = text.join("");
        cursorPosition -= 1;
    };
    let word = "";
    while (!(wordsDelimiters.includes(text.charAt(cursorPosition + 1)))) {
        cursorPosition += 1;
    };
    while (!(wordsDelimitersWOB.includes(text.charAt(cursorPosition)))) {
        if (text.charAt(cursorPosition) === "\\") {
            word = text.charAt(cursorPosition) + word;
            break;
        } else {
            word = text.charAt(cursorPosition) + word;
            cursorPosition -= 1;
        }
    };
    return word;
};

function suggestions(command) {
    // Outputs list of other commands that are similar to the one currently being written
    if (command === "") {
        closeSuggestions();
    } else if (command[0] !== "\\") {
        let row = suggestionsPopup.insertRow(-1);
        let cell = row.insertCell(0);
        cell.textContent = "The first character of the command must be a backslash (\\). Superscript starts with ^ and subscript with _";
    } else {
        command = command.substring(1, command.length);  // Erases the backslash so that, for instance, \arrow will also show \rightarrow, etc.
        for (let keys in defaultDict) {
            // Puts commands in button form, so they can be clicked on to replace the command being written
            if (keys.toLowerCase().indexOf(command.toLowerCase()) !== -1) {
                let row = suggestionsPopup.insertRow(-1);
                let cell = row.insertCell(0);
                let btn = document.createElement("button");
                btn.value = showCommand(keys);
                btn.textContent = toReplaceCommand(keys);

                // Button style
                btn.style.width = "145px";  // Would be cleaner with something like 'fit-content', but is way to slow
                btn.style.height = "17px";
                const btnBackColor = getComputedStyle(document.body).backgroundColor;
                const btnFontColor = (btnBackColor === "rgb(255, 255, 255)") ? "black" : "whitesmoke"; 
                btn.style.backgroundColor = btnBackColor;
                btn.style.border = "1px solid " + btnBackColor;
                btn.style.color = btnFontColor;
                btn.style.borderRadius = "3px";
                btn.type = "button";

                // Complete the command if the user clicks on that command
                btn.addEventListener("click", () => {
                    textIn.value = semiAutoCompletion(textIn.value, textIn.selectionEnd, btn.value);
                    closeSuggestions();
                    textIn.focus();
                });

                // Shows what the command ouputs on mouseover, return to normal on mouseout
                btn.addEventListener("mouseover", () => {
                    let x = btn.textContent;
                    btn.textContent = btn.value;
                    btn.value = x;
                });
                btn.addEventListener("mouseout", () => {
                    let x = btn.textContent;
                    btn.textContent = btn.value;
                    btn.value = x;
                });
                cell.appendChild(btn);
            };
        };
    };
};

function semiAutoCompletion(textIn, cursorPosition, command) {
    // Replace the command being written by the selected suggestion
    let textOut = textIn;
    // Find end of word
    while (!(wordsDelimiters.includes(textIn.charAt(cursorPosition)))) {
        cursorPosition += 1;
    };
    // Deletes word
    while (textIn.charAt(cursorPosition - 1) !== "\\") {
        textOut = textOut.substring(0, cursorPosition - 1) + textOut.substring(cursorPosition);
        cursorPosition -= 1;
    };
    // Replace by selected suggestion
    textOut = textOut.substring(0, cursorPosition - 1) + command + textOut.substring(cursorPosition);
    return textOut;
};

function showCommand(key) {
    // Used in suggestions
    // Changes what's seen when the user hovers on a command in the suggestion popup
    if (typeof defaultDict[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[n]{x} \u2192 â¿âˆšğ‘¥";
        } else if (key == "\\sqrt*") {
            return "\\sqrt[n]* \u2192 â¿âˆš";
        } else if (key == "\\frac") {
            return "\\frac{1}{2} \u2192 Â¹âˆ•â‚‚";
        } else if (key == "\\frac*") {
            return "\\frac*{1}{2} \u2192 Â½";
        } else if ((key == "\\above") || (key == "\\below") || (key == "\\hspace") || (key == "\\vskip")) {
            return key + "{}";
        } else if ((key == "_") || (key == "^")) {
            return "x" + key + "{a1} \u2192 ğ‘¥" + (defaultDict[key](["a", "1"], defaultDict[key])).join("");
        } else if (key == "\\pmod") {
            return key + "{n} \u2192 " + spaceCommand(defaultDict[key](["n"], defaultDict[key]));
        } else {
            return key + "{abc} \u2192 " + (defaultDict[key](["a", "b", "c"], defaultDict[key])).join("");
        };
    } else {
        if (key == "\\:") {
            return "1 space";
        } else if ((key == "\\;") || ((key == "\\quad") || (key == "\\qquad"))) {
            return defaultDict[key].length + " spaces";
        } else if (key === "\\!") {
            return "Remove a space";
        } else if ((key == "\\id2") || (key == "\\id3") || (key == "\\id4") || (key == "\\idn")) {
            const M = {
                "\\id2": "â¡ 1 0 â¤\u000Aâ£ 0 1 â¦",
                "\\id3" : "â¡ 1 0 0 â¤\u000Aâ¢ 0 1 0 â¥\u000Aâ£ 0 0 1 â¦",
                "\\id4" : "â¡ 1 0 0 0 â¤\u000Aâ¢ 0 1 0 0 â¥\u000Aâ¢ 0 0 1 0 â¥\u000Aâ£ 0 0 0 1 â¦",
                "\\idn" : "â¡ 1 0 â‹¯ 0 â¤\u000Aâ¢ 0 1 â‹¯ 0 â¥\u000Aâ¢  â‹®  â‹®  â‹±  â‹® â¥\u000Aâ£ 0 0 â‹¯ 1 â¦"
            }
            return M[key];
        } else {
            return spaceCommand(defaultDict[key]);
        };
    };
};

function toReplaceCommand(key) {
    // Used in suggestions
    // Changes what the user sees when the suggestion popup is opened
    if (typeof defaultDict[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[]{}";
        } else if (key == "\\sqrt*") {
            return "\\sqrt[]*";
        } else if (key == "\\frac") {
            return "\\frac{}{}";
        } else if (key == "\\frac*") {
            return "\\frac*{}{}";
        } else {
            return key + "{}";
        };
    } else {
        return key
    };
};


//-----------------------------------------------------//


/** Convert text **/


// Main functions

function replaceText(fullText, fullDict, mathmode) {
    // Main function, loops on letters and convert the input into characters

    // TODO: Clean it up, and maybe restructure it completely, a more 'object oriented' way to do it is perhaps better
    // Currently, the depth (\command{\command{\command{...}}}) is limited since it's hand coded. Going from this method 
    // to a basic stack that stores commands as the depth increases and convert them as the depth decreases would be much better 
    // and would finaly allow things like \sqrt{\mathbf{\mathfrak{x}}} to be possible
    // (although one could simply write \sqrt*\mathbf{\mathfrak{x}} for the same output)

    let newText = "";
    let temporaryBox = [];  // Stores characters that are in command (e.g. \int -> ['\', 'i', 'n', 't'])
    let temporaryArg = [];  // Stores characters that are in command arguments (e.g. \text{ok} -> ['o', 'k'])
    let commandInArg = [];  // Stores characters that are a command inside arguments (e.g. \dot{\equiv} -> ['\','e','q','u','i','v'])
    let trigger = false;  // true if a command has begun (e.g. input: '\' -> true)
    let arg = false;  // true if there's an argument at the end of a command (e.g. \mathbf + '{' -> true)
    let triggerInArg = false;  // true if there's a command in an argument (e.g. \overline{ + '\' -> true)
    let numberCurly = 0;  // Counts the number of curly brackets (except those used in the text like in 'S = {1,2,3}')
    let mathmodeStarter = "";  // e.g. if mathmode is started with $$, then "$$" will be mathmodeStarter
    const parentheses = ["(", ")"];
    const brackets = ["[", "]"];
    const commandStoppers = [" ", ",", "/", "-", "+", "<", ">", "|", "?"];  // parentheses and brackets also stops commands (most of the time)
    const potentialCommandStoppers = [":" , ";" , "~", ".", "!", "'", '"', "=", "%", "#"];
    const dictOutMathmode = {...lettersOutMathMode, ...textCommands, " " : "\u2710"};  // dict used if outside of mathmode
    const startMathmode = mathmode;

    // The basic 'algorithm' here is to loop on all characters of input and add them to one of the array described above based on the context.
    // Some characters stop a command to be built (like a space) and it's at this moment that the arrays are being emptied and their content 
    // will be converted by the dictionary to then be added to 'newText'
    for (let char=0; char<fullText.length; char++) {
        if (mathmode) {
    //---- ENTER MATH MODE ----//
            if (trigger) {
    //---- START OF A COMMAND ----//
                if (arg) {
    //---- ENTER COMMAND ARGUMENT ----//
                    if (triggerInArg) {
    //---- ENTER COMMAND IN A COMMAND ARGUMENT ----//
                        if (commandStoppers.includes(fullText[char])) {
                            temporaryArg.push(str(fullDict[commandInArg.join("")]));
                            temporaryArg.push(fullDict[fullText[char]]);
                            commandInArg = [];
                            triggerInArg = false;
                        } else if (potentialCommandStoppers.includes(fullText[char])) {
                            if (fullText[char-1] === "\\") {
                                temporaryArg.push(str(fullDict[commandInArg.join("") +fullText[char]]));
                            } else {
                                temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                temporaryArg.push(fullDict[fullText[char]]);
                            };
                            commandInArg = [];
                            triggerInArg = false;
                        } else if (fullText[char] === "}") {
                            if (fullText[char - 1] === "\\") {
                                temporaryArg.push(fullText[char]);
                            } else {
                                if (temporaryBox.join("").slice(0, 5) === "\\sqrt") {
                                    temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                    newText += addSymbol(fullDict["\\sqrt"](temporaryArg, temporaryBox.join("")));
                                    mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", fullDict["\\sqrt"], temporaryBox.join(""));
                                    temporaryBox = [];
                                    temporaryArg = [];
                                    arg = false;
                                    trigger = false;
                                    numberCurly += 1;
                                } else if ((temporaryBox.join("") === "\\frac") || (temporaryBox.join("") === "\\frac*")) {
                                    if (temporaryArg.indexOf("}") === -1) {
                                        temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                        temporaryArg.push(fullText[char]);
                                    } else {
                                        if ((temporaryArg.join("") === "\\frac") || (temporaryArg.join("") === "\\frac*")) {
                                            temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                            newText += addSymbol(fullDict[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                            mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", undefined, "Embedded \\frac are currently not accepted");
                                        } else {
                                            temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                            newText += addSymbol(fullDict[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                            mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", fullDict[temporaryBox.join("")], temporaryBox.join(""));
                                        };
                                        temporaryBox = [];
                                        temporaryArg = [];
                                        arg = false;
                                        trigger = false;
                                        numberCurly += 1;
                                    };
                                } else {
                                    temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                    newText += addSymbol(fullDict[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                    mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", fullDict[temporaryBox.join("")], temporaryBox.join(""));
                                    temporaryBox = [];
                                    temporaryArg = [];
                                    arg = false;
                                    trigger = false;
                                    numberCurly += 1;
                                };
                                commandInArg = [];
                                triggerInArg = false;
                            };
                        } else if (parentheses.includes(fullText[char])) {
                            if (fullText[char - 1] === "\\") {
                                temporaryArg.push(fullText[char]);
                            } else {
                                temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                temporaryArg.push(fullText[char]);
                            };
                            commandInArg = [];
                            triggerInArg = false;
                        } else if (brackets.includes(fullText[char])) {
                            if (fullText[char - 1] === "\\") {
                                temporaryArg.push(fullText[char]);
                                commandInArg = [];
                                triggerInArg = false;
                            } else {
                                if (commandInArg.join("").slice(0, 5) === "\\sqrt") {
                                    commandInArg.push(fullText[char]);
                                } else {
                                    temporaryArg.push(str(fullDict[commandInArg.join("")]));
                                    temporaryArg.push(fullText[char]);
                                    commandInArg = [];
                                    triggerInArg = false;
                                };
                            };
                        } else if (fullText[char] === "{") {
                            if (fullText[char - 1] === "\\") {
                                temporaryArg.push(fullText[char]);
                                triggerInArg = false;
                                commandInArg = [];
                            } else {
                                if ((commandInArg.join("") === "\\frac") || commandInArg.join("") === "\\frac*") {
                                    mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", undefined, "Embedded \\frac are currently not accepted. Try: ^{(y/z)}/_{x} â‡’ â½Ê¸áŸá¶»â¾/â‚“"); 
                                } else {
                                    let embCommand = embeddedCommand(commandInArg.join(""), fullText.substring(char), fullDict);
                                    for (let i in embCommand[0]) {
                                        temporaryArg.push(embCommand[0][i]);
                                    };
                                    char += embCommand[1] + 1;
                                    triggerInArg = false;
                                    commandInArg = [];
                                };
                            };
                        } else if ((fullText[char] === "\\") ||Â (fullText[char] === "^") || (fullText[char] === "_")) {
                            temporaryArg.push(str(fullDict[commandInArg.join("")]));
                            commandInArg = [fullText[char]];
                        } else {
                            commandInArg.push(fullText[char]);
                        };
    //---- EXIT COMMAND IN A COMMAND ARGUMENT ----//
                    } else {
    //---- SILL IN A COMMAND ARGUMENT ----//
                        if (fullText[char] === "}") {
                            if (temporaryBox.join("").slice(0, 5) === "\\sqrt") {
                                mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", fullDict["\\sqrt"], temporaryBox.join(""));
                                newText += addSymbol(fullDict["\\sqrt"](temporaryArg, temporaryBox.join("")));
                                temporaryBox = [];
                                temporaryArg = [];
                                arg = false;
                                trigger = false;
                                numberCurly += 1;
                            } else if ((temporaryBox.join("") === "\\frac") || (temporaryBox.join("") === "\\frac*")) {
                                if (temporaryArg.indexOf("}") === -1) {
                                    temporaryArg.push(fullText[char]);
                                } else {
                                    mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", fullDict[temporaryBox.join("")], temporaryBox.join(""));
                                    newText += addSymbol(fullDict[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                    temporaryBox = [];
                                    temporaryArg = [];
                                    arg = false;
                                    trigger = false;
                                    numberCurly += 1;
                                };
                            } else {
                                mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", fullDict[temporaryBox.join("")], temporaryBox.join(""));
                                newText += addSymbol(fullDict[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                temporaryBox = [];
                                temporaryArg = [];
                                arg = false;
                                trigger = false;
                                numberCurly += 1;
                            };
                        } else if ((fullText[char] === "\\") || (fullText[char] === "^") || (fullText[char] === "_")) {
                            triggerInArg = true;
                            commandInArg.push(fullText[char]);
                        } else {
                            temporaryArg.push(fullDict[fullText[char]]);
                        };
                    };
    //---- EXIT ARGUMENT ----//
                } else {
    //---- STILL IN A COMMAND (trigger) ----//
                    if (fullText[char] == "{") {
                        if (fullText[char - 1] === "\\") {
                            newText += addSymbol(fullDict[fullText[char]]);
                            trigger = false;
                            temporaryBox = [];
                        } else {
                            if ((typeof fullDict[temporaryBox.join("")] == "function") || (temporaryBox.join("").slice(0, 5) === "\\sqrt")) {
                                arg = true;
                                numberCurly += 1;
                            } else {
                                newText += addSymbol(str(fullDict[temporaryBox.join("")]));
                                mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                                newText += "{";
                                temporaryBox = [];
                                trigger = false;
                            };
                        };
                    } else if (fullText[char] == "}") {
                        if (fullText[char - 1] === "\\") {
                            newText += addSymbol(fullDict[fullText[char]]);
                        } else {
                            newText += addSymbol(str(fullDict[temporaryBox.join("")]));
                            mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                            newText += "}"
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else if (commandStoppers.includes(fullText[char])) {
                        if (temporaryBox.join("").replace(/\[.*\]/g, "") === "\\sqrt*") {
                            newText += addSymbol(fullDict["\\sqrt*"](undefined, temporaryBox.join("")));
                            mistakes(temporaryBox.join(""), fullDict["\\sqrt*"]);
                            newText += addSymbol(fullDict[fullText[char]]);
                        } else if (fullText[char] === "!") {
                            if (fullText[char-1] === "\\") {
                                newText += addSymbol(fullDict["\\!"]);
                            } else {
                                newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                                addSymbol(fullDict[temporaryBox.join("")]) + fullDict[fullText[char]] : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                                mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                            };
                        } else {
                            newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                            addSymbol(fullDict[temporaryBox.join("")]) + fullDict[fullText[char]] : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else if (potentialCommandStoppers.includes(fullText[char])) {
                        if (fullText[char-1] === "\\") {
                            newText += addSymbol(fullDict[temporaryBox.join("") + fullText[char]]);
                            mistakes(temporaryBox.join("") + fullText[char], fullDict[temporaryBox.join("") + fullText[char]]);
                        } else {
                            newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                            addSymbol(fullDict[temporaryBox.join("")]) + fullDict[fullText[char]] : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else if ((fullText[char] === "\\") || (fullText[char] === "^") || fullText[char] === "_") {
                        if (fullText[char - 1] === "\\") {
                            temporaryBox.push(fullText[char]);
                            newText += addSymbol(str(fullDict[temporaryBox.join("")]));
                            mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                            trigger = false;
                            temporaryBox = [];
                        } else {
                            if (temporaryBox.join("").replace(/\[.*\]/g, "") === "\\sqrt*") {
                                newText += addSymbol(fullDict["\\sqrt*"](undefined, temporaryBox.join("")));
                                mistakes(temporaryBox.join(""), fullDict["\\sqrt*"]);
                                temporaryBox = [fullText[char]];
                            } else {
                                newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                                addSymbol(fullDict[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                                mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                                temporaryBox = [fullText[char]];
                            };
                        };
                    } else if (parentheses.includes(fullText[char])) {
                        if (temporaryBox.join("").replace(/\[.*\]/g, "") === "\\sqrt*") {
                            newText += addSymbol(fullDict["\\sqrt*"](undefined, temporaryBox.join("")));
                            mistakes(temporaryBox.join(""), fullDict["\\sqrt*"]);
                            newText += addSymbol(fullDict[fullText[char]]);
                        } else {
                            newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                            addSymbol(fullDict[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                            newText += addSymbol(fullDict[fullText[char]]);
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else if (brackets.includes(fullText[char])) {
                        if (temporaryBox.join("").slice(0,5) === "\\sqrt") {
                            temporaryBox.push(fullText[char]);
                        } else {
                            if (fullText[char-1] === "\\") {
                                if ((fullText[char] === "]") && (mathmodeStarter === "\\[")) {
                                    newText += addSymbol(fullDict["\\\\"]);
                                    mathmodeStarter = "";
                                    mathmode = false;
                                } else {
                                    newText += addSymbol(str(fullDict[temporaryBox.join("") + fullText[char]]));
                                    mistakes(temporaryBox.join("") + fullText[char], fullDict[temporaryBox.join("") + fullText[char]]);
                                };
                            } else {
                                newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                                addSymbol(fullDict[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                                mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                                newText += addSymbol(fullDict[fullText[char]]);
                            };
                            temporaryBox = [];
                            trigger = false;
                        };
                    } else if (fullText[char] === "$") {
                        if (fullText[char-1] === "\\") {
                            newText += addSymbol(str(fullDict[temporaryBox.join("") + fullText[char]]));
                            mistakes(temporaryBox.join("") + fullText[char], fullDict[temporaryBox.join("") + fullText[char]]);
                        } else {
                            if (mathmodeStarter === "$") {
                                if (fullText[char-1] === "$") {
                                    newText += addSymbol(fullDict["\\\\"]);
                                    mathmodeStarter = "$$";
                                } else {
                                    newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                                    addSymbol(fullDict[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                                    mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                                    mathmodeStarter = "";
                                    mathmode = false;
                                };
                            } else if (mathmodeStarter === "$$") {
                                if (fullText[char-1] === "$") {
                                    newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                                    addSymbol(fullDict[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                                    mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                                    newText += addSymbol(fullDict["\\\\"]);
                                    mathmodeStarter = "";
                                    mathmode = false;
                                } else if (fullText[char+1] === "$") {
                                    continue;
                                } else {
                                    newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                                    addSymbol(fullDict[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                                    mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                                    newText += addSymbol(str(fullDict[fullText[char]]));
                                    mistakes(fullText[char], fullDict[fullText[char]]);
                                };
                            } else {
                                newText += !(typeof fullDict[temporaryBox.join("")] == "function") ? 
                                addSymbol(fullDict[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                                mistakes(temporaryBox.join(""), fullDict[temporaryBox.join("")]);
                                newText += addSymbol(fullDict[fullText[char]]);
                                mistakes(fullText[char], fullDict[fullText[char]]);
                            };
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else {
                        temporaryBox.push(fullText[char]);
                    };
                };
    //---- EXIT COMMAND (trigger) ----//
            } else {
    //---- STILL IN MATH MODE ----//
                if ((fullText[char] === "\\") || (fullText[char] === "^") || (fullText[char] === "_")) {
                    temporaryBox.push(fullText[char]);
                    trigger = true;
                } else if (fullText[char] === "$") {
                    if (mathmodeStarter === "$") {
                        if (fullText[char-1] === "$") {
                            newText += addSymbol(fullDict["\\\\"]);
                            mathmodeStarter = "$$";
                        } else {
                            mathmodeStarter = "";
                            mathmode = false;
                        };
                    } else if (mathmodeStarter === "$$") {
                        if (fullText[char-1] === "$") {
                            newText += addSymbol(fullDict["\\\\"]);
                            mathmodeStarter = "";
                            mathmode = false;
                        } else if (fullText[char+1] === "$") {
                            continue;
                        } else {
                            newText += addSymbol(fullDict[fullText[char]]);
                            mistakes(fullText[char], fullDict[fullText[char]]);
                        };
                    } else {
                        newText += addSymbol(fullDict[fullText[char]]);
                        mistakes(fullText[char], fullDict[fullText[char]]);
                    };
                } else {
                    newText += addSymbol(fullDict[fullText[char]]);
                    mistakes(fullText[char], fullDict[fullText[char]]);
                };
            };
    //---- EXIT MATH MODE ----//
        } else {
    //---- OUT OF MATH MODE ----//
            if (trigger) {
    //---- START OF A COMMAND ----//
                if (arg) {
    //---- ENTER COMMAND ARGUMENT ----//
                    if (fullText[char] === "}") {
                        if (fullText[char-1] === "\\") {
                            temporaryArg.push(fullText[char]);
                        } else {
                            mistakes("Out of math mode: " + temporaryBox.join("") + "{" + temporaryArg.join("") + "}", dictOutMathmode[temporaryBox.join("")], temporaryBox.join(""));
                            newText += addSymbol(dictOutMathmode[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                            temporaryBox = [];
                            temporaryArg = [];
                            arg = false;
                            trigger = false;
                            numberCurly += 1;
                        };
                    } else {
                        temporaryArg.push(fullText[char]);
                    };
    //---- EXIT COMMAND ARGUMENT ----//
                } else {
    //---- STILL IN A COMMAND (trigger) ----//
                    if (fullText[char] === "[") {
                        if (fullText[char-1] === "\\") {
                            newText += addSymbol(dictOutMathmode["\\\\"]);
                            mathmodeStarter = "\\[";
                            mathmode = true;
                        } else {
                            newText += !(typeof dictOutMathmode[temporaryBox.join("")] == "function") ? 
                            addSymbol(dictOutMathmode[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("")], temporaryBox.join(""));
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else if (fullText[char] === "$") {
                        if (fullText[char-1] === "\\") {
                            newText += addSymbol(str(dictOutMathmode[temporaryBox.join("") + fullText[char]]));
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("") + fullText[char]], temporaryBox.join("") + fullText[char]);
                        } else {
                            newText += !(typeof dictOutMathmode[temporaryBox.join("")] == "function") ? 
                            addSymbol(dictOutMathmode[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("")], temporaryBox.join(""));
                            mathmodeStarter = "$";
                            mathmode = true;
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else if (commandStoppers.includes(fullText[char]) || parentheses.includes(fullText[char]) || (fullText[char] === "]") || (fullText[char] === "}")) {
                        if (fullText[char-1] === "\\") {
                            newText += addSymbol(dictOutMathmode[temporaryBox.join("") + fullText[char]]);
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("") + fullText[char]], temporaryBox.join("") + fullText[char]);
                        } else {
                            newText += !(typeof dictOutMathmode[temporaryBox.join("")] == "function") ? 
                            addSymbol(dictOutMathmode[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("")], temporaryBox.join(""));
                            newText += addSymbol(dictOutMathmode[fullText[char]]);
                            mistakes("Out of math mode", dictOutMathmode[fullText[char]], fullText[char]);
                        };
                        temporaryBox = [];
                        trigger = false;
                    } else if (potentialCommandStoppers.includes(fullText[char])) {
                        if (fullText[char-1] === "\\") {
                            temporaryBox.push(fullText[char]);
                        } else {
                            newText += !(typeof dictOutMathmode[temporaryBox.join("")] == "function") ? 
                            addSymbol(dictOutMathmode[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("")], temporaryBox.join(""));
                            newText += addSymbol(dictOutMathmode[fullText[char]]);
                            mistakes("Out of math mode", dictOutMathmode[fullText[char]], fullText[char]);
                            temporaryBox = [];
                            trigger = false;
                        };
                    } else if (fullText[char] === "{") {
                        if (fullText[char-1] === "\\") {
                            newText += addSymbol(str(dictOutMathmode[temporaryBox.join("") + fullText[char]]));
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("") + fullText[char]], temporaryBox.join("") + fullText[char]);
                            temporaryBox = [];
                            trigger = false;
                        } else {
                            arg = true;
                            numberCurly += 1;
                        };
                    } else if (fullText[char] === "\\") {
                        if (fullText[char-1] === "\\") {
                            newText += addSymbol(str(dictOutMathmode["\\\\"]));
                            mistakes("Out of math mode", dictOutMathmode["\\\\"], "\\\\");
                            temporaryBox = [];
                            trigger = false;
                        } else {
                            newText += addSymbol(str(dictOutMathmode[temporaryBox.join("")]));
                            mistakes("Out of math mode", dictOutMathmode[temporaryBox.join("")], temporaryBox.join(""));
                            temporaryBox = ["\\"];
                        };
                    } else {
                        temporaryBox.push(fullText[char]);
                    };
                };
    //---- EXIT COMMAND (trigger) ----//
            } else {
    //---- NO MATH MODE, NO COMMAND ----//
                if (fullText[char] === "$") {
                    mathmodeStarter = "$";
                    mathmode = true;
                } else if (fullText[char] === "\\") {
                    temporaryBox.push(fullText[char]);
                    trigger = true;
                } else {
                    newText += addSymbol(dictOutMathmode[fullText[char]]);
                    mistakes("Out of math mode", dictOutMathmode[fullText[char]], fullText[char]);
                };
            };
        };
    };
    if (numberCurly % 2 !== 0) {
        mistakes("Missing curly brackets { }", undefined);
    };
    if (!startMathmode && mathmode) {
        const comToStop = (mathmodeStarter === "\\[") ? "\\]" : mathmodeStarter;
        mistakes("Math mode wasn't closed", undefined, "Missing '" + comToStop + "' ");
    };
    return newText;
};

function replaceLetters(letters, dict, initialCommand, checkMistakes=true) {
    // Used by a lot of functions to convert every letter in a string of characters
    let newtext = [];
    for (let c in letters) {
        newtext.push(addSymbol(dict[letters[c]]));
        if (checkMistakes) {
            mistakes(initialCommand + "{" + letters.join("") + "}", dict[letters[c]], (letters[c] !== errSymbol) ? letters[c] : "A symbol does not exist or can't be shown");
        };
    };
    return newtext;
};


// Used by main functions

const combineSymbols = (arg, initialCommand, symbol, forTwo=undefined) => {
    // Appends a 'combining symbol' to a regular symbol to create a new one (e.g. 'e' + 'Â´' -> Ã©)
    // N.B. errSymbol  ->  error symbol
    let textComb = [];
    if ((arg.length === 2) && (forTwo !== undefined)) {
        textComb.push(arg[0] + forTwo + arg[1]);
        mistakes(initialCommand + "{" + errSymbol + arg[1] + "}", arg[0], "Argument doesn't exist");
        mistakes(initialCommand + "{" + arg[0] + errSymbol + "}", arg[1], "Argument doesn't exist");
    } else {
        let err = [];
        for (let c in arg) {
            if (arg[c] !== undefined) {
                textComb.push(arg[c] + symbol);
                err.push(arg[c]);
            } else {
                textComb.push(errSymbol);
                err.push(errSymbol);
            };
        };
        if (err.includes(errSymbol)) {
            mistakes(initialCommand + "{" + err.join("") + "}", undefined, "Argument doesn't exist")
        };
    };
    return textComb;
};

function embeddedCommand(command, endOfText, fullDict) {
    // Is called if there is a command as an argument of a command

    // TODO: Should be rewritten to be much more flexible, there's no reason to not be able to have embedded \sqrt, for instance
    let args = [];
    endOfText = endOfText.substring(1);
    for (let c in endOfText) {
        if (endOfText[c] === "}") {
            if (endOfText[c - 1] === "\\") {
                args.splice(-1, 1);
                args.push(endOfText[c]);
            } else {
                if (command.slice(0, 5) === "\\sqrt") {
                    mistakes("Embedded \\sqrt are not best practice, use '\\sqrt[n]* (\\sqrt[k]* x)' instead of '\\sqrt[n]{\\sqrt[k]{x}}'", undefined, "â¿âˆš(áµâˆšğ‘¥)");
                    return [addSymbol(fullDict["\\sqrt"](args, command), true), parseInt(c)];
                } else {
                    mistakes(command + "{" + args.join("") + "}", fullDict[command](args, command));
                    return [addSymbol(fullDict[command](args, command), true), parseInt(c)];
                };
            };
        } else if (endOfText[c] === "{") {
            if (endOfText[c-1] !== "\\") {
                mistakes("Embedded commands (depth exceeded)", undefined);
                return [addSymbol(fullDict[command](args, command), true), parseInt(c)];
            } else {
                args.push(fullDict[endOfText[c]]);
            };
        } else {
            args.push(fullDict[endOfText[c]]);
        };
    };
};

function addSymbol(command, keepArray=false) {
    // Return the command if it's defined, if not it returns a bold "err" with two "x" under it
    if ((typeof command == "object") && !(keepArray)) {
        // Changes an array of characters into a string
        command = command.join("");
    };
    return (command !== undefined) ? command : errSymbol;
};

function addSymbolArray(args, command, checkMistakes=true) {
    // Differs from the function above as it returns an array instead of a string
    let output = "";
    for (let i in args) {
        output += (args[i] !== undefined) ? args[i] : errSymbol;
        if (checkMistakes) {
            mistakes(command, ((args[i] === errSymbol) ||Â (args[i] === undefined)) ? undefined : args[i], "A symbol does not exist or can't be shown");
        };
    };
    return output;
};

function str(command) {
    // Make sure the command is a string
    return (typeof command === "string") ? command : errSymbol;
};


//-----------------------------------------------------//

/** Check mistakes **/

function mistakes(textInput, textOutput, letter="") {
    // Writes every errors in a box, so it's easier for the user to find them

    const text = "\u{1D404}\u{1D42B}\u{1D42B}\u{1D428}\u{1D42B}\u{1D42C}: \r\n";  // "Errors" in bold
    if (textOutput === undefined) {
        if (letter != "") {
            if (letter !== errSymbol) {  // Only add to errorsList once
                if (letter.includes("\u2710")) {  // i.e. Spaces
                    if (textInput.substring(0,5) == "\\text") {
                        errorsList += spaceCommand(textInput + " \u2192 Spaces are kept inside '" + textInput.replace(/{.*}/g, "") + "{}', no need for a spacing command") + "\r\n";
                    } else if ((textInput[0] === "^") || (textInput[0] === "_") || (textInput.substring(0,5) == "\\frac")) {
                        const initialSpaceCommand = ["\\:", "\\;", "\\quad", "\\qquad"];
                        errorsList += spaceCommand(textInput + " \u2192 Replace '" + initialSpaceCommand[letter.length-1] + "' by '\\hspace{" + letter.length + "}'") + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                } else {
                    const subSupChar = Object.values(Superscript).concat(Object.values(Subscript)).filter(x => {return x !== "\u2710";});  // Makes sure that there are no spaces that sneaks in
                    if (subSupChar.includes(letter)) {
                        const argPos = Object.values(Superscript).includes(letter) ? "superscript" : "subscript";
                        const commandPos = (textInput[0] === "^") ? "superscript" : "subscript";
                        errorsList += spaceCommand(textInput + " \u2192 Can't put a " + argPos + " (" + letter + ") in a " + commandPos + " position") + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                };
            };
        } else {
            if ((textInput[0] === "^") || (textInput[0] === "_")) {
                if (textInput.indexOf(" needs an argument.") !== -1) {
                    const example = (textInput[0] === "^") ? "Â¹" : "â‚";
                    errorsList += "For '" + textInput[0] + "' alone: \\" + textInput[0] + " \u2192 " + textInput[0] + 
                    "  |  To use '" + textInput[0] + "' as a command: " + textInput[0] + "{1} \u2192 " + example + "\r\n";
                } else {
                    if (textInput[1] === "{") {
                        errorsList += '"' + textInput + '" \u2192 ' + "Argument does not exists" + '\r\n';
                    } else {
                        errorsList += '"' + textInput + '" \u2192 ' + "try: " + textInput[0] + "{" + textInput.slice(1) + "}" + '\r\n';
                    };
                };
            } else {
                errorsList += '"' + textInput + '" \r\n';
            };
        };
    };
    if (errorsList.length > 0) {
        mistakesBox.textContent = text + errorsList;
    };
    return errSymbol;
};


//-----------------------------------------------------//

/** Matrix document class **/

function matrix(text) {
    // If the keyword !matrix is used as the first word of the input text, this function is called
    // Converts arrays into a matrix (i.e. !matrix [a,b,c][1,2,3] will be converted to a matrix 2x3)
    text = text.replace(/ /g, "");
    let matrixText = "";
    let i, x;
    let cpt = 0;
    let rceil = 0;
    let lceil = 0;
    let lfloor = 0;
    let rfloor = 0;

    for (x in text) {
        if (text[x] == "[" || text[x] == "]") {
            cpt += 1;
        };
    };
    if (cpt == 2) {
        // vector (ie single line matrix)
        matrixText = text.replace(/ /g, "");
        matrixText = matrixText.replace(/\[/g, "[ ");
        matrixText = matrixText.replace(/\]/g, " ]");
        matrixText = matrixText.replace(/,/g, "\u2710");
        return spaceCommand(matrixText);
    } else {
        for (i in text) {
            if (text[i] == "[" && rceil == 0) {
                matrixText += "\u23A1 ";
                rceil += 1;
            } else if (text[i] == "]" && lceil == 0) {
                matrixText += " \u23A4\u000A";
                lceil += 1;
            } else if (text[i] == "]") {
                matrixText += " \u23A5\u000A";
            } else if (text[i] == "[") {
                matrixText += "\u23A2 ";
            } else {
                matrixText += text[i];
            }
        };
        for (let n = matrixText.length; n > 0; n--) {
            if (matrixText[n] == "\u23A5" && n > rfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A6";
                matrixText[n+1] = "";  // removes "\u000A" since it's the last line
                matrixText = matrixText.join("");
                rfloor = n;
            } else if (matrixText[n] == "\u23A2" && n > lfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A3";
                matrixText = matrixText.join("");
                lfloor = n;
            };
        };
    };
    matrixText = matrixCols(matrixText);  // Adjusts columns width
    matrixText = matrixText.replace(/,/g, " ");  // Add spaces between characters
    if ((cpt % 2 != 0) || (cpt == 0)) {
        matrixText = "";
        mistakes('Wrong arguments given" \r\n \r\nExample: "!matrix [a,b,c] [d,e,f] [1,2,3]', undefined);
    };
    return spaceCommand(matrixText);
};

function matrixCols(matrix) {
    // Adjusts columns length for !matrix package
    // So, if the input is [100,10,1][0,0,0], the output should still be a 2x3 matrix with the elements aligned
    let positionLength = 0;
    let posLengths = [];
    let matrixPositions = [];
    let matrixPos = 0;
    let realPositions = [];
    for (let i in matrix) {
        if (matrix[i] == ",") {
            matrixPositions.push(matrixPos);
            matrixPos += 1;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-1);
        } else if ((matrix[i] == "\u23A4") || (matrix[i] == "\u23A5") || (matrix[i] == "\u23A6")) {  // right bracket
            matrixPositions.push(matrixPos);
            matrixPos = 0;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-2);
        } else if ((matrix[i] == "\u23A1") || (matrix[i] == "\u23A2") || (matrix[i] == "\u23A3") || (matrix[i] == " ") || (matrix[i] == "\u000A")) {  // left bracket and spaces
            continue;
        } else {
            positionLength += 1;
        };
    };
    // Add spaces to adjust columns length
    let spacesAdded = 1;
    for (let i in posLengths) {
        for (let n in matrixPositions) {
            if (matrixPositions[i] == matrixPositions[n]) {
                matrix = matrix.split("");
                while (posLengths[i] < posLengths[n]) {
                    matrix.splice(realPositions[i] + spacesAdded, 0, " ");
                    posLengths[i] += 1;
                    spacesAdded += 1;
                };
                matrix = matrix.join("");
            };
        };
    };
    return matrix;
};


//-----------------------------------------------------//

/** Automatic spacing **/

function spaceCommand(text) {
    // Add spaces ("\:" command)
    // Internally, spaces that are kept even if 'Adjust spaces' is on are represented as \u2710
    // this function changes them back to spaces
    text = text.replace(/\u2710/g, " ")

    // Also, it removes a space around the command \! (and the command itself)
            .replace(/\u270E /g, "")
            .replace(/ \u270E/g, "")
            .replace(/\u270E/g, "");
    return text;
};

function adjustSpacesCommon(input, symbolSpaced, conditionalSpaces) {
    // Removes spaces and add some depending on surrounding symbols
    // Used if 'Adjust space' is on

    /* 
        TODO: Spacing around symbols like '+' should depend of context
        For instance f(y+2) should return f(y+2), but 3xÂ²+4y should return 3xÂ² + 4y 
        Also, a_{i}-x should return a_{i} - x, but \sum_{i}-x should return \sum_{i}-x (as in \sum_{i}(-x) or -\sum_{i}x)
        Again, it should take the context in consideration
    */
    input = input.slice(0, input.length - 1)  // Since the last char is a space
    if ((spacesButton.checked == true) && (input.length > 2)) {
        const noSpaceSymbols = Object.values(Subscript).concat(Object.values(Above), Object.values(Below)).filter(x => {return x !== "\u2710";});
        // noSpaceSymbols is a list of all the symbols (subscript and combined symbol, without spaces) that delay a space to be added.
        // For instance, the spaces in 'x \equiv_{2} 0 \def x \equiv 0 (mod 2)' should be kept the same and therefore 'delay' the space
        // to be added from \equiv because of the subscript.
        const spacedChar = characters.concat(noSpaceSymbols, Object.values(Superscript));  // Add space around 'conditionalSpaces' if the previous symbol is in spacedChar
        let output = "";
        input = input.replace(/ /g, "");
        let delayedSpace = false;
        let spaceStored = [];
        for (let i in input) {
            delayedSpace = noSpaceSymbols.includes(input[parseInt(i)+1]);
            if (symbolSpaced.includes(input[i])) {
                if ((output[output.length - 1] !== " ") &&Â (output[output.length - 1] !== undefined)) {
                    if (delayedSpace) {
                        output += " " + input[i];
                        spaceStored.push(" ");
                    } else {
                        output += " " + input[i] + " ";
                    }
                } else {
                    if (delayedSpace) {
                        output += input[i];
                        spaceStored.push(" ");
                    } else {
                        output += input[i] + " ";
                    };
                };
            } else if (conditionalSpaces.includes(input[i])) {
                if ((output[output.length - 1] !== " ") &&Â (output[output.length - 1] !== undefined) && (spacedChar.includes(output[output.length - 1]))) {
                    if (delayedSpace) {
                        output += " " + input[i];
                    } else {
                        output += " " + input[i] + " ";
                    };
                } else {
                    output += input[i];
                };
            } else {
                if (delayedSpace) {
                    output += input[i];
                } else {
                    if (spaceStored.length >= 1) {
                        output += input[i] + " ";
                        spaceStored = [];
                    }
                    else {
                        output += input[i];
                    };
                };
            };
        };
        return spaceCommand(output);
    } else {
        return spaceCommand(input);
    };
};

function adjustSpaces(input) {
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    const symbolSpaced = ["=", "\u003D", "\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
                "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
                "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
                "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
                "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
                "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2261", "\u2A67", "\u2263",
                "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
                "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
                "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2225",
                "\u2226", "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u2250",
                "\u2A66", "\u00D7", "\u22CA", "\u22C9", "\u225D", "\u2254", "\u2255"];
    const conditionalSpaces = ["\u002B", "\u2212", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};

function adjustSpaceChem(input) {
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    const symbolSpaced = ["\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
            "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
            "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
            "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
            "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
            "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2A67", "\u2250", "\u2A66",
            "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
            "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
            "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2225",
            "\u2226", "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u00D7", 
            "\u22CA", "\u22C9", "\u225D", "\u2254", "\u2255"];
    const conditionalSpaces = ["\u002B", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};


//-----------------------------------------------------//

/** Main **/

function convert(fullText) {
    // Takes text and convert it based on the documentclass (or package)
    const firstWord = fullText.split(" ")[0];
    let fullDict;
    if (firstWord === "!chem") {
        // Chemistry package, differs in the automatic conversion of letters and spacing adjustments
        fullDict = makeDict(firstWord);
        fullText = fullText.replace("!chem", "");
        fullText = replaceText(fullText, fullDict, changeModeButton.checked);
        fullText = adjustSpaceChem(fullText);
    } else if (firstWord === "!matrix") {
        // Matrix package, the input should be of the form [a,b,c][d,e,f]
        fullDict = makeDict(firstWord);
        fullText = fullText.replace("!matrix", "");
        fullText = replaceText(fullText, fullDict, true);
        fullText = matrix(fullText);
        if (changeFontButton.checked) {
            mistakes("!matrix", undefined, "Works better with 'Mathematical font' unchecked");
        };
    } else {
        // Default package
        fullDict = makeDict("default");
        fullText = replaceText(fullText, fullDict, changeModeButton.checked);
        fullText = adjustSpaces(fullText);
    };
    return fullText;
};

function makeDict(documentClass) {
    // Returns the full dictionary (in mathmode) with all the commands, letters, etc. based on documentclass and font choice
    const greek = (changeFontButton.checked) ? stdGreek : noStyleGreek;
    let letters;  // lettersMath or lettersNoFont
    if (documentClass === "!chem") {
        letters = lettersNoFont;  // Works better to "draw" molecules with lewis notation
    } else if (documentClass === "!matrix") {
        letters = (changeFontButton.checked) ? lettersMath : lettersNoFont;
    } else {  // documentClass === "default"
        letters = (changeFontButton.checked) ? lettersMath : lettersNoFont;
    };
    return {...mathDictionary, ...greek, ...letters};
};

function main() {
    // Takes the original text (input) and outputs the new one, with the converted symbols

    mistakesBox.textContent = "";  // Starts with an empty box for errors
    errorsList = "";  // Makes sure it starts empty

    let fullText = textIn.value;
    fullText = fullText.replace(/\u000A/g, " ");  // Cancels the line skipped by pressing "enter", use "\\" instead

    fullText = convert(fullText + " ");

    textOut.value = fullText;
    textOut.disabled = false;
};