/*
    The main purpose of this program is to take a text as input (mostly LaTeX commands), 
    to convert them into the desired symbol (UTF) and finally to display them so they can 
    be copied and sent via Messenger, Instagram, Twitter, etc.
*/



/// Global variables ///


// Functions to convert text

function replaceLetters(letters, dict, initialCommand, checkMistakes=true) {
    let newtext = [];
    for (let c in letters) {
        newtext.push(addSymbol(dict[letters[c]]));
        if (checkMistakes) {
            mistakes(initialCommand + "{" + letters.join("") + "}", dict[letters[c]], letters[c]);
        };
    };
    return newtext;
};

const mathbb = (arg, initialCommand) => {
    const symbols = {
        "A" : "\u{1D538}",
        "B" : "\u{1D539}",
        "C" : "\u2102",
        "D" : "\u{1D53B}",
        "E" : "\u{1D53C}",
        "F" : "\u{1D53D}",
        "G" : "\u{1D53E}",
        "H" : "\u210D",
        "I" : "\u{1D540}",
        "J" : "\u{1D541}",
        "K" : "\u{1D542}",
        "L" : "\u{1D543}",
        "M" : "\u{1D544}",
        "N" : "\u2115",
        "O" : "\u{1D546}",
        "P" : "\u2119",
        "Q" : "\u211A",
        "R" : "\u211D",
        "S" : "\u{1D54A}",
        "T" : "\u{1D54B}",
        "U" : "\u{1D54C}",
        "V" : "\u{1D54D}",
        "W" : "\u{1D54E}",
        "X" : "\u{1D54F}",
        "Y" : "\u{1D550}",
        "Z" : "\u2124",
        "a" : "\u{1D552}",
        "b" : "\u{1D553}",
        "c" : "\u{1D554}",
        "d" : "\u{1D555}",
        "e" : "\u{1D556}",
        "f" : "\u{1D557}",
        "g" : "\u{1D558}",
        "h" : "\u{1D559}",
        "i" : "\u{1D55A}",
        "j" : "\u{1D55B}",
        "k" : "\u{1D55C}",
        "l" : "\u{1D55D}",
        "m" : "\u{1D55E}",
        "n" : "\u{1D55F}",
        "o" : "\u{1D560}",
        "p" : "\u{1D561}",
        "q" : "\u{1D562}",
        "r" : "\u{1D563}",
        "s" : "\u{1D564}",
        "t" : "\u{1D565}",
        "u" : "\u{1D566}",
        "v" : "\u{1D567}",
        "w" : "\u{1D568}",
        "x" : "\u{1D569}",
        "y" : "\u{1D56A}",
        "z" : "\u{1D56B}",

        "𝐴" : "\u{1D538}",
        "𝐵" : "\u{1D539}",
        "𝐶" : "\u2102",
        "𝐷" : "\u{1D53B}",
        "𝐸" : "\u{1D53C}",
        "𝐹" : "\u{1D53D}",
        "𝐺" : "\u{1D53E}",
        "𝐻" : "\u210D",
        "𝐼" : "\u{1D540}",
        "𝐽" : "\u{1D541}",
        "𝐾" : "\u{1D542}",
        "𝐿" : "\u{1D543}",
        "𝑀" : "\u{1D544}",
        "𝑁" : "\u2115",
        "𝑂" : "\u{1D546}",
        "𝑃" : "\u2119",
        "𝑄" : "\u211A",
        "𝑅" : "\u211D",
        "𝑆" : "\u{1D54A}",
        "𝑇" : "\u{1D54B}",
        "𝑈" : "\u{1D54C}",
        "𝑉" : "\u{1D54D}",
        "𝑊" : "\u{1D54E}",
        "𝑋" : "\u{1D54F}",
        "𝑌" : "\u{1D550}",
        "𝑍" : "\u2124",
        "𝑎" : "\u{1D552}",
        "𝑏" : "\u{1D553}",
        "𝑐" : "\u{1D554}",
        "𝑑" : "\u{1D555}",
        "𝑒" : "\u{1D556}",
        "𝑓" : "\u{1D557}",
        "𝑔" : "\u{1D558}",
        "ℎ" : "\u{1D559}",
        "𝑖" : "\u{1D55A}",
        "𝑗" : "\u{1D55B}",
        "𝑘" : "\u{1D55C}",
        "𝑙" : "\u{1D55D}",
        "𝑚" : "\u{1D55E}",
        "𝑛" : "\u{1D55F}",
        "𝑜" : "\u{1D560}",
        "𝑝" : "\u{1D561}",
        "𝑞" : "\u{1D562}",
        "𝑟" : "\u{1D563}",
        "𝑠" : "\u{1D564}",
        "𝑡" : "\u{1D565}",
        "𝑢" : "\u{1D566}",
        "𝑣" : "\u{1D567}",
        "𝑤" : "\u{1D568}",
        "𝑥" : "\u{1D569}",
        "𝑦" : "\u{1D56A}",
        "𝑧" : "\u{1D56B}",
        
        "𝜋" : "\u213C",
        "Π" : "\u213F",
        "𝛾" : "\u213D",
        "𝛤" : "\u213E",
        "Σ" : "\u2140",

        "0" : "\u{1D7D8}",
        "1" : "\u{1D7D9}",
        "2" : "\u{1D7DA}",
        "3" : "\u{1D7DB}",
        "4" : "\u{1D7DC}",
        "5" : "\u{1D7DD}",
        "6" : "\u{1D7DE}",
        "7" : "\u{1D7DF}",
        "8" : "\u{1D7E0}",
        "9" : "\u{1D7E1}",

        "(" : "⦅",
        "{" : "⦃",
        "[" : "⟦",
        "]" : "⟧",
        "}" : "⦄",
        ")" : "⦆",
        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathbf = (arg, initialCommand) => {
    const symbols = {
        "A" : "\u{1D468}",
        "a" : "\u{1D482}",
        "B" : "\u{1D469}",
        "b" : "\u{1D483}",
        "C" : "\u{1D46A}",
        "c" : "\u{1D484}",
        "D" : "\u{1D46B}",
        "d" : "\u{1D485}",
        "E" : "\u{1D46C}",
        "e" : "\u{1D486}",
        "F" : "\u{1D46D}",
        "f" : "\u{1D487}",
        "G" : "\u{1D46E}",
        "g" : "\u{1D488}",
        "H" : "\u{1D46F}",
        "h" : "\u{1D489}",
        "I" : "\u{1D470}",
        "i" : "\u{1D48A}",
        "J" : "\u{1D471}",
        "j" : "\u{1D48B}",
        "K" : "\u{1D472}",
        "k" : "\u{1D48C}",
        "L" : "\u{1D473}",
        "l" : "\u{1D48D}",
        "M" : "\u{1D474}",
        "m" : "\u{1D48E}",
        "N" : "\u{1D475}",
        "n" : "\u{1D48F}",
        "O" : "\u{1D476}",
        "o" : "\u{1D490}",
        "P" : "\u{1D477}",
        "p" : "\u{1D491}",
        "Q" : "\u{1D478}",
        "q" : "\u{1D492}",
        "R" : "\u{1D479}",
        "r" : "\u{1D493}",
        "S" : "\u{1D47A}",
        "s" : "\u{1D494}",
        "T" : "\u{1D47B}",
        "t" : "\u{1D495}",
        "U" : "\u{1D47C}",
        "u" : "\u{1D496}",
        "V" : "\u{1D47D}",
        "v" : "\u{1D497}",
        "W" : "\u{1D47E}",
        "w" : "\u{1D498}",
        "X" : "\u{1D47F}",
        "x" : "\u{1D499}",
        "Y" : "\u{1D480}",
        "y" : "\u{1D49A}",
        "Z" : "\u{1D481}",
        "z" : "\u{1D49B}",

        "𝐴" : "\u{1D468}",
        "𝑎" : "\u{1D482}",
        "𝐵" : "\u{1D469}",
        "𝑏" : "\u{1D483}",
        "𝐶" : "\u{1D46A}",
        "𝑐" : "\u{1D484}",
        "𝐷" : "\u{1D46B}",
        "𝑑" : "\u{1D485}",
        "𝐸" : "\u{1D46C}",
        "𝑒" : "\u{1D486}",
        "𝐹" : "\u{1D46D}",
        "𝑓" : "\u{1D487}",
        "𝐺" : "\u{1D46E}",
        "𝑔" : "\u{1D488}",
        "𝐻" : "\u{1D46F}",
        "ℎ" : "\u{1D489}",
        "𝐼" : "\u{1D470}",
        "𝑖" : "\u{1D48A}",
        "𝐽" : "\u{1D471}",
        "𝑗" : "\u{1D48B}",
        "𝐾" : "\u{1D472}",
        "𝑘" : "\u{1D48C}",
        "𝐿" : "\u{1D473}",
        "𝑙" : "\u{1D48D}",
        "𝑀" : "\u{1D474}",
        "𝑚" : "\u{1D48E}",
        "𝑁" : "\u{1D475}",
        "𝑛" : "\u{1D48F}",
        "𝑂" : "\u{1D476}",
        "𝑜" : "\u{1D490}",
        "𝑃" : "\u{1D477}",
        "𝑝" : "\u{1D491}",
        "𝑄" : "\u{1D478}",
        "𝑞" : "\u{1D492}",
        "𝑅" : "\u{1D479}",
        "𝑟" : "\u{1D493}",
        "𝑆" : "\u{1D47A}",
        "𝑠" : "\u{1D494}",
        "𝑇" : "\u{1D47B}",
        "𝑡" : "\u{1D495}",
        "𝑈" : "\u{1D47C}",
        "𝑢" : "\u{1D496}",
        "𝑉" : "\u{1D47D}",
        "𝑣" : "\u{1D497}",
        "𝑊" : "\u{1D47E}",
        "𝑤" : "\u{1D498}",
        "𝑋" : "\u{1D47F}",
        "𝑥" : "\u{1D499}",
        "𝑌" : "\u{1D480}",
        "𝑦" : "\u{1D49A}",
        "𝑍" : "\u{1D481}",
        "𝑧" : "\u{1D49B}",

        "0" : "\u{1D7CE}",
        "1" : "\u{1D7CF}",
        "2" : "\u{1D7D0}",
        "3" : "\u{1D7D1}",
        "4" : "\u{1D7D2}",
        "5" : "\u{1D7D3}",
        "6" : "\u{1D7D4}",
        "7" : "\u{1D7D5}",
        "8" : "\u{1D7D6}",
        "9" : "\u{1D7D7}",

        "∂" : "\u{1D789}",

	    // Greek
        "𝛢" : "\u{1D71C}",
        "𝛼" : "\u{1D736}",
        "𝛣" : "\u{1D71D}",
        "𝛽" : "\u{1D737}",
        "𝛤" : "\u{1D71E}",
        "𝛾" : "\u{1D738}",
        "Δ" : "\u{1D6AB}",
        "δ" : "\u{1D6C5}",
        "𝛦" : "\u{1D720}",
        "ϵ" : "\u{1D6DC}",
        "ε" : "\u{1D6C6}",
        "𝛧" : "\u{1D721}",
        "𝜁" : "\u{1D73B}",
        "𝛨" : "\u{1D722}",
        "𝜂" : "\u{1D73C}",
        "Θ" : "\u{1D6BD}",
        "𝜃" : "\u{1D73D}",
        "ϑ" : "\u{1D6DD}",
        "𝛪" : "\u{1D724}",
        "𝜄" : "\u{1D73E}",
        "𝛫" : "\u{1D725}",
        "𝜅" : "\u{1D73F}",
        "𝜘" : "\u{1D752}",
        "Λ" : "\u{1D6B2}",
        "λ" : "\u{1D6CC}",
        "𝛭" : "\u{1D727}",
        "𝜇" : "\u{1D741}",
        "𝛮" : "\u{1D728}",
        "𝜈" : "\u{1D742}",
        "Ξ" : "\u{1D6B5}",
        "𝜉" : "\u{1D743}",
        "𝛰" : "\u{1D72A}",
        "𝜊" : "\u{1D744}",
        "Π" : "\u{1D6B7}",
        "𝜋" : "\u{1D745}",
        "𝜛" : "\u{1D755}",
        "𝛲" : "\u{1D72C}",
        "𝜌" : "\u{1D746}",
        "ϱ" : "\u{1D6E0}",
        "Σ" : "\u{1D6BA}",
        "σ" : "\u{1D6D4}",
        "ς" : "\u{1D6D3}",
        "𝛵" : "\u{1D72F}",
        "𝜏" : "\u{1D749}",
        "𝛶" : "\u{1D730}",
        "𝜐" : "\u{1D74A}",
        "Φ" : "\u{1D6BD}",
        "𝜙" : "\u{1D753}",
        "𝜑" : "\u{1D74B}",
        "𝛸" : "\u{1D732}",
        "𝜒" : "\u{1D74C}",
        "𝛹" : "\u{1D733}",
        "𝜓" : "\u{1D74D}",
        "Ω" : "\u{1D6C0}",
        "𝜔" : "\u{1D74E}",

        // mathcal
        "𝒜" : "\u{1D4D0}",
        "𝒶" : "\u{1D4EA}",
        "ℬ" : "\u{1D4D1}",
        "𝒷" : "\u{1D4EB}",
        "𝒞" : "\u{1D4D2}",
        "𝒸" : "\u{1D4EC}",
        "𝒟" : "\u{1D4D3}",
        "𝒹" : "\u{1D4ED}",
        "ℰ" : "\u{1D4D4}",
        "ℯ" : "\u{1D4EE}",
        "ℱ" : "\u{1D4D5}",
        "𝒻" : "\u{1D4EF}",
        "𝒢" : "\u{1D4D6}",
        "ℊ" : "\u{1D4F0}",
        "ℋ" : "\u{1D4D7}",
        "𝒽" : "\u{1D4F1}",
        "ℐ" : "\u{1D4D8}",
        "𝒾" : "\u{1D4F2}",
        "𝒥" : "\u{1D4D9}",
        "𝒿" : "\u{1D4F3}",
        "𝒦" : "\u{1D4DA}",
        "𝓀" : "\u{1D4F4}",
        "ℒ" : "\u{1D4DB}",
        "𝓁" : "\u{1D4F5}",
        "ℳ" : "\u{1D4DC}",
        "𝓂" : "\u{1D4F6}",
        "𝒩" : "\u{1D4DD}",
        "𝓃" : "\u{1D4F7}",
        "𝒪" : "\u{1D4DE}",
        "ℴ" : "\u{1D4F8}",
        "𝒫" : "\u{1D4DF}",
        "𝓅" : "\u{1D4F9}",
        "𝒬" : "\u{1D4E0}",
        "𝓆" : "\u{1D4FA}",
        "ℛ" : "\u{1D4E1}",
        "𝓇" : "\u{1D4FB}",
        "𝒮" : "\u{1D4E2}",
        "𝓈" : "\u{1D4FC}",
        "𝒯" : "\u{1D4E3}",
        "𝓉" : "\u{1D4FD}",
        "𝒰" : "\u{1D4E4}",
        "𝓊" : "\u{1D4FE}",
        "𝒱" : "\u{1D4E5}",
        "𝓋" : "\u{1D4FF}",
        "𝒲" : "\u{1D4E6}",
        "𝓌" : "\u{1D500}",
        "𝒳" : "\u{1D4E7}",
        "𝓍" : "\u{1D501}",
        "𝒴" : "\u{1D4E8}",
        "𝓎" : "\u{1D502}",
        "𝒵" : "\u{1D4E9}",
        "𝓏" : "\u{1D503}",

        // mathfrak
        "𝔄" : "\u{1D56C}",
        "𝔞" : "\u{1D586}",
        "𝔅" : "\u{1D56D}",
        "𝔟" : "\u{1D587}",
        "ℭ" : "\u{1D56E}",
        "𝔠" : "\u{1D588}",
        "𝔇" : "\u{1D56F}",
        "𝔡" : "\u{1D589}",
        "𝔈" : "\u{1D570}",
        "𝔢" : "\u{1D58A}",
        "𝔉" : "\u{1D571}",
        "𝔣" : "\u{1D58B}",
        "𝔊" : "\u{1D572}",
        "𝔤" : "\u{1D58C}",
        "ℌ" : "\u{1D573}",
        "𝔥" : "\u{1D58D}",
        "ℑ" : "\u{1D574}",
        "𝔦" : "\u{1D58E}",
        "𝔍" : "\u{1D575}",
        "𝔧" : "\u{1D58F}",
        "𝔎" : "\u{1D576}",
        "𝔨" : "\u{1D590}",
        "𝔏" : "\u{1D577}",
        "𝔩" : "\u{1D591}",
        "𝔐" : "\u{1D578}",
        "𝔪" : "\u{1D592}",
        "𝔑" : "\u{1D579}",
        "𝔫" : "\u{1D593}",
        "𝔒" : "\u{1D57A}",
        "𝔬" : "\u{1D594}",
        "𝔓" : "\u{1D57B}",
        "𝔭" : "\u{1D595}",
        "𝔔" : "\u{1D57C}",
        "𝔮" : "\u{1D596}",
        "ℜ" : "\u{1D57D}",
        "𝔯" : "\u{1D597}",
        "𝔖" : "\u{1D57E}",
        "𝔰" : "\u{1D598}",
        "𝔗" : "\u{1D57F}",
        "𝔱" : "\u{1D599}",
        "𝔘" : "\u{1D580}",
        "𝔲" : "\u{1D59A}",
        "𝔙" : "\u{1D581}",
        "𝔳" : "\u{1D59B}",
        "𝔚" : "\u{1D582}",
        "𝔴" : "\u{1D59C}",
        "𝔛" : "\u{1D583}",
        "𝔵" : "\u{1D59D}",
        "𝔜" : "\u{1D584}",
        "𝔶" : "\u{1D59E}",
        "ℨ" : "\u{1D585}",
        "𝔷" : "\u{1D59F}",

        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathcal = (arg, initialCommand) => {
    const symbols = {
        "A" : "\u{1D49C}",
        "a" : "\u{1D4B6}",
        "B" : "\u212C",
        "b" : "\u{1D4B7}",
        "C" : "\u{1D49E}",
        "c" : "\u{1D4B8}",
        "D" : "\u{1D49F}",
        "d" : "\u{1D4B9}",
        "E" : "\u2130",
        "e" : "\u212F",
        "F" : "\u2131",
        "f" : "\u{1D4BB}",
        "G" : "\u{1D4A2}",
        "g" : "\u210A",
        "H" : "\u210B",
        "h" : "\u{1D4BD}",
        "I" : "\u2110",
        "i" : "\u{1D4BE}",
        "J" : "\u{1D4A5}",
        "j" : "\u{1D4BF}",
        "K" : "\u{1D4A6}",
        "k" : "\u{1D4C0}",
        "L" : "\u2112",
        "l" : "\u{1D4C1}",
        "M" : "\u2133",
        "m" : "\u{1D4C2}",
        "N" : "\u{1D4A9}",
        "n" : "\u{1D4C3}",
        "O" : "\u{1D4AA}",
        "o" : "\u2134",
        "P" : "\u{1D4AB}",
        "p" : "\u{1D4C5}",
        "Q" : "\u{1D4AC}",
        "q" : "\u{1D4C6}",
        "R" : "\u211B",
        "r" : "\u{1D4C7}",
        "S" : "\u{1D4AE}",
        "s" : "\u{1D4C8}",
        "T" : "\u{1D4AF}",
        "t" : "\u{1D4C9}",
        "U" : "\u{1D4B0}",
        "u" : "\u{1D4CA}",
        "V" : "\u{1D4B1}",
        "v" : "\u{1D4CB}",
        "W" : "\u{1D4B2}",
        "w" : "\u{1D4CC}",
        "X" : "\u{1D4B3}",
        "x" : "\u{1D4CD}",
        "Y" : "\u{1D4B4}",
        "y" : "\u{1D4CE}",
        "Z" : "\u{1D4B5}",
        "z" : "\u{1D4CF}",

        "𝐴" : "\u{1D49C}",
        "𝑎" : "\u{1D4B6}",
        "𝐵" : "\u212C",
        "𝑏" : "\u{1D4B7}",
        "𝐶" : "\u{1D49E}",
        "𝑐" : "\u{1D4B8}",
        "𝐷" : "\u{1D49F}",
        "𝑑" : "\u{1D4B9}",
        "𝐸" : "\u2130",
        "𝑒" : "\u212F",
        "𝐹" : "\u2131",
        "𝑓" : "\u{1D4BB}",
        "𝐺" : "\u{1D4A2}",
        "𝑔" : "\u210A",
        "𝐻" : "\u210B",
        "ℎ" : "\u{1D4BD}",
        "𝐼" : "\u2110",
        "𝑖" : "\u{1D4BE}",
        "𝐽" : "\u{1D4A5}",
        "𝑗" : "\u{1D4BF}",
        "𝐾" : "\u{1D4A6}",
        "𝑘" : "\u{1D4C0}",
        "𝐿" : "\u2112",
        "𝑙" : "\u{1D4C1}",
        "𝑀" : "\u2133",
        "𝑚" : "\u{1D4C2}",
        "𝑁" : "\u{1D4A9}",
        "𝑛" : "\u{1D4C3}",
        "𝑂" : "\u{1D4AA}",
        "𝑜" : "\u2134",
        "𝑃" : "\u{1D4AB}",
        "𝑝" : "\u{1D4C5}",
        "𝑄" : "\u{1D4AC}",
        "𝑞" : "\u{1D4C6}",
        "𝑅" : "\u211B",
        "𝑟" : "\u{1D4C7}",
        "𝑆" : "\u{1D4AE}",
        "𝑠" : "\u{1D4C8}",
        "𝑇" : "\u{1D4AF}",
        "𝑡" : "\u{1D4C9}",
        "𝑈" : "\u{1D4B0}",
        "𝑢" : "\u{1D4CA}",
        "𝑉" : "\u{1D4B1}",
        "𝑣" : "\u{1D4CB}",
        "𝑊" : "\u{1D4B2}",
        "𝑤" : "\u{1D4CC}",
        "𝑋" : "\u{1D4B3}",
        "𝑥" : "\u{1D4CD}",
        "𝑌" : "\u{1D4B4}",
        "𝑦" : "\u{1D4CE}",
        "𝑍" : "\u{1D4B5}",
        "𝑧" : "\u{1D4CF}",

        "𝑨" : "\u{1D4D0}",
        "𝒂" : "\u{1D4EA}",
        "𝑩" : "\u{1D4D1}",
        "𝒃" : "\u{1D4EB}",
        "𝑪" : "\u{1D4D2}",
        "𝒄" : "\u{1D4EC}",
        "𝑫" : "\u{1D4D3}",
        "𝒅" : "\u{1D4ED}",
        "𝑬" : "\u{1D4D4}",
        "𝒆" : "\u{1D4EE}",
        "𝑭" : "\u{1D4D5}",
        "𝒇" : "\u{1D4EF}",
        "𝑮" : "\u{1D4D6}",
        "𝒈" : "\u{1D4F0}",
        "𝑯" : "\u{1D4D7}",
        "𝒉" : "\u{1D4F1}",
        "𝑰" : "\u{1D4D8}",
        "𝒊" : "\u{1D4F2}",
        "𝑱" : "\u{1D4D9}",
        "𝒋" : "\u{1D4F3}",
        "𝑲" : "\u{1D4DA}",
        "𝒌" : "\u{1D4F4}",
        "𝑳" : "\u{1D4DB}",
        "𝒍" : "\u{1D4F5}",
        "𝑴" : "\u{1D4DC}",
        "𝒎" : "\u{1D4F6}",
        "𝑵" : "\u{1D4DD}",
        "𝒏" : "\u{1D4F7}",
        "𝑶" : "\u{1D4DE}",
        "𝒐" : "\u{1D4F8}",
        "𝑷" : "\u{1D4DF}",
        "𝒑" : "\u{1D4F9}",
        "𝑸" : "\u{1D4E0}",
        "𝒒" : "\u{1D4FA}",
        "𝑹" : "\u{1D4E1}",
        "𝒓" : "\u{1D4FB}",
        "𝑺" : "\u{1D4E2}",
        "𝒔" : "\u{1D4FC}",
        "𝑻" : "\u{1D4E3}",
        "𝒕" : "\u{1D4FD}",
        "𝑼" : "\u{1D4E4}",
        "𝒖" : "\u{1D4FE}",
        "𝑽" : "\u{1D4E5}",
        "𝒗" : "\u{1D4FF}",
        "𝑾" : "\u{1D4E6}",
        "𝒘" : "\u{1D500}",
        "𝑿" : "\u{1D4E7}",
        "𝒙" : "\u{1D501}",
        "𝒀" : "\u{1D4E8}",
        "𝒚" : "\u{1D502}",
        "𝒁" : "\u{1D4E9}",
        "𝒛" : "\u{1D503}",

        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const mathfrak = (arg, initialCommand) => {
    const symbols = {
        "A" : "\u{1D504}",
        "a" : "\u{1D51E}",
        "B" : "\u{1D505}",
        "b" : "\u{1D51F}",
        "C" : "\u212D",
        "c" : "\u{1D520}",
        "D" : "\u{1D507}",
        "d" : "\u{1D521}",
        "E" : "\u{1D508}",
        "e" : "\u{1D522}",
        "F" : "\u{1D509}",
        "f" : "\u{1D523}",
        "G" : "\u{1D50A}",
        "g" : "\u{1D524}",
        "H" : "\u210C",
        "h" : "\u{1D525}",
        "I" : "\u2111",
        "i" : "\u{1D526}",
        "J" : "\u{1D50D}",
        "j" : "\u{1D527}",
        "K" : "\u{1D50E}",
        "k" : "\u{1D528}",
        "L" : "\u{1D50F}",
        "l" : "\u{1D529}",
        "M" : "\u{1D510}",
        "m" : "\u{1D52A}",
        "N" : "\u{1D511}",
        "n" : "\u{1D52B}",
        "O" : "\u{1D512}",
        "o" : "\u{1D52C}",
        "P" : "\u{1D513}",
        "p" : "\u{1D52D}",
        "Q" : "\u{1D514}",
        "q" : "\u{1D52E}",
        "R" : "\u211C",
        "r" : "\u{1D52F}",
        "S" : "\u{1D516}",
        "s" : "\u{1D530}",
        "T" : "\u{1D517}",
        "t" : "\u{1D531}",
        "U" : "\u{1D518}",
        "u" : "\u{1D532}",
        "V" : "\u{1D519}",
        "v" : "\u{1D533}",
        "W" : "\u{1D51A}",
        "w" : "\u{1D534}",
        "X" : "\u{1D51B}",
        "x" : "\u{1D535}",
        "Y" : "\u{1D51C}",
        "y" : "\u{1D536}",
        "Z" : "\u2128",
        "z" : "\u{1D537}",

        "𝐴" : "\u{1D504}",
        "𝑎" : "\u{1D51E}",
        "𝐵" : "\u{1D505}",
        "𝑏" : "\u{1D51F}",
        "𝐶" : "\u212D",
        "𝑐" : "\u{1D520}",
        "𝐷" : "\u{1D507}",
        "𝑑" : "\u{1D521}",
        "𝐸" : "\u{1D508}",
        "𝑒" : "\u{1D522}",
        "𝐹" : "\u{1D509}",
        "𝑓" : "\u{1D523}",
        "𝐺" : "\u{1D50A}",
        "𝑔" : "\u{1D524}",
        "𝐻" : "\u210C",
        "ℎ" : "\u{1D525}",
        "𝐼" : "\u2111",
        "𝑖" : "\u{1D526}",
        "𝐽" : "\u{1D50D}",
        "𝑗" : "\u{1D527}",
        "𝐾" : "\u{1D50E}",
        "𝑘" : "\u{1D528}",
        "𝐿" : "\u{1D50F}",
        "𝑙" : "\u{1D529}",
        "𝑀" : "\u{1D510}",
        "𝑚" : "\u{1D52A}",
        "𝑁" : "\u{1D511}",
        "𝑛" : "\u{1D52B}",
        "𝑂" : "\u{1D512}",
        "𝑜" : "\u{1D52C}",
        "𝑃" : "\u{1D513}",
        "𝑝" : "\u{1D52D}",
        "𝑄" : "\u{1D514}",
        "𝑞" : "\u{1D52E}",
        "𝑅" : "\u211C",
        "𝑟" : "\u{1D52F}",
        "𝑆" : "\u{1D516}",
        "𝑠" : "\u{1D530}",
        "𝑇" : "\u{1D517}",
        "𝑡" : "\u{1D531}",
        "𝑈" : "\u{1D518}",
        "𝑢" : "\u{1D532}",
        "𝑉" : "\u{1D519}",
        "𝑣" : "\u{1D533}",
        "𝑊" : "\u{1D51A}",
        "𝑤" : "\u{1D534}",
        "𝑋" : "\u{1D51B}",
        "𝑥" : "\u{1D535}",
        "𝑌" : "\u{1D51C}",
        "𝑦" : "\u{1D536}",
        "𝑍" : "\u2128",
        "𝑧" : "\u{1D537}",

        "𝑨" : "\u{1D56C}",
        "𝒂" : "\u{1D586}",
        "𝑩" : "\u{1D56D}",
        "𝒃" : "\u{1D587}",
        "𝑪" : "\u{1D56E}",
        "𝒄" : "\u{1D588}",
        "𝑫" : "\u{1D56F}",
        "𝒅" : "\u{1D589}",
        "𝑬" : "\u{1D570}",
        "𝒆" : "\u{1D58A}",
        "𝑭" : "\u{1D571}",
        "𝒇" : "\u{1D58B}",
        "𝑮" : "\u{1D572}",
        "𝒈" : "\u{1D58C}",
        "𝑯" : "\u{1D573}",
        "𝒉" : "\u{1D58D}",
        "𝑰" : "\u{1D574}",
        "𝒊" : "\u{1D58E}",
        "𝑱" : "\u{1D575}",
        "𝒋" : "\u{1D58F}",
        "𝑲" : "\u{1D576}",
        "𝒌" : "\u{1D590}",
        "𝑳" : "\u{1D577}",
        "𝒍" : "\u{1D591}",
        "𝑴" : "\u{1D578}",
        "𝒎" : "\u{1D592}",
        "𝑵" : "\u{1D579}",
        "𝒏" : "\u{1D593}",
        "𝑶" : "\u{1D57A}",
        "𝒐" : "\u{1D594}",
        "𝑷" : "\u{1D57B}",
        "𝒑" : "\u{1D595}",
        "𝑸" : "\u{1D57C}",
        "𝒒" : "\u{1D596}",
        "𝑹" : "\u{1D57D}",
        "𝒓" : "\u{1D597}",
        "𝑺" : "\u{1D57E}",
        "𝒔" : "\u{1D598}",
        "𝑻" : "\u{1D57F}",
        "𝒕" : "\u{1D599}",
        "𝑼" : "\u{1D580}",
        "𝒖" : "\u{1D59A}",
        "𝑽" : "\u{1D581}",
        "𝒗" : "\u{1D59B}",
        "𝑾" : "\u{1D582}",
        "𝒘" : "\u{1D59C}",
        "𝑿" : "\u{1D583}",
        "𝒙" : "\u{1D59D}",
        "𝒀" : "\u{1D584}",
        "𝒚" : "\u{1D59E}",
        "𝒁" : "\u{1D585}",
        "𝒛" : "\u{1D59F}",

        " " : " "
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const superscript = (arg, initialCommand, forFrac=false) => {
    const sup = {
        "0" : "\u2070",
        "1" : "\u00B9",
        "2" : "\u00B2",
        "3" : "\u00B3",
        "4" : "\u2074",
        "5" : "\u2075",
        "6" : "\u2076",
        "7" : "\u2077",
        "8" : "\u2078",
        "9" : "\u2079",

        "+" : "\u207A",
        "-" : "\u207B",
        "\u2212" : "\u207B",
        "=" : "\u207C",
        "(" : "\u207D",
        ")" : "\u207E",
        "\\" : "ᐠ",
        "/" : "ᐟ",
        "." : "ᐧ",
        "," : "\u02D2",
        "$" : "ᙚ",

        "A" : "ᴬ",
        "a" : "ᵃ",
        "B" : "ᴮ",
        "b" : "ᵇ",
        "C" : "ᶜ",
        "c" : "ᶜ",
        "D" : "ᴰ",
        "d" : "ᵈ",
        "E" : "ᴱ",
        "e" : "ᵉ",
        "f" : "ᶠ",
        "G" : "ᴳ",
        "g" : "ᵍ",
        "H" : "ᴴ",
        "h" : "ʰ",
        "I" : "ᴵ",
        "i" : "ⁱ",
        "J" : "ᴶ",
        "j" : "ʲ",
        "K" : "ᴷ",
        "k" : "ᵏ",
        "L" : "ᴸ",
        "l" : "ˡ",
        "M" : "ᴹ",
        "m" : "ᵐ",
        "N" : "ᴺ",
        "n" : "ⁿ",
        "O" : "ᴼ",
        "o" : "ᵒ",
        "P" : "ᴾ",
        "p" : "ᵖ",
        "R" : "ᴿ",
        "r" : "ʳ",
        "S" : "ˢ",
        "s" : "ˢ",
        "T" : "ᵀ",
        "t" : "ᵗ",
        "U" : "ᵁ",
        "u" : "ᵘ",
        "V" : "ⱽ",
        "v" : "ᵛ",
        "W" : "ᵂ",
        "w" : "ʷ",
        "X" : "ˣ",
        "x" : "ˣ",
        "y" : "ʸ",
        "Z" : "ᶻ",
        "z" : "ᶻ",

        "𝐴" : "ᴬ",
        "𝑎" : "ᵃ",
        "𝐵" : "ᴮ",
        "𝑏" : "ᵇ",
        "𝐶" : "ᶜ",
        "𝑐" : "ᶜ",
        "𝐷" : "ᴰ",
        "𝑑" : "ᵈ",
        "𝐸" : "ᴱ",
        "𝑒" : "ᵉ",
        "𝑓" : "ᶠ",
        "𝐺" : "ᴳ",
        "𝑔" : "ᵍ",
        "𝐻" : "ᴴ",
        "ℎ" : "ʰ",
        "𝐼" : "ᴵ",
        "𝑖" : "ⁱ",
        "𝐽" : "ᴶ",
        "𝑗" : "ʲ",
        "𝐾" : "ᴷ",
        "𝑘" : "ᵏ",
        "𝐿" : "ᴸ",
        "𝑙" : "ˡ",
        "𝑀" : "ᴹ",
        "𝑚" : "ᵐ",
        "𝑁" : "ᴺ",
        "𝑛" : "ⁿ",
        "𝑂" : "ᴼ",
        "𝑜" : "ᵒ",
        "𝑃" : "ᴾ",
        "𝑝" : "ᵖ",
        "𝑅" : "ᴿ",
        "𝑟" : "ʳ",
        "𝑆" : "ˢ",
        "𝑠" : "ˢ",
        "𝑇" : "ᵀ",
        "𝑡" : "ᵗ",
        "𝑈" : "ᵁ",
        "𝑢" : "ᵘ",
        "𝑉" : "ⱽ",
        "𝑣" : "ᵛ",
        "𝑊" : "ᵂ",
        "𝑤" : "ʷ",
        "𝑋" : "ˣ",
        "𝑥" : "ˣ",
        "𝑦" : "ʸ",
        "𝑍" : "ᶻ",
        "𝑧" : "ᶻ",

        "𝛽" : "\u1D5D",
        "𝛤" : "ᣘ",
        "𝛾" : "\u1D5E",
        "Δ" : "ᐞ",
        "δ" : "\u1D5F",
        "ϵ" : "ᵋ",
        "Λ" : "ᣔ",
        "𝜃" : "\u1DBF",
        "𝜄" : "ᶥ",
        "𝜈" : "ᶹ",
        "σ" : "ᣙ",
        "𝜙" : "ᶲ",
        "𝜑" : "\u1D60",
        "𝜌" : "ᣖ",
        "𝜒" : "\u1D61",

        "∫" : "ᶴ",
        "≠" : "ᙾ",
        "∘" : "°",
        "$" : "ᙚ",
        "∞" : "\u2710\u1AB2\u2710",  // Only works on certain website/apps
        "∅" : "\u{1D1A9}",

        " " : " "
    };
    let output = replaceLetters(arg, sup, initialCommand, !forFrac);
    if ((output.indexOf("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") === -1) || (forFrac)) {
        return output;
    } else {
        return "^(" + arg.join("") + ")";
    };
};

const subscript = (arg, initialCommand, forFrac=false) => {
    const sub = {
        "0" : "\u2080",
        "1" : "\u2081",
        "2" : "\u2082",
        "3" : "\u2083",
        "4" : "\u2084",
        "5" : "\u2085",
        "6" : "\u2086",
        "7" : "\u2087",
        "8" : "\u2088",
        "9" : "\u2089",

        "+" : "\u208A",
        "-" : "\u208B",
        "\u2212" : "\u208B",
        "=" : "\u208C",
        "(" : "\u208D",
        ")" : "\u208E",
        "," : "\u2710\u0326\u2710",
        "." : "\u2710\u0323\u2710",

        "a" : "\u2090",
        "e" : "\u2091",
        "h" : "\u2095",
        "i" : "\u1D62",
        "j" : "ⱼ",
        "k" : "\u2096",
        "l" : "\u2097",
        "m" : "\u2098",
        "n" : "\u2099",
        "O" : "\u2092",
        "o" : "\u2092",
        "p" : "\u209A",
        "r" : "ᵣ",
        "S" : "\u209B",
        "s" : "\u209B",
        "t" : "\u209C",
        "u" : "ᵤ",
        "V" : "ᵥ",
        "v" : "ᵥ",
        "X" : "\u2093",
        "x" : "\u2093",

        "𝑎" : "\u2090",
        "𝑒" : "\u2091",
        "ℎ" : "\u2095",
        "𝑖" : "\u1D62",
        "𝑗" : "ⱼ",
        "𝑘" : "\u2096",
        "𝑙" : "\u2097",
        "𝑚" : "\u2098",
        "𝑛" : "\u2099",
        "𝑂" : "\u2092",
        "𝑜" : "\u2092",
        "𝑝" : "\u209A",
        "𝑟" : "ᵣ",
        "𝑆" : "\u209B",
        "𝑠" : "\u209B",
        "𝑡" : "\u209C",
        "𝑢" : "ᵤ",
        "𝑉" : "ᵥ",
        "𝑣" : "ᵥ",
        "𝑋" : "\u2093",
        "𝑥" : "\u2093",

        "𝛽" : "\u1D66",
        "𝛾" : "\u1D67",
        "𝜌" : "\u1D68",
        "𝜑" : "\u1D69",
        "𝜙" : "\u1D69",
        "𝜒" : "\u1D6A",
    
        "→" : "\u2710\u2710\u0362\u2710\u2710",
        "∞" : "\u2710\u035A\u2710",

        " " : " "
    };
    let output = replaceLetters(arg, sub, initialCommand, !forFrac);
    if ((output.indexOf("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") === -1) || (forFrac)) {
        return output;
    } else {
        return "_(" + arg.join("") + ")";
    };
};

const textbf = (arg, initialCommand) => {
	const symbols = {
        "A" : "\u{1D5D4}",
        "a" : "\u{1D5EE}",
        "B" : "\u{1D5D5}",
        "b" : "\u{1D5EF}",
        "C" : "\u{1D5D6}",
        "c" : "\u{1D5F0}",
        "D" : "\u{1D5D7}",
        "d" : "\u{1D5F1}",
        "E" : "\u{1D5D8}",
        "e" : "\u{1D5F2}",
        "F" : "\u{1D5D9}",
        "f" : "\u{1D5F3}",
        "G" : "\u{1D5DA}",
        "g" : "\u{1D5F4}",
        "H" : "\u{1D5DB}",
        "h" : "\u{1D5F5}",
        "I" : "\u{1D5DC}",
        "i" : "\u{1D5F6}",
        "J" : "\u{1D5DD}",
        "j" : "\u{1D5F7}",
        "K" : "\u{1D5DE}",
        "k" : "\u{1D5F8}",
        "L" : "\u{1D5DF}",
        "l" : "\u{1D5F9}",
        "M" : "\u{1D5E0}",
        "m" : "\u{1D5FA}",
        "N" : "\u{1D5E1}",
        "n" : "\u{1D5FB}",
        "O" : "\u{1D5E2}",
        "o" : "\u{1D5FC}",
        "P" : "\u{1D5E3}",
        "p" : "\u{1D5FD}",
        "Q" : "\u{1D5E4}",
        "q" : "\u{1D5FE}",
        "R" : "\u{1D5E5}",
        "r" : "\u{1D5FF}",
        "S" : "\u{1D5E6}",
        "s" : "\u{1D600}",
        "T" : "\u{1D5E7}",
        "t" : "\u{1D601}",
        "U" : "\u{1D5E8}",
        "u" : "\u{1D602}",
        "V" : "\u{1D5E9}",
        "v" : "\u{1D603}",
        "W" : "\u{1D5EA}",
        "w" : "\u{1D604}",
        "X" : "\u{1D5EB}",
        "x" : "\u{1D605}",
        "Y" : "\u{1D5EC}",
        "y" : "\u{1D606}",
        "Z" : "\u{1D5ED}",
        "z" : "\u{1D607}",

        "𝐴" : "\u{1D5D4}",
        "𝑎" : "\u{1D5EE}",
        "𝐵" : "\u{1D5D5}",
        "𝑏" : "\u{1D5EF}",
        "𝐶" : "\u{1D5D6}",
        "𝑐" : "\u{1D5F0}",
        "𝐷" : "\u{1D5D7}",
        "𝑑" : "\u{1D5F1}",
        "𝐸" : "\u{1D5D8}",
        "𝑒" : "\u{1D5F2}",
        "𝐹" : "\u{1D5D9}",
        "𝑓" : "\u{1D5F3}",
        "𝐺" : "\u{1D5DA}",
        "𝑔" : "\u{1D5F4}",
        "𝐻" : "\u{1D5DB}",
        "ℎ" : "\u{1D5F5}",
        "𝐼" : "\u{1D5DC}",
        "𝑖" : "\u{1D5F6}",
        "𝐽" : "\u{1D5DD}",
        "𝑗" : "\u{1D5F7}",
        "𝐾" : "\u{1D5DE}",
        "𝑘" : "\u{1D5F8}",
        "𝐿" : "\u{1D5DF}",
        "𝑙" : "\u{1D5F9}",
        "𝑀" : "\u{1D5E0}",
        "𝑚" : "\u{1D5FA}",
        "𝑁" : "\u{1D5E1}",
        "𝑛" : "\u{1D5FB}",
        "𝑂" : "\u{1D5E2}",
        "𝑜" : "\u{1D5FC}",
        "𝑃" : "\u{1D5E3}",
        "𝑝" : "\u{1D5FD}",
        "𝑄" : "\u{1D5E4}",
        "𝑞" : "\u{1D5FE}",
        "𝑅" : "\u{1D5E5}",
        "𝑟" : "\u{1D5FF}",
        "𝑆" : "\u{1D5E6}",
        "𝑠" : "\u{1D600}",
        "𝑇" : "\u{1D5E7}",
        "𝑡" : "\u{1D601}",
        "𝑈" : "\u{1D5E8}",
        "𝑢" : "\u{1D602}",
        "𝑉" : "\u{1D5E9}",
        "𝑣" : "\u{1D603}",
        "𝑊" : "\u{1D5EA}",
        "𝑤" : "\u{1D604}",
        "𝑋" : "\u{1D5EB}",
        "𝑥" : "\u{1D605}",
        "𝑌" : "\u{1D5EC}",
        "𝑦" : "\u{1D606}",
        "𝑍" : "\u{1D5ED}",
        "𝑧" : "\u{1D607}",

        "𝘈" : "\u{1D63C}",
        "𝘢" : "\u{1D656}",
        "𝘉" : "\u{1D63D}",
        "𝘣" : "\u{1D657}",
        "𝘊" : "\u{1D63E}",
        "𝘤" : "\u{1D658}",
        "𝘋" : "\u{1D63F}",
        "𝘥" : "\u{1D659}",
        "𝘌" : "\u{1D640}",
        "𝘦" : "\u{1D65A}",
        "𝘍" : "\u{1D641}",
        "𝘧" : "\u{1D65B}",
        "𝘎" : "\u{1D642}",
        "𝘨" : "\u{1D65C}",
        "𝘏" : "\u{1D643}",
        "𝘩" : "\u{1D65D}",
        "𝘐" : "\u{1D644}",
        "𝘪" : "\u{1D65E}",
        "𝘑" : "\u{1D645}",
        "𝘫" : "\u{1D65F}",
        "𝘒" : "\u{1D646}",
        "𝘬" : "\u{1D660}",
        "𝘓" : "\u{1D647}",
        "𝘭" : "\u{1D661}",
        "𝘔" : "\u{1D648}",
        "𝘮" : "\u{1D662}",
        "𝘕" : "\u{1D649}",
        "𝘯" : "\u{1D663}",
        "𝘖" : "\u{1D64A}",
        "𝘰" : "\u{1D664}",
        "𝘗" : "\u{1D64B}",
        "𝘱" : "\u{1D665}",
        "𝘘" : "\u{1D64C}",
        "𝘲" : "\u{1D666}",
        "𝘙" : "\u{1D64D}",
        "𝘳" : "\u{1D667}",
        "𝘚" : "\u{1D64E}",
        "𝘴" : "\u{1D668}",
        "𝘛" : "\u{1D64F}",
        "𝘵" : "\u{1D669}",
        "𝘜" : "\u{1D650}",
        "𝘶" : "\u{1D66A}",
        "𝘝" : "\u{1D651}",
        "𝘷" : "\u{1D66B}",
        "𝘞" : "\u{1D652}",
        "𝘸" : "\u{1D66C}",
        "𝘟" : "\u{1D653}",
        "𝘹" : "\u{1D66D}",
        "𝘠" : "\u{1D654}",
        "𝘺" : "\u{1D66E}",
        "𝘡" : "\u{1D655}",
        "𝘻" : "\u{1D66F}",

        "0" : "\u{1D7EC}",
        "1" : "\u{1D7ED}",
        "2" : "\u{1D7EE}",
        "3" : "\u{1D7EF}",
        "4" : "\u{1D7F0}",
        "5" : "\u{1D7F1}",
        "6" : "\u{1D7F2}",
        "7" : "\u{1D7F3}",
        "8" : "\u{1D7F4}",
        "9" : "\u{1D7F5}",

		" " : "\u2710"
	};
	return replaceLetters(arg, symbols, initialCommand);
};

const textit = (arg, initialCommand) => {
    const symbols = {
        "A" : "\u{1D608}",
        "a" : "\u{1D622}",
        "B" : "\u{1D609}",
        "b" : "\u{1D623}",
        "C" : "\u{1D60A}",
        "c" : "\u{1D624}",
        "D" : "\u{1D60B}",
        "d" : "\u{1D625}",
        "E" : "\u{1D60C}",
        "e" : "\u{1D626}",
        "F" : "\u{1D60D}",
        "f" : "\u{1D627}",
        "G" : "\u{1D60E}",
        "g" : "\u{1D628}",
        "H" : "\u{1D60F}",
        "h" : "\u{1D629}",
        "I" : "\u{1D610}",
        "i" : "\u{1D62A}",
        "J" : "\u{1D611}",
        "j" : "\u{1D62B}",
        "K" : "\u{1D612}",
        "k" : "\u{1D62C}",
        "L" : "\u{1D613}",
        "l" : "\u{1D62D}",
        "M" : "\u{1D614}",
        "m" : "\u{1D62E}",
        "N" : "\u{1D615}",
        "n" : "\u{1D62F}",
        "O" : "\u{1D616}",
        "o" : "\u{1D630}",
        "P" : "\u{1D617}",
        "p" : "\u{1D631}",
        "Q" : "\u{1D618}",
        "q" : "\u{1D632}",
        "R" : "\u{1D619}",
        "r" : "\u{1D633}",
        "S" : "\u{1D61A}",
        "s" : "\u{1D634}",
        "T" : "\u{1D61B}",
        "t" : "\u{1D635}",
        "U" : "\u{1D61C}",
        "u" : "\u{1D636}",
        "V" : "\u{1D61D}",
        "v" : "\u{1D637}",
        "W" : "\u{1D61E}",
        "w" : "\u{1D638}",
        "X" : "\u{1D61F}",
        "x" : "\u{1D639}",
        "Y" : "\u{1D620}",
        "y" : "\u{1D63A}",
        "Z" : "\u{1D621}",
        "z" : "\u{1D63B}",

        "𝐴" : "\u{1D608}",
        "𝑎" : "\u{1D622}",
        "𝐵" : "\u{1D609}",
        "𝑏" : "\u{1D623}",
        "𝐶" : "\u{1D60A}",
        "𝑐" : "\u{1D624}",
        "𝐷" : "\u{1D60B}",
        "𝑑" : "\u{1D625}",
        "𝐸" : "\u{1D60C}",
        "𝑒" : "\u{1D626}",
        "𝐹" : "\u{1D60D}",
        "𝑓" : "\u{1D627}",
        "𝐺" : "\u{1D60E}",
        "𝑔" : "\u{1D628}",
        "𝐻" : "\u{1D60F}",
        "ℎ" : "\u{1D629}",
        "𝐼" : "\u{1D610}",
        "𝑖" : "\u{1D62A}",
        "𝐽" : "\u{1D611}",
        "𝑗" : "\u{1D62B}",
        "𝐾" : "\u{1D612}",
        "𝑘" : "\u{1D62C}",
        "𝐿" : "\u{1D613}",
        "𝑙" : "\u{1D62D}",
        "𝑀" : "\u{1D614}",
        "𝑚" : "\u{1D62E}",
        "𝑁" : "\u{1D615}",
        "𝑛" : "\u{1D62F}",
        "𝑂" : "\u{1D616}",
        "𝑜" : "\u{1D630}",
        "𝑃" : "\u{1D617}",
        "𝑝" : "\u{1D631}",
        "𝑄" : "\u{1D618}",
        "𝑞" : "\u{1D632}",
        "𝑅" : "\u{1D619}",
        "𝑟" : "\u{1D633}",
        "𝑆" : "\u{1D61A}",
        "𝑠" : "\u{1D634}",
        "𝑇" : "\u{1D61B}",
        "𝑡" : "\u{1D635}",
        "𝑈" : "\u{1D61C}",
        "𝑢" : "\u{1D636}",
        "𝑉" : "\u{1D61D}",
        "𝑣" : "\u{1D637}",
        "𝑊" : "\u{1D61E}",
        "𝑤" : "\u{1D638}",
        "𝑋" : "\u{1D61F}",
        "𝑥" : "\u{1D639}",
        "𝑌" : "\u{1D620}",
        "𝑦" : "\u{1D63A}",
        "𝑍" : "\u{1D621}",
        "𝑧" : "\u{1D63B}",

        "𝗔" : "\u{1D63C}",
        "𝗮" : "\u{1D656}",
        "𝗕" : "\u{1D63D}",
        "𝗯" : "\u{1D657}",
        "𝗖 " : "\u{1D63E}",
        "𝗰" : "\u{1D658}",
        "𝗗" : "\u{1D63F}",
        "𝗱" : "\u{1D659}",
        "𝗘" : "\u{1D640}",
        "𝗲" : "\u{1D65A}",
        "𝗙" : "\u{1D641}",
        "𝗳" : "\u{1D65B}",
        "𝗚" : "\u{1D642}",
        "𝗴" : "\u{1D65C}",
        "𝗛" : "\u{1D643}",
        "𝗵" : "\u{1D65D}",
        "𝗜" : "\u{1D644}",
        "𝗶" : "\u{1D65E}",
        "𝗝" : "\u{1D645}",
        "𝗷 " : "\u{1D65F}",
        "𝗞" : "\u{1D646}",
        "𝗸" : "\u{1D660}",
        "𝗟" : "\u{1D647}",
        "𝗹" : "\u{1D661}",
        "𝗠" : "\u{1D648}",
        "𝗺" : "\u{1D662}",
        "𝗡" : "\u{1D649}",
        "𝗻" : "\u{1D663}",
        "𝗢" : "\u{1D64A}",
        "𝗼" : "\u{1D664}",
        "𝗣" : "\u{1D64B}",
        "𝗽" : "\u{1D665}",
        "𝗤" : "\u{1D64C}",
        "𝗾" : "\u{1D666}",
        "𝗥" : "\u{1D64D}",
        "𝗿" : "\u{1D667}",
        "𝗦" : "\u{1D64E}",
        "𝘀" : "\u{1D668}",
        "𝗧" : "\u{1D64F}",
        "𝘁" : "\u{1D669}",
        "𝗨" : "\u{1D650}",
        "𝘂" : "\u{1D66A}",
        "𝗩" : "\u{1D651}",
        "𝘃" : "\u{1D66B}",
        "𝗪" : "\u{1D652}",
        "𝘄" : "\u{1D66C}",
        "𝗫" : "\u{1D653}",
        "𝘅" : "\u{1D66D}",
        "𝗬" : "\u{1D654}",
        "𝘆" : "\u{1D66E}",
        "𝗭" : "\u{1D655}",
        "𝘇" : "\u{1D66F}",

        "𝟬" : "𝟬",
        "𝟭" : "𝟭",
        "𝟮" : "𝟮",
        "𝟯" : "𝟯",
        "𝟰" : "𝟰",
        "𝟱" : "𝟱",
        "𝟲" : "𝟲",
        "𝟳" : "𝟳",
        "𝟴" : "𝟴",
        "𝟵" : "𝟵",

        // These symbols don't exist in textit, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        '"' : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¢" : "¢",
        "£" : "£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "∶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "°" : "°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",
        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

		" " : "\u2710"
	};
	return replaceLetters(arg, symbols, initialCommand);
};

const texttt = (arg, initialCommand) => {
    const symbols = {
        "A" : "\u{1D670}",
        "a" : "\u{1D68A}",
        "B" : "\u{1D671}",
        "b" : "\u{1D68B}",
        "C" : "\u{1D672}",
        "c" : "\u{1D68C}",
        "D" : "\u{1D673}",
        "d" : "\u{1D68D}",
        "E" : "\u{1D674}",
        "e" : "\u{1D68E}",
        "F" : "\u{1D675}",
        "f" : "\u{1D68F}",
        "G" : "\u{1D676}",
        "g" : "\u{1D690}",
        "H" : "\u{1D677}",
        "h" : "\u{1D691}",
        "I" : "\u{1D678}",
        "i" : "\u{1D692}",
        "J" : "\u{1D679}",
        "j" : "\u{1D693}",
        "K" : "\u{1D67A}",
        "k" : "\u{1D694}",
        "L" : "\u{1D67B}",
        "l" : "\u{1D695}",
        "M" : "\u{1D67C}",
        "m" : "\u{1D696}",
        "N" : "\u{1D67D}",
        "n" : "\u{1D697}",
        "O" : "\u{1D67E}",
        "o" : "\u{1D698}",
        "P" : "\u{1D67F}",
        "p" : "\u{1D699}",
        "Q" : "\u{1D680}",
        "q" : "\u{1D69A}",
        "R" : "\u{1D681}",
        "r" : "\u{1D69B}",
        "S" : "\u{1D682}",
        "s" : "\u{1D69C}",
        "T" : "\u{1D683}",
        "t" : "\u{1D69D}",
        "U" : "\u{1D684}",
        "u" : "\u{1D69E}",
        "V" : "\u{1D685}",
        "v" : "\u{1D69F}",
        "W" : "\u{1D686}",
        "w" : "\u{1D6A0}",
        "X" : "\u{1D687}",
        "x" : "\u{1D6A1}",
        "Y" : "\u{1D688}",
        "y" : "\u{1D6A2}",
        "Z" : "\u{1D689}",
        "z" : "\u{1D6A3}",

        "𝐴" : "\u{1D670}",
        "𝑎" : "\u{1D68A}",
        "𝐵" : "\u{1D671}",
        "𝑏" : "\u{1D68B}",
        "𝐶" : "\u{1D672}",
        "𝑐" : "\u{1D68C}",
        "𝐷" : "\u{1D673}",
        "𝑑" : "\u{1D68D}",
        "𝐸" : "\u{1D674}",
        "𝑒" : "\u{1D68E}",
        "𝐹" : "\u{1D675}",
        "𝑓" : "\u{1D68F}",
        "𝐺" : "\u{1D676}",
        "𝑔" : "\u{1D690}",
        "𝐻" : "\u{1D677}",
        "ℎ" : "\u{1D691}",
        "𝐼" : "\u{1D678}",
        "𝑖" : "\u{1D692}",
        "𝐽" : "\u{1D679}",
        "𝑗" : "\u{1D693}",
        "𝐾" : "\u{1D67A}",
        "𝑘" : "\u{1D694}",
        "𝐿" : "\u{1D67B}",
        "𝑙" : "\u{1D695}",
        "𝑀" : "\u{1D67C}",
        "𝑚" : "\u{1D696}",
        "𝑁" : "\u{1D67D}",
        "𝑛" : "\u{1D697}",
        "𝑂" : "\u{1D67E}",
        "𝑜" : "\u{1D698}",
        "𝑃" : "\u{1D67F}",
        "𝑝" : "\u{1D699}",
        "𝑄" : "\u{1D680}",
        "𝑞" : "\u{1D69A}",
        "𝑅" : "\u{1D681}",
        "𝑟" : "\u{1D69B}",
        "𝑆" : "\u{1D682}",
        "𝑠" : "\u{1D69C}",
        "𝑇" : "\u{1D683}",
        "𝑡" : "\u{1D69D}",
        "𝑈" : "\u{1D684}",
        "𝑢" : "\u{1D69E}",
        "𝑉" : "\u{1D685}",
        "𝑣" : "\u{1D69F}",
        "𝑊" : "\u{1D686}",
        "𝑤" : "\u{1D6A0}",
        "𝑋" : "\u{1D687}",
        "𝑥" : "\u{1D6A1}",
        "𝑌" : "\u{1D688}",
        "𝑦" : "\u{1D6A2}",
        "𝑍" : "\u{1D689}",
        "𝑧" : "\u{1D6A3}",

        "0" : "\u{1D7F6}",
        "1" : "\u{1D7F7}",
        "2" : "\u{1D7F8}",
        "3" : "\u{1D7F9}",
        "4" : "\u{1D7FA}",
        "5" : "\u{1D7FB}",
        "6" : "\u{1D7FC}",
        "7" : "\u{1D7FD}",
        "8" : "\u{1D7FE}",
        "9" : "\u{1D7FF}",

        // These symbols don't exist in texttt, but don't output errors
        "." : ".",
        "," : ",",
        "'" : "'",
        '"' : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¢" : "¢",
        "£" : "£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "∶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "°" : "°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        " " : "\u2710"
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const text = (arg, initialCommand) => {
    const symbols = {
        "A" : "A",
        "À" : "À",
        "à" : "à",
        "a" : "a",
        "B" : "B",
        "b" : "b",
        "C" : "C",
        "Ç" : "Ç",
        "c" : "c",
        "ç" : "ç",
        "D" : "D",
        "d" : "d",
        "E" : "E",
        "É" : "É",
        "È" : "È",
        "Ê" : "Ê",
        "Ë" : "Ë",
        "e" : "e",
        "é" : "é",
        "è" : "è",
        "ê" : "ê",
        "ë" : "ë",
        "F" : "F",
        "f" : "f",
        "G" : "G",
        "g" : "g",
        "H" : "H",
        "h" : "h",
        "I" : "I",
        "i" : "i",
        "J" : "J",
        "j" : "j",
        "K" : "K",
        "k" : "k",
        "L" : "L",
        "l" : "l",
        "M" : "M",
        "m" : "m",
        "N" : "N",
        "n" : "n",
        "O" : "O",
        "Ô" : "Ô",
        "o" : "o",
        "ô" : "ô",
        "P" : "P",
        "p" : "p",
        "Q" : "Q",
        "q" : "q",
        "R" : "R",
        "r" : "r",
        "S" : "S",
        "s" : "s",
        "T" : "T",
        "t" : "t",
        "U" : "U",
        "u" : "u",
        "Ù" : "Ù",
        "ù" : "ù",
        "V" : "V",
        "v" : "v",
        "W" : "W",
        "w" : "w",
        "X" : "X",
        "x" : "x",
        "Y" : "Y",
        "y" : "y",
        "Z" : "Z",
        "z" : "z",

        "𝐴" : "A",
        "𝑎" : "a",
        "𝐵" : "B",
        "𝑏" : "b",
        "𝐶" : "C",
        "𝑐" : "c",
        "𝐷" : "D",
        "𝑑" : "d",
        "𝐸" : "E",
        "𝑒" : "e",
        "𝐹" : "F",
        "𝑓" : "f",
        "𝐺" : "G",
        "𝑔" : "g",
        "𝐻" : "H",
        "ℎ" : "h",
        "𝐼" : "I",
        "𝑖" : "i",
        "𝐽" : "J",
        "𝑗" : "j",
        "𝐾" : "K",
        "𝑘" : "k",
        "𝐿" : "L",
        "𝑙" : "l",
        "𝑀" : "M",
        "𝑚" : "m",
        "𝑁" : "N",
        "𝑛" : "n",
        "𝑂" : "O",
        "𝑜" : "o",
        "𝑃" : "P",
        "𝑝" : "p",
        "𝑄" : "Q",
        "𝑞" : "q",
        "𝑅" : "R",
        "𝑟" : "r",
        "𝑆" : "S",
        "𝑠" : "s",
        "𝑇" : "T",
        "𝑡" : "t",
        "𝑈" : "U",
        "𝑢" : "u",
        "𝑉" : "V",
        "𝑣" : "v",
        "𝑊" : "W",
        "𝑤" : "w",
        "𝑋" : "X",
        "𝑥" : "x",
        "𝑌" : "Y",
        "𝑦" : "y",
        "𝑍" : "Z",
        "𝑧" : "z",

        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "." : ".",
        "," : ",",
        "'" : "'",
        '"' : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "¢" : "¢",
        "£" : "£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "∶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "°" : "°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        " " : "\u2710"
    };
    return replaceLetters(arg, symbols, initialCommand);
};

const hspace = (arg, initialCommand) => {
    let spaces = "";
    const num = arg.join("");
    if (num * 0 !== 0) {
        spaces = mistakes(initialCommand + "{" + num + "}", undefined, "argument must be a number");
    } else {
        for (let i=0; i<parseInt(arg); i++) {
            spaces += "\u2710";
        };
    };
    return spaces;
};

const vskip = (arg, initialCommand) => {
    let skips = "";
    const num = arg.join("");
    if (num * 0 !== 0) {
        skips = mistakes(initialCommand + "{" + num + "}", undefined, "argument must be a number");
    } else {
        for (let i=0; i<parseInt(num); i++) {
            skips += "\u000A";
        };
    };
    return skips;
};

const sqrt = (arg, initialCommand) => {
    const numStart = parseInt(initialCommand.indexOf("["));
    const numEnd = parseInt(initialCommand.indexOf("]"));
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]{x}", undefined, "ⁿ√𝑥");
            return addSymbol(undefined);
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output = "";
    switch (rootNum) {
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(mathDictionary["^"](rootNum.toString().split(""), initialCommand)) + "\u221A";
    };
    if (arg.length >= 2) {
        output += "(" + addSymbolArray(arg, initialCommand + "{" + arg.join("") + "}") + ")";
    } else {
        output += addSymbolArray(arg, initialCommand + "{" + arg.join("") + "}");
    };
    return output;
};


const sqrtNoArg = (arg, initialCommand) => {
    if (arg !== undefined) {
        mistakes(initialCommand + " does not take in arguments and should take the form \\sqrt[n]*", undefined, "ⁿ√  (use \\sqrt[n]{x} to get ⁿ√𝑥)");
        return addSymbol(undefined);
    };
    const numStart = parseInt(initialCommand.indexOf("["));
    const numEnd = parseInt(initialCommand.indexOf("]"));
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]*", undefined, "ⁿ√");
            return addSymbol(undefined);
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output = "";
    switch (rootNum) {
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(mathDictionary["^"](rootNum.toString().split(""), initialCommand)) + "\u221A";
    };
    return output;
};

const frac = (arg, initialCommand) => {
    let output = "";
    let nume = [];
    let deno = [];
    let numerator = true;
    for (let i in arg) {
        if (numerator) {
            if (arg[i] === "}") {
                numerator = false;
            } else {
                nume.push(arg[i]);
            };
        } else {
            if (arg[i] === "{") {
                if (arg[i - 1] === "}") {
                    output += addSymbol(mathDictionary["^"](nume, initialCommand, true)) + "\u2215";
                } else {
                    deno.push(arg[i]);
                };
            } else {
                deno.push(arg[i]);
            };
        };
    };
    output += addSymbol(mathDictionary["_"](deno, initialCommand, true));
    if (output.indexOf("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") === -1) {
        return output;
    } else {
        output = "";
        numerator = true;
        nume = [];
        deno = [];
        for (let i in arg) {
            if (numerator) {
                if (arg[i] === "}") {
                    numerator = false;
                } else {
                    nume.push(arg[i]);
                };
            } else {
                if (arg[i] === "{") {
                    if (arg[i - 1] === "}") {
                        output += "(" + addSymbolArray(nume, "\\frac{" + arg.join("") + "}") + "/";
                    } else {
                        deno.push(arg[i]);
                    };
                } else {
                    deno.push(arg[i]);
                };
            };
        };
        output += addSymbolArray(deno, "\\frac{" + arg.join("") + "}") + ")";
        return output;
    };
};

const singleCharFrac = (arg, initialCommand) => {
    let noSpaceArg = arg.join("").replace(/ /g, "");
    const fractions = {
        "1}{2" : "\u00BD",
        "1}{7" : "⅐",
        "1}{9" : "⅑",
        "1}{10" : "⅒",
        "1}{3"  :"⅓",
        "2}{3" : "⅔",
        "1}{5" : "⅕",
        "2}{5" : "⅖",
        "3}{5" : "⅗",
        "4}{5" : "⅘",
        "1}{6" : "⅙",
        "5}{6" : "⅚",
        "1}{8" : "⅛",
        "3}{8" : "⅜",
        "5}{8" : "⅝",
        "7}{8" : "⅞",
        "a}{c" : "\u2100",
        "a}{s" : "\u2101",
        "c}{o" : "\u2105",
        "c}{u" : "\u2106"
    };
    let output = fractions[noSpaceArg];
    return (output !== undefined) ? output : frac(arg, initialCommand);
};

const combineSymbols = (arg, initialCommand, symbol, forTwo=undefined) => {
    // "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}"  ->  error symbol
    let textComb = [];
    if ((arg.length === 2) && (forTwo !== undefined)) {
        textComb.push(arg[0] + forTwo + arg[1]);
        mistakes(initialCommand + "{\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}" + arg[1] + "}", arg[0], "Argument doesn't exist");
        mistakes(initialCommand + "{" + arg[0] + "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}}", arg[1], "Argument doesn't exist");
    } else {
        let err = [];
        for (let c in arg) {
            if (arg[c] !== undefined) {
                textComb.push(arg[c] + symbol);
                err.push(arg[c]);
            } else {
                textComb.push("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}");
                err.push("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}");
            };
        };
        if (err.includes("\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}")) {
            mistakes(initialCommand + "{" + err.join("") + "}", undefined, "Argument doesn't exist")
        };
    };
    return textComb;
};

const overline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0305")};

const underline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0332")};

const vec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D7")};

const hvec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D1")};

const overfrown = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0361", "\u0361")};

const oversmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035D", "\u035D")};

const undersmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035C", "\u035C")};

const hat = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0302")};

const not = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0338")};

const tilde = (arg, initialCommand) => {if ((arg == "\u27F6") || (arg == "\u2192")) {return ["\u2972"]} else {return combineSymbols(arg, initialCommand, "\u0303", "\u0360")}};

const dot = (arg, initialCommand) => {if ((arg == "=") || (arg == "\u003D")) {return ["\u2250"]} else if (arg == "\u2261") {return ["\u2A67"]} else {return combineSymbols(arg, initialCommand, "\u0307")}};

const ddot = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0308")};

const underarrow = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0362", "\u0362")};

const underharpoon = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20EC")};

const acute = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0301")};

const grave = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0300")};

const above = (arg, initialCommand) => {
    if (arg.length > 1) {
        return mistakes(initialCommand + "{" + arg.join("") + "}", undefined, "Only one argument accepted");
    };
    const symbols = {
        "." : "\u0307",
        ":" : "\u0308",
        "\u2236" : "\u0308",
        "=" : "\u033F",
        "∞" : "\u1AB2", // Only works on certain website/apps
        "∘" : "\u030A",
        "°" : "\u030A",
        "a" : "\u0363",
        "𝑎" : "\u0363",
        "b" : "\u1DE8",
        "𝑏" : "\u1DE8",
        "c" : "\u0368",
        "𝑐" : "\u0368",
        "d" : "\u0369",
        "𝑑" : "\u0369",
        "e" : "\u0364",
        "𝑒" : "\u0364",
        "f" : "\u1DEB",
        "𝑓" : "\u1DEB",
        "h" : "\u036A",
        "ℎ" : "\u036A",
        "i" : "\u0365",
        "𝑖" : "\u0365",
        "k" : "\u1DDC",  // Only works on certain website/apps
        "𝑘" : "\u1DDC",
        "m" : "\u036B",
        "𝑚" : "\u036B",
        "N" : "\u1DE1",
        "𝑁" : "\u1DE1",
        "n" : "\u1DE0",  // Only works on certain website/apps
        "𝑛" : "\u1DE0",
        "o" : "\u0366",
        "𝑜" : "\u0366",
        "R" : "\u1DE2",
        "𝑅" : "\u1DE2",
        "r" : "\u036C",
        "𝑟" : "\u036C",
        "t" : "\u036D",
        "𝑡" : "\u036D",
        "u" : "\u0367",
        "𝑢" : "\u0367",
        "v" : "\u036E",
        "𝑣" : "\u036E",
        "x" : "\u036F",
        "𝑥" : "\u036F",

        "𝛼" : "\u1DE7",
        "𝛽" : "\u1DE9",

        "↼" : "\u20D0",
        "⇀" : "\u20D1",
        "↔" : "\u20E1",
        "↶" : "\u20D4",
        "↷" : "\u20D5",
        "←" : "\u20D6",
        "→" : "\u20D7",
        "↓" : "\u1AB3",
        "∴" : "\u1AB4",
        "⋯" : "\u20DB",
        "…" : "\u20DB",
        " " : " "
    };
    mistakes(initialCommand + "{" + arg.join("") + "}", symbols[arg[0]], (arg[0] !== undefined) ? arg[0] : "Argument doesn't exist");
    return symbols[arg[0]];
};

const below = (arg, initialCommand) => {
    if (arg.length > 1) {
        return mistakes(initialCommand + "{" + arg.join("") + "}", undefined, "Only one argument accepted");
    };
    const symbols = {
        "." : "\u0323",
        ":" : "\u0324",
        "\u2236" : "\u0324",
        "=" : "\u0333",
        "m" : "\u1AC0",
        "𝑚" : "\u1AC0",
        "x" : "\u0353",
        "𝑥" : "\u0353",
        "w" : "\u1ABF",
        "𝑤" : "\u1ABF",
        "↽" : "\u20ED",
        "⇁" : "\u20EC",
        "←" : "\u20EE",
        "→" : "\u20EF",
        "↔" : "\u034D",
        " " : " "
    };
    mistakes(initialCommand + "{" + arg.join("") + "}", symbols[arg[0]], (arg[0] !== undefined) ? arg[0] : "Argument doesn't exist");
    return symbols[arg[0]];
};

// Dictionary for text conversion
const mathDictionary = {
    // Math operators
    "\\times" : "\u00D7",
    "\\rtimes" : "\u22CA",
    "\\ltimes" : "\u22C9",
    "\\div" : "\u00F7",
    "\\longdiv" : "\u27CC",
    "\\int" : "\u222B",
    "\\iint" : "\u222C",
    "\\iiint" : "\u222D",
    "\\iiiint" : "\u2A0C",
    "\\oint" : "\u222E",
    "\\oiint" : "\u222F",
    "\\oiiint" : "\u2230",
    "\\intclockwise" : "\u2231",
    "\\ointclockwise" : "\u2232",
    "\\ointctrclockwise" : "\u2233",
    "\\sqint" : "\u2A16",
    "\\fint" : "\u2A0F",
    "\\cupint" : "\u2A1A",
    "\\capint" : "\u2A19",
    "\\overbarint" : "\u2A1B",
    "\\underbarint" : "\u2A1C",
    "\\cupplus" : "\u228E",
    "\\timesint" : "\u2A18",
    "\\ast" : "\u2217",
    "\\star" : "\u22C6",
    "\\partial" : "\u2202",
    "\\nabla" : "\u2207",
    "\\sqrt2" : "\u221A",
    "\\sqrt3" : "\u221B",
    "\\sqrt4" : "\u221C",
    "\\circ" : "\u2218",
    "\\sum" : "\u2211",
    "\\osum" : "\u2A0A",
    "\\sumint" : "\u2A0B",
    "\\prod" : "\u220F",
    "\\cdot" : "\u00B7",
    "\\cdotp" : "\u22C5",
    "\\pm" : "\u00B1",
    "\\mp" : "\u2213",
    "\\emptyset" : "\u2205",
    "\\sin" : "sin",
    "\\cos" : "cos",
    "\\tan" : "tan",
    "\\arcsin" : "arcsin",
    "\\arccos" : "arccos",
    "\\arctan" : "arctan",
    "\\cot" : "cot",
    "\\csc" : "csc",
    "\\sec" : "sec",
    "\\arccot" : "arccot",
    "\\arccsc" : "arccsc",
    "\\arcsec" : "arcsec",
    "\\*" : "*",
    "\\det" : "det",
    "\\rank" : "rank",
    "\\log" : "log",
    "\\ln" : "ln",
    "\\lim" : "lim",
    "\\mod" : "mod",
    "\\Mod" : "Mod",
    "\\cup" : "\u222A",
    "\\Cup" : "\u22D3",
    "\\sqcup" : "\u2294",
    "\\sqCup" : "\u2A4F",
    "\\cap" : "\u2229",
    "\\Cap" : "\u22D2",
    "\\sqcap" : "\u2293",
    "\\sqCap" : "\u2A4E",
    "\\uplus" : "\u228E",
    "\\def" : "\u225D",
    "\\vee" : "\u2228",
    "\\doublevee" : "\u2A56",
    "\\wedge" : "\u2227",
    "\\doublewedge" : "\u2A55",
    "\\curlyvee" : "\u22CE",
    "\\curlywedge" : "\u22CF",
    "\\diamond" : "\u22C4",
    "\\wr" : "\u2240",
    "\\oplus" : "\u2295",
    "\\ominus" : "\u2296",
    "\\otimes" : "\u2297",
    "\\oslash" : "\u2298",
    "\\odot" : "\u2299",
    "\\obullet" : "\u29BF",
    "\\ocirc" : "\u29BE",
    "\\operp" : "\u29B9",
    "\\oparallel" : "\u29B7",
    "\\oast" : "\u229B",
    "\\oeq" : "\u229C",
    "\\opluslhrim" : "\u2A2D",
    "\\oplusrhrim" : "\u2A2E",
    "\\otimeslhrim" : "\u2A34",
    "\\otimesrhrim" : "\u2A35",
    "\\boxplus" : "\u229E",
    "\\boxminus" : "\u229F",
    "\\boxtimes" : "\u22A0",
    "\\boxdot" : "\u22A1",
    "\\amalg" : "\u2210",
    "\\tprime" : "\u2034",
    "\\lthree" : "\u22CB",
    "\\rthree" : "\u22CC",
    "\\pitchfork" : "\u22D4",
    "\\topfork" : "\u2ADA",
    "\\invamp" : "\u214B",
    "\\originalof" : "\u22B6",
    "\\imageof" : "\u22B7",
    "\\multimap" : "\u22B8",
    "\\leftmultimap" : "\u27DC",
    "\\uptack" : "\u27DF",
    "\\xor" : "\u22BB",
    "\\nand" : "\u22BC",
    "\\nor" : "\u22BD",
    "\\divideontimes" : "\u22C7",
    "\\smashtimes" : "\u2A33",
    "\\fracline" : "\u2215",  // Better suited for superscript over subscript

    // Relations
    "\\forall" : "\u2200",
    "\\exists" : "\u2203",
    "\\nexists" : "\u2204",
    "\\land" : "\u2227",
    "\\lor" : "\u2228",
    "\\sqland" : "\u27CE",
    "\\sqlor" : "\u27CF",
    "\\in" : "\u2208",
    "\\notin" : "\u2209",
    "\\ni" : "\u220B",
    "\\subset" : "\u2282",
    "\\nsubset" : "\u2284",
    "\\subseteq" : "\u2286",
    "\\nsubseteq" : "\u2288",
    "\\supset" : "\u2283",
    "\\nsupset" : "\u2285",
    "\\supseteq" : "\u2287",
    "\\nsupseteq" : "\u2289",
    "\\sqsubset" : "\u228F",
    "\\sqsupset" : "\u2290",
    "\\sqsubseteq" : "\u2291",
    "\\sqsupseteq" : "\u2292",
    "\\Subset" : "\u22D0",
    "\\Supset" : "\u22D1",
    "\\subsetplus" : "\u2ABF",
    "\\supsetplus" : "\u2AC0",
    "\\osubset" : "\u27C3",
    "\\osupset" : "\u27C4",
    "\\setminus" : "\u2216",
    "\\cong" : "\u2245",
    "\\ncong" : "\u2247",
    "\\propto" : "\u221D",
    "\\equiv" : "\u2261",
    "\\dotequiv" : "\u2A67",
    "\\superequiv" : "\u2263",
    "\\tbond" : "\u2261",
    "\\qbond" : "\u2263",
    "\\doteq" : "\u2250",
    "\\eqdot" : "\u2A66",
    "\\neq" : "\u2260",
    "\\approx" : "\u2248",
    "\\sim" : "\u223C",
    "\\simeq" : "\u224C",
    "\\nsim" : "\u2241",
    "\\nless" : "\u226E",
    "\\ngtr" : "\u226F",
    "\\leq" : "\u2264",
    "\\leqslant" : "\u2A7D",
    "\\geq" : "\u2265",
    "\\geqslant" : "\u2A7E",
    "\\nleq" : "\u2270",
    "\\ngeq" : "\u2271",
    "\\lneq" : "\u2A87",
    "\\lneqq" : "\u2268",
    "\\gneq" : "\u2A88",
    "\\gneqq" : "\u2269",
    "\\lnapprox" : "\u2A89",
    "\\gnapprox" : "\u2A8A",
    "\\lnsim" : "\u22E6",
    "\\gnsim" : "\u22E7",
    "\\ll" : "\u226A",
    "\\lll" : "\u22D8",
    "\\gg" : "\u226B",
    "\\ggg" : "\u22D9",
    "\\prec" : "\u227A",
    "\\succ" : "\u227B",
    "\\nprec" : "\u2280",
    "\\nsucc" : "\u2281",
    "\\preceq" : "\u227C",
    "\\succeq" : "\u227D",
    "\\precneqq" : "\u2AB5",
    "\\succneqq" : "\u2AB6",
    "\\precnapprox" : "\u2AB9",
    "\\succnapprox" : "\u2ABA",
    "\\precnsim" : "\u22E8",
    "\\succnsim" : "\u22E9",
    "\\perp" : "\u27C2",
    "\\Perp" : "\u2AEB",
    "\\parallel" : "\u2225",
    "\\nparallel" : "\u2226",
    "\\vvvert" : "\u2AF4",
    "\\nvvvert" : "\u2AF5",
    "\\mid" : "|",
    "\\nmid" : "\u2224",
    "\\asymp" : "\u224D",
    "\\neg" : "\u00AC",
    "\\bowtie" : "\u2A1D",
    "\\vdash" : "\u22A2",
    "\\nvdash" : "\u22AC",
    "\\dashv" : "\u22A3",
    "\\vDash" : "\u22A8",
    "\\Dashv" : "\u2AE4",
    "\\nvDash" : "\u22AD",
    "\\Vdash" : "\u22A9",
    "\\dashV" : "\u2AE3",
    "\\nVdash" : "\u22AE",
    "\\VDash" : "\u22AB",
    "\\DashV" : "\u2AE5",
    "\\nVDash" : "\u22AF",
    "\\triangleleft" : "\u22B2",
    "\\ntriangleleft" : "\u22EA",
    "\\triangleright" : "\u22B3",
    "\\ntriangleright" : "\u22EB",
    "\\ntrianglelefteq" : "\u22EC",
    "\\ntrianglerighteq" : "\u22ED",
    "\\triangleq" : "\u225C",
    "\\equest" : "\u225F",
    "\\lquest" : "\u2A7B",
    "\\rquest" : "\u2A7C",
    "\\mquest" : "\u225E",
    "\\vdots" : "\u22EE",
    "\\cdots" : "\u22EF",
    "\\udots" : "\u22F0",
    "\\ddots" : "\u22F1",
    "\\ldots" : "\u2026",
    "\\top" : "\u22A4",
    "\\bot" : "\u22A5",
    "\\between" : "\u226C",
    "\\therefore" : "\u2234",
    "\\because" : "\u2235",
    "\\squaredots" : "\u2237",
    "\\dotminus" : "\u2238",
    "\\max" : "max",
    "\\min" : "min",
    "\\grad" : "grad",
    "\\curl" : "curl",
    "\\ratio" : "\u2236",  // Same as ":", except with "$chem"

    // Arrows
    "\\Rightarrow" : "\u21D2",
    "\\Leftarrow" : "\u21D0",
    "\\nLeftarrow" : "\u21CD",
    "\\nRightarrow" : "\u21CF",
    "\\nLeftrightarrow" : "\u21CE",
    "\\Uparrow" : "\u21D1",
    "\\Downarrow" : "\u21D3",
    "\\Updownarrow" : "\u21D5",
    "\\rightarrow" : "\u2192",
    "\\longrightarrow" : "\u27F6",
    "\\leftarrow" : "\u2190",
    "\\longleftarrow" : "\u27F5",
    "\\leftrightarrow" : "\u2194",
    "\\nleftrightarrow" : "\u21AE",
    "\\uparrow" : "\u2191",
    "\\downarrow" : "\u2193",
    "\\updownarrow" : "\u2195",
    "\\nleftarrow" : "\u219A",
    "\\nrightarrow" : "\u219B",
    "\\Longleftarrow" : "\u27F8",
    "\\implies" : "\u27F9",
    "\\Longrightarrow" : "\u27F9",
    "\\Leftrightarrow" : "\u21D4",
    "\\iff" : "\u27FA",
    "\\mapsto" : "\u27FC",
    "\\rightleftharpoons" : "\u21CC",
    "\\leftrightharpoons" : "\u21CB",
    "\\rightharpoonup" : "\u21C0",
    "\\rightharpoondown" : "\u21C1",
    "\\leftharpoonup" : "\u21BC",
    "\\leftharpoondown" : "\u21BD",
    "\\upharpoonleft" : "\u21BF",
    "\\upharpoonright" : "\u21BE",
    "\\downharpoonleft" : "\u21C3",
    "\\downharpoonright" : "\u21C2", 
    "\\hookleftarrow" : "\u21A9",
    "\\hookrightarrow" : "\u21AA",
    "\\nearrow" : "\u2197",
    "\\searrow" : "\u2198",
    "\\swarrow" : "\u2199",
    "\\nwarrow" : "\u2196",
    "\\Nearrow" : "\u21D7",
    "\\Searrow" : "\u21D8",
    "\\Swarrow" : "\u21D9",
    "\\Nwarrow" : "\u21D6",
    "\\twoheadleftarrow" : "\u219E",
    "\\twoheadrightarrow" : "\u21A0",
    "\\twoheaduparrow" : "\u219F",
    "\\twoheaddownarrow" : "\u21A1",
    "\\Lsh" : "\u21B0",
    "\\Rsh" : "\u21B1",
    "\\leftleftarrows" : "\u21C7",
    "\\rightrightarrows" : "\u21C9",
    "\\rightrightrightarrows" : "\u21F6",
    "\\upuparrows" : "\u21C8",
    "\\downdownarrows" : "\u21CA",
    "\\leftrightarrows" : "\u21C6",
    "\\rightleftarrows" : "\u21C4",
    "\\Lleftarrow" : "\u21DA",
    "\\Rrightarrow" : "\u21DB",
    "\\Uuparrow" : "\u290A",
    "\\Ddownarrow" : "\u290B",
    "\\leftarrowtail" : "\u21A2",
    "\\rightarrowtail" : "\u21A3",
    "\\leftsquigarrow" : "\u21DC",
    "\\rightsquigarrow" : "\u21DD",
    "\\leftrightsquigarrow" : "\u21AD",
    "\\longrightsquiglearrow" : "\u27FF",
    "\\looparrowleft" : "\u21AB",
    "\\looparrowright" : "\u21AC",
    "\\circlearrowleft" : "\u21BA",
    "\\circlearrowright" : "\u21BB",
    "\\curvearrowleft" : "\u21B6",
    "\\curvearrowright" : "\u21B7",
    "\\leftdasharrow" : "\u21E0",
    "\\rightdasharrow" : "\u21E2",
    "\\updasharrow" : "\u21E1",
    "\\downdasharrow" : "\u21E3",
    "\\tildeabovearrow" : "\u2972",
    "\\tildebelowarrow" : "\u2974",
    "\\equalabovearrow" : "\u2971",

    // Greek alphabet
    "\\Alpha" : "\u{1D6E2}",
    "\\alpha" : "\u{1D6FC}",
    "\\Beta" : "\u{1D6E3}",
    "\\beta" : "\u{1D6FD}",
    "\\Gamma" : "\u{1D6E4}",
    "\\gamma" : "\u{1D6FE}",
    "\\Delta" : "\u0394",
    "\\delta" : "\u03B4",
    "\\Epsilon" : "\u{1D6E6}",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u{1D6E7}",
    "\\zeta" : "\u{1D701}",
    "\\Eta" : "\u{1D6E8}",
    "\\eta" : "\u{1D702}",
    "\\Theta" : "\u0398",
    "\\theta" : "\u{1D703}",
    "\\vartheta" : "\u03D1",
    "\\Iota" : "\u{1D6EA}",
    "\\iota" : "\u{1D704}",
    "\\Kappa" : "\u{1D6EB}",
    "\\kappa" : "\u{1D705}",
    "\\varkappa" : "\u{1D718}",
    "\\Lambda" : "\u039B",
    "\\lambda" : "\u03BB",
    "\\Mu" : "\u{1D6ED}",
    "\\mu" : "\u{1D707}",
    "\\Nu" : "\u{1D6EE}",
    "\\nu" : "\u{1D708}",
    "\\Xi" : "\u039E",
    "\\xi" : "\u{1D709}",
    "\\Omicron" : "\u{1D6F0}",
    "\\omicron" : "\u{1D70A}",
    "\\Pi" : "\u03A0",
    "\\pi" : "\u{1D70B}",
    "\\varpi" : "\u{1D71B}",
    "\\Rho" : "\u{1D6F2}",
    "\\rho" : "\u{1D70C}",
    "\\varrho" : "\u03F1",
    "\\Sigma" : "\u03A3",
    "\\sigma" : "\u03C3",
    "\\varsigma" : "\u03C2",
    "\\Tau" : "\u{1D6F5}",
    "\\tau" : "\u{1D70F}",
    "\\Upsilon" : "\u{1D6F6}",
    "\\upsilon" : "\u{1D710}",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u{1D719}",
    "\\varphi" : "\u{1D711}",
    "\\Chi" : "\u{1D6F8}",
    "\\chi" : "\u{1D712}",
    "\\Psi" : "\u{1D6F9}",
    "\\psi" : "\u{1D713}",
    "\\Omega" : "\u2126",
    "\\omega" : "\u{1D714}",

    // Hebrew alphabet
    "\\aleph" : "\u2135",
    "\\beth" : "\u2136",
    "\\gimel" : "\u2137",
    "\\dalet" : "\u2138",

    // Convert text
    "\\mathbb" : mathbb,
    "\\mathbf" : mathbf,
    "\\mathcal" : mathcal,
    "\\mathfrak" : mathfrak,
    "^" : superscript,
    "_" : subscript,
    "\\text" : text,
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,

    // Spaces
    "\\hspace" : hspace,
    "\\vskip" : vskip,

    // Square root and fractions
    "\\sqrt" : sqrt,
    "\\sqrt*" : sqrtNoArg,
    "\\frac" : frac,
    "\\frac*" : singleCharFrac,

    // Combining symbols
    "\\overline" : overline,
    "\\underline" : underline,
    "\\underarrow" : underarrow,
    "\\underharpoon" : underharpoon,
    "\\overfrown" : overfrown,
    "\\oversmile" : oversmile,
    "\\undersmile" : undersmile,
    "\\hat" : hat,
    "\\not" : not,
    "\\tilde" : tilde,
    "\\vec" : vec,
    "\\hvec" : hvec,
    "\\dot" : dot,
    "\\ddot" : ddot,
    "\\acute" : acute,
    "\\grave" : grave,

    // For Lewis Notation
    "\\above" : above,
    "\\below" : below,
    "\\mid." : "\u2E31",
    "\\mid:" : "\u003A",

    // Chess
    "\\wking" : "\u2654",
    "\\wqueen" : "\u2655",
    "\\wrook" : "\u2656",
    "\\wbishop" : "\u2657",
    "\\wknight" :"\u2658",
    "\\wpawn" : "\u2659",
    "\\bking" : "\u265A",
    "\\bqueen" : "\u265B",
    "\\brook" : "\u265C",
    "\\bbishop" : "\u265D",
    "\\bknight" :"\u265E",
    "\\bpawn" : "\u265F",

    // Card games
    "\\bspade" : "\u2660",
    "\\wheart" : "\u2661",
    "\\wdiamond" : "\u2662",
    "\\bclub" : "\u2663",
    "\\wspade" : "\u2664",
    "\\bheart" : "\u2665",
    "\\bdiamond" : "\u2666",
    "\\wclub" : "\u2667",

    // Money
    "\\dollar" : "\u0024",
    "\\cent" : "\u00A2",
    "\\pound" : "\u00A3",
    "\\yen" : "\u00A5",
    "\\franc" : "\u20A3",
    "\\euro" : "\u20AC",
    "\\peso" : "\u20B1",
    "\\bitcoin" : "\u20BF",
    "\\austral" : "\u20B3",
    "\\ruble" : "\u20BD",
    "\\hryvnia" : "\u20B4",
    "\\rupee" : "\u20B9",
    "\\lira" : "\u20AA",
    "\\tlira" : "\u20A9",
    "\\won" : "\u20A9",
    "\\baht" : "\u0E3F",

    // Non italic letters
    "\\A" : "A",
    "\\À" : "À",
    "\\a" : "a",
    "\\à" : "à",
    "\\B" : "B",
    "\\b" : "b",
    "\\C" : "C",
    "\\Ç" : "Ç",
    "\\c" : "c",
    "\\ç" : "ç",
    "\\D" : "D",
    "\\d" : "d",
    "\\E" : "E",
    "\\É" : "É",
    "\\È" : "È",
    "\\e" : "e",
    "\\é" : "é",
    "\\è" : "è",
    "\\F" : "F",
    "\\f" : "f",
    "\\G" : "G",
    "\\g" : "g",
    "\\H" : "H",
    "\\h" : "h",
    "\\I" : "I",
    "\\i" : "i",
    "\\J" : "J",
    "\\j" : "j",
    "\\K" : "K",
    "\\k" : "k",
    "\\L" : "L",
    "\\l" : "l",
    "\\M" : "M",
    "\\m" : "m",
    "\\N" : "N",
    "\\n" : "n",
    "\\O" : "O",
    "\\o" : "o",
    "\\P" : "P",
    "\\p" : "p",
    "\\Q" : "Q",
    "\\q" : "q",
    "\\R" : "R",
    "\\r" : "r",
    "\\S" : "S",
    "\\s" : "s",
    "\\T" : "T",
    "\\t" : "t",
    "\\U" : "U",
    "\\u" : "u",
    "\\Ù" : "Ù",
    "\\ù" : "ù",
    "\\V" : "V",
    "\\v" : "v",
    "\\W" : "W",
    "\\w" : "w",
    "\\X" : "X",
    "\\x" : "x",
    "\\Y" : "Y",
    "\\y" : "y",
    "\\Z" : "Z",
    "\\z" : "z",

    "\\^" : "^",
    "\\_" : "_",

    // Matrix
    "\\id1" : "[1]",
    "\\id2" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u23A4 \u000A \u23A3 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id3" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\id4" : "\u23A1 \u2710 1 \u2710 0 \u2710 0 \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 0 \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 0 \u2710 0 \u2710 1 \u2710 0 \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 0 \u2710 1 \u2710 \u23A6",
    "\\idn" : "\u23A1 \u2710 1 \u2710 0 \u2710 \u22EF \u2710 0 \u2710 \u23A4 \u000A \u23A2 \u2710 0 \u2710 1 \u2710 \u22EF \u2710 0 \u2710 \u23A5 \u000A \u23A2 \u2710 \u2710 \u22EE \u2710 \u2710 \u22EE \u2710 \u2710 \u22F1 \u2710 \u2710 \u22EE \u2710 \u23A5 \u000A \u23A3 \u2710 0 \u2710 0 \u2710 \u22EF \u2710 1 \u2710 \u23A6",
    
    // To build your own
    "\\mlceil" : "\u23A1",
    "\\mrceil" : "\u23A4",
    "\\mlmid" : "\u23A2",
    "\\mrmid" : "\u23A5",
    "\\mlfloor" : "\u23A3",
    "\\mrfloor" : "\u23A6",

    // Music
    "\\flat" : "\u{1D12C}",
    "\\natural" : "\u{1D12E}",
    "\\sharp" : "\u{1D130}",
    "\\eightnote" : "\u{1D160}",
    "\\sixteenthnote" : "\u{1D161}",
    "\\halfnote" : "\u{1D15E}",
    "\\quarternote" : "\u{1D15F}",
    "\\fullnote" : "\u{1D15D}",
    "\\doublenote" : "\u266B",
    "\\trebleclef" : "\u{1D11E}",
    
    // Box drawing
    "\\boxh" : "\u2500",
    "\\boxbfh" : "\u2501",
    "\\boxH" : "\u2550",
    "\\boxv" : "\u2502",
    "\\boxbfv" : "\u2503",
    "\\boxV" : "\u2551",
    "\\boxdr" : "\u250C",
    "\\boxbfdr" : "\u250F",
    "\\boxDR" : "\u2554",
    "\\boxdl" : "\u2510",
    "\\boxbfdl" : "\u2513",
    "\\boxDL" : "\u2557",
    "\\boxur" : "\u2514",
    "\\boxbfur" : "\u2517",
    "\\boxUR" : "\u255A",
    "\\boxul" : "\u2518",
    "\\boxbful" : "\u251B",
    "\\boxUL" : "\u255D",
    "\\boxvr" : "\u251C",
    "\\boxbfvr" : "\u2523",
    "\\boxVR" : "\u2560",
    "\\boxvl" : "\u2524",
    "\\boxbfvl" : "\u252B",
    "\\boxVL" : "\u2563",
    "\\boxdh" : "\u252C",
    "\\boxbfdh" : "\u2533",
    "\\boxDH" : "\u2566",
    "\\boxuh" : "\u2534",
    "\\boxbfuh" : "\u253B",
    "\\boxUH" : "\u2569",
    "\\boxvh" : "\u253C",
    "\\boxbfvh" : "\u254B",
    "\\boxVH" : "\u256C",

    // Other symbols
    "\\LaTeX" : "𝐿ᴬ𝑇ᴇ𝑋",
    "\\TeX" : "𝑇ᴇ𝑋",
    "\\MatTalX" : "𝑀ᴀᴛ𝑇ᴀʟ𝑋",
    "\\CaMuS" : "𝐶ᴬ𝑀ᴜ𝑆",  // http://camus.math.usherbrooke.ca/index.html
    "\\infty" : "\u221E",
    "\\iinfin" : "\u29DC",
    "\\tieinfty" : "\u29DD",
    "\\nvinfty" : "\u29DE",
    "\\acidfree" : "\u267E",
    "\\radioactive" : "\u2622",
    "\\biohazard" : "\u2623",
    "\\atom" : "\u269B",
    "\\angle" : "\u2220",
    "\\measuredangle" : "\u2221",
    "\\sphericalangle" : "\u2222",
    "\\rightangle" : "\u299C",
    "\\hbar" : "\u210F",
    "\\ell" : "\u2113",
    "\\dagger" : "\u2020",
    "\\ddagger" : "\u2021",
    "\\hermitian" : "\u22B9",
    "\\qc" : "\u269C",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\wp" : "\u2118",
    "\\laplace" : "\u2112",
    "\\bloch" : "\u212C",
    "\\im" : "\u2111",
    "\\fourier" : "\u2131",
    "\\angstrom" : "\u212B",
    "\\emdash" : "\u2014",
    "\\bullet" : "\u2219",
    "\\textbullet" : "\u2022",
    "\\bigbullet" : "\u25CF",
    "\\langle" : "\u27E8",
    "\\rangle" : "\u27E9",
    "\\llangle" : "\u27EA",
    "\\rrangle" : "\u27EB",
    "\\lceil" : "\u2308",
    "\\rceil" : "\u2309",
    "\\lfloor" : "\u230A",
    "\\rfloor" : "\u230B",
    "\\lBrace" : "\u2983",
    "\\rBrace" : "\u2984",
    "\\%" : "%",
    "\\{" : "{",
    "\\}" : "}",
    "\\(" : "(",
    "\\)" : ")",
    "\\[" : "[",
    "\\]" : "]",
    "\\backslash" : "\\",
    "\\llbracket" : "\u27E6",
    "\\rrbracket" : "\u27E7",
    "\\llparenthesis" : "\u2985",
    "\\rrparenthesis" : "\u2986",
    "\\frown" : "\u2322",
    "\\smile" : "\u2323",
    "\\qed" : "\u220E",
    "\\blacksquare" : "\u25A0",
    "\\square" : "\u25A1",
    "\\lightning" : "\u21AF",
    "\\male" : "\u2642",
    "\\female" : "\u2640",
    "\\Hermaphrodite" : "\u26A5",
    "\\neuter" : "\u26B2",
    "\\malemale" : "\u26A3",
    "\\femalefemale" : "\u26A2",
    "\\femalemale" : "\u26A4",
    "\\" : "\\",
    "\\:" : "\u2710",  // Space (internally represented with \u2710 ✐, but switched to a real space before output)
    "\\;" : "\u2710\u2710",  // Double space
    "\\quad" : "\u2710\u2710\u2710",
    "\\qquad" : "\u2710\u2710\u2710\u2710",
    "\\colon" : "\u003A",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009"
};

const lettersSymbols = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "°" : "°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "$" : "$",
    "*" : "*",
    "@" : "@",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "\u003C",
    ">" : "\u003E",
    "^" : "^",
    "_" : "_",
    "%" : "%",
    "#" : "#",
    "~" : "~",
    "¬" : "¬",
    ":" : "\u2236",
    ";" : ";",
    "…" : "…",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "\u{1D434}",
    "a" : "\u{1D44E}",
    "B" : "\u{1D435}",
    "b" : "\u{1D44F}",
    "C" : "\u{1D436}",
    "c" : "\u{1D450}",
    "D" : "\u{1D437}",
    "d" : "\u{1D451}",
    "E" : "\u{1D438}",
    "e" : "\u{1D452}",
    "F" : "\u{1D439}",
    "f" : "\u{1D453}",
    "G" : "\u{1D43A}",
    "g" : "\u{1D454}",
    "H" : "\u{1D43B}",
    "h" : "\u210E",
    "I" : "\u{1D43C}",
    "i" : "\u{1D456}",
    "J" : "\u{1D43D}",
    "j" : "\u{1D457}",
    "K" : "\u{1D43E}",
    "k" : "\u{1D458}",
    "L" : "\u{1D43F}",
    "l" : "\u{1D459}",
    "M" : "\u{1D440}",
    "m" : "\u{1D45A}",
    "N" : "\u{1D441}",
    "n" : "\u{1D45B}",
    "O" : "\u{1D442}",
    "o" : "\u{1D45C}",
    "P" : "\u{1D443}",
    "p" : "\u{1D45D}",
    "Q" : "\u{1D444}",
    "q" : "\u{1D45E}",
    "R" : "\u{1D445}",
    "r" : "\u{1D45F}",
    "S" : "\u{1D446}",
    "s" : "\u{1D460}",
    "T" : "\u{1D447}",
    "t" : "\u{1D461}",
    "U" : "\u{1D448}",
    "u" : "\u{1D462}",
    "V" : "\u{1D449}",
    "v" : "\u{1D463}",
    "W" : "\u{1D44A}",
    "w" : "\u{1D464}",
    "X" : "\u{1D44B}",
    "x" : "\u{1D465}",
    "Y" : "\u{1D44C}",
    "y" : "\u{1D466}",
    "Z" : "\u{1D44D}",
    "z" : "\u{1D467}",
    " " : " "
};

const lettersChem = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "°" : "°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "\u003C",
    ">" : "\u003E",
    "^" : "^",
    "_" : "_",
    "%" : "%",
    "$" : "$",
    "*" : "*",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "¬" : "¬",
    ":" : ":",  // Same as "\colon", use "\ratio" instead to get the same as without "$chem"
    ";" : ";",
    "…" : "…",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "À" : "À",
    "a" : "a",
    "à" : "à",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "Ç" : "Ç",
    "c" : "c",
    "ç" : "ç",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "É" : "É",
    "È" : "È",
    "e" : "e",
    "é" : "é",
    "è" : "è",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "i" : "i",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "o" : "o",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "Ù" : "Ù",
    "ù" : "ù",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    " " : " "
};

// Submit button
const submit = document.getElementById("button");
submit.onclick = function() {main()};

// Copy button
const copyButton = document.getElementById("copy");
copyButton.onclick = function() {copyTextOut()};

// Clear button
const resetButton = document.getElementById("reset");
resetButton.onclick = function() {clear()};

// Remove spaces button
const spacesButton = document.getElementById("adjust");

// Originally hidden
const suggestionsPopup = document.getElementById("suggestions");

// Every undefined commands
let errorsList = "";




/// FUNCTIONS ///

// Saves the text in the first box so it doesn't disappear if you change page or close MatTalX
window.addEventListener("blur", () => {
    chrome.storage.sync.set({"box1" : document.getElementById("text_in").value});
    chrome.storage.sync.set({"check" : spacesButton.checked});
});

// Retreives the text when the popup reopens
window.addEventListener("focus", () => {
    const textIn = document.getElementById("text_in");
    chrome.storage.sync.get(["box1"], (text) => {
        if (text.box1 !== undefined) {
            textIn.value = text.box1;
        };
    });
    chrome.storage.sync.get(["check"], (button) => {
        // Default is true
        if (button.check === false) {
            spacesButton.checked = false;
        };
    })
    textIn.focus();
});

// Listens for 'message' from background.js
window.addEventListener("DOMContentLoaded", () => {
    const manifest = chrome.runtime.getManifest();
    chrome.storage.local.get("reason", (details) => {
        if (details.reason === "install") {
            firstMessage(manifest.version);
        } else if (details.reason === "update") {
            updateMessage(manifest.version);
        };
    });
    chrome.storage.local.remove("reason");
});

// Message for first time users
function firstMessage(version) {
    // Writes explanation in the two text boxes
    let text = "Welcome to MatTalX version " + version + "! At any moment, you can look at the documentation by putting your mouse above the question mark (?) " + 
    "on the top right corner. MatTalX almost always uses the same command as LaTeX, but there are some differences.";
    let tutorial = "First and foremost, it is important to remember that MatTalX converts the command into text, therefore a command like: \r\n" + 
    "x^{x^{x^{x}}} will give an error, since it can't fit in a line.\r\n \r\n" +
    "Every letter will automatically be converted to a mathematical font, if you do not want that, you can put the text inside the command \\text{}. " + 
    "If you simply want a single letter to not be in the mathematical font, add '\\' before the letter:\r\n" + 
    " a → \u{1d44e} | \\a (or \\text{a}) → a\r\n \r\n" + 
    "As a last tip, if you get an error and the command seems right, the character that you want might not exist in unicode:\r\n" + 
    " x^{y} → 𝑥ʸ | x^{Y} → 𝑥^(𝑌) (ie y exists in superscript but not Y)\r\n \r\n" +
    "But, before jumping to conclusion, please look at the documentation! The command, for various reason, might be different than in LaTeX!";
    document.text_input.text_in.value = text;
    document.text_input.text_out.value = tutorial;
};

// Message after an update
function updateMessage(version) {
    // Writes explanation in the second box
    // To be changed by hand every version
    let majorChanges = "Welcome to MatTalX version " + version + "\r\n \r\n" + 
    "Major changes: \r\n" +
    " 1) Added \\acute{}, \\grave{}, \\hvec{} and \\underharpoon{}\r\n" +
    "  i) \\acute{x} → 𝑥́ \r\n" + 
    "  ii) \\grave{x} → 𝑥̀ \r\n" + 
    "  iii) \\hvec{x} → 𝑥⃑ \r\n" + 
    "  iv) \\underharpoon{x} → 𝑥⃬ \r\n" 
    " 2) 'Ù' and 'ù' can be obtained directly with \\Ù, \\ù or $chem Ù, ù\r\n" + 
    " 3) Added \\lightning, \\square and \\blacksquare\r\n" + 
    "  i) ↯\r\n" +
    "  ii) □\r\n" + 
    "  iii) ■\r\n" + 
    " 4) Added various arrows and letters as argument in the \\above{} and \\below{} commands\r\n" + 
    " 5) Improvements with 'Adjust spaces'";
    document.text_input.text_out.value = majorChanges;
};

// Listens for Alt+S to show suggestions, Alt+I to copy text of the first box (input) and Alt+O to copy text in the second box (output)
document.addEventListener("keydown", (keyPressed) => {
    const textIn = document.getElementById("text_in");
    // Alt+S to shows suggestions but closes the popup if the suggestion box is already opened
    if ((keyPressed.key === "s") && keyPressed.altKey && (textIn == document.activeElement)) {
        if (suggestionsPopup.style.display !== "inline-block") { 
            suggestionsPopup.textContent = "";
            let word = findWord(textIn.value, (textIn.selectionEnd - 1));
            suggestionsPopup.style.display = "inline-block";
            suggestions(word);
        } else {
            closeSuggestions();
        };
    } else if (((keyPressed.code === "Space") || (keyPressed.code === "Tab")) && (suggestionsPopup.style.display === "inline-block")) {
        closeSuggestions();
    } else if ((keyPressed.key === "i") && keyPressed.altKey) {
        copyTextIn();
    } else if ((keyPressed.key === "o") && keyPressed.altKey) {
        copyTextOut();
    } else {
        // If any key is pressed while the suggestion popup is opened, it adjusts the suggestions
        // The word must be adjusted "by hand" because the eventListener is synchronous
        if (suggestionsPopup.style.display === "inline-block") {
            if (keyPressed.key === "Backspace") {
                suggestionsPopup.textContent = "";
                let word = findWord(textIn.value, textIn.selectionEnd - 1, "Backspace");
                suggestions(word);
            } else if (keyPressed.key.length === 1) {
                suggestionsPopup.textContent = "";
                let word = findWord(textIn.value, textIn.selectionEnd - 1, keyPressed.key);
                suggestions(word);
            } else if ((keyPressed.key === "ArrowUp") || (keyPressed.key === "ArrowRight") || (keyPressed.key === "ArrowLeft") || (keyPressed.key === "ArrowDown")) {
                suggestionsPopup.textContent = "";
                const arrows = {"ArrowUp": 0, "ArrowRight": 1, "ArrowLeft": -1, "ArrowDown": 0};
                let word = findWord(textIn.value, (textIn.selectionEnd - 1 + arrows[keyPressed.key]));  // Only adjusts the cursor position for right and left arrows
                suggestions(word);
            };
        };
    };
});

// Finds the word that is touched by the cursor
function findWord(text, cursorPosition, addedLetter="") {
    if (addedLetter.length === 1) {  // ie a letter
        text = text.split("");
        text[cursorPosition] += addedLetter;
        text = text.join("");
    } else if (addedLetter === "Backspace") {
        text = text.split("");
        text[cursorPosition] = "";
        text = text.join("");
        cursorPosition -= 1;
    };
    let word = "";
    const wordsDelimiters = [" ", "", "\u000A", "\\", "^", "_", "(", ")", "[", "]", "{", "}", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"];
    while (!(wordsDelimiters.includes(text.charAt(cursorPosition + 1)))) {
        cursorPosition += 1;
    };
    const wordsDelimitersWOB = [" ", "", "\u000A", "^", "_", "(", ")", "[", "]", "{", "}", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"]; // Without backslash
    while (!(wordsDelimitersWOB.includes(text.charAt(cursorPosition)))) {
        if (text.charAt(cursorPosition) === "\\") {
            word = text.charAt(cursorPosition) + word;
            break;
        } else {
            word = text.charAt(cursorPosition) + word;
            cursorPosition -= 1;
        }
    };
    return word;
};

// Outputs list of other commands that are similar to the one currently being written
function suggestions(command) {
    if (command === "") {
        closeSuggestions();
    } else if (command[0] !== "\\") {
        let row = suggestionsPopup.insertRow(-1);
        let cell = row.insertCell(0);
        cell.textContent = "The first character of the command must be a backslash (\\). Superscript starts with ^ and subscript with _";
    } else {
        const textIn = document.getElementById("text_in");
        command = command.substring(1, command.length);  // Erases the backslash (for instance, \arrow will also show \rightarrow, etc.)
        for (keys in mathDictionary) {
            // Puts commands in button form, so they can be clicked on to replace the command being written
            if (keys.toLowerCase().indexOf(command.toLowerCase()) !== -1) {
                let row = suggestionsPopup.insertRow(-1);
                let cell = row.insertCell(0);
                let btn = document.createElement("button");
                btn.value = showCommand(keys);
                btn.textContent = toReplaceCommand(keys);
                btn.style.width = "130px";
                btn.style.height = "17px";
                btn.style.backgroundColor = "white";
                btn.style.border = "1px solid white";
                btn.style.borderRadius = "3px";
                btn.type = "button";
                btn.addEventListener("click", () => {
                    textIn.value = semiAutoCompletion(textIn.value, textIn.selectionEnd, btn.value);
                    closeSuggestions();
                    textIn.focus();
                });
                // Shows what the command ouputs on mouseover, return to normal on mouseout
                btn.addEventListener("mouseover", () => {
                    let x = btn.textContent;
                    btn.textContent = btn.value;
                    btn.value = x;
                });
                btn.addEventListener("mouseout", () => {
                    let x = btn.textContent;
                    btn.textContent = btn.value;
                    btn.value = x;
                });
                cell.appendChild(btn);
            };
        };
    };
};

// Close and empties the suggestion popup
function closeSuggestions() {
    suggestionsPopup.style.display = "none";
    suggestionsPopup.textContent = "";
};

// Replace the command being written by the selected suggestion
function semiAutoCompletion(textIn, cursorPosition, command) {
    let textOut = textIn;
    // Find end of word
    const wordsDelimiters = [" ", "", "\u000A", "\\", "^", "_", "(", ")", "[", "]", "{", "}", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"];
    while (!(wordsDelimiters.includes(textIn.charAt(cursorPosition)))) {
        cursorPosition += 1;
    };
    // Deletes word
    while (textIn.charAt(cursorPosition - 1) !== "\\") {
        textOut = textOut.substring(0, cursorPosition - 1) + textOut.substring(cursorPosition);
        cursorPosition -= 1;
    };
    // Replace by selected suggestion
    textOut = textOut.substring(0, cursorPosition - 1) + command + textOut.substring(cursorPosition);
    return textOut;
};

// Used in suggestions
function showCommand(key) {
    if (typeof mathDictionary[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[n]{x} \u2192 ⁿ√𝑥";
        } else if (key == "\\sqrt*") {
            return "\\sqrt[n]* \u2192 ⁿ√";
        } else if (key == "\\frac") {
            return "\\frac{1}{2} \u2192 ¹∕₂";
        } else if (key == "\\frac*") {
            return "\\frac*{1}{2} \u2192 ½";
        } else if ((key == "\\above") || (key == "\\below") || (key == "\\hspace") || (key == "\\vskip")) {
            return key + "{}";
        } else if ((key == "_") || (key == "^")) {
            return "x" + key + "{a1} \u2192 𝑥" + (mathDictionary[key](["a", "1"], mathDictionary[key])).join("");
        } else {
            return key + "{abc} \u2192 " + (mathDictionary[key](["a", "b", "c"], mathDictionary[key])).join("");
        };
    } else {
        if (key == "\\:") {
            return "1 space";
        } else if ((key == "\\;") || ((key == "\\quad") || (key == "\\qquad"))) {
            return mathDictionary[key].length + " spaces";
        } else if ((key == "\\id2") || (key == "\\id3") || (key == "\\id4") || (key == "\\idn")) {
            const M = {
                "\\id2": "⎡ 1 0 ⎤\u000A⎣ 0 1 ⎦",
                "\\id3" : "⎡ 1 0 0 ⎤\u000A⎢ 0 1 0 ⎥\u000A⎣ 0 0 1 ⎦",
                "\\id4" : "⎡ 1 0 0 0 ⎤\u000A⎢ 0 1 0 0 ⎥\u000A⎢ 0 0 1 0 ⎥\u000A⎣ 0 0 0 1 ⎦",
                "\\idn" : "⎡ 1 0 ⋯ 0 ⎤\u000A⎢ 0 1 ⋯ 0 ⎥\u000A⎢  ⋮  ⋮  ⋱  ⋮ ⎥\u000A⎣ 0 0 ⋯ 1 ⎦"
            }
            return M[key];
        } else {
            return mathDictionary[key]
        };
    };
};

// Used in suggestions
function toReplaceCommand(key) {
    if (typeof mathDictionary[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[]{}";
        } else if (key == "\\sqrt*") {
            return "\\sqrt[]*";
        } else if (key == "\\frac") {
            return "\\frac{}{}";
        } else if (key == "\\frac*") {
            return "\\frac*{}{}";
        } else {
            return key + "{}";
        };
    } else {
        return key
    };
};

// Copy second box (output) to clipboard
function copyTextOut() {
    const copyText = document.getElementById("text_out");
    if (copyText.disabled === false) {
        navigator.clipboard.writeText(copyText.value);
        copyButton.value = "Copied!";
        copyButton.style.cursor = "default";
        copyText.style.border = "2px solid black";

        setTimeout(() => {
            copyButton.value = "Copy text";
            copyButton.style.cursor = "pointer";
            copyText.style.border = "1px solid black";
        }, 2500)  // Returns to initial copyButton
    };
};

// Copy first box (input) to clipboard
function copyTextIn() {
    const textIn = document.getElementById("text_in");
    navigator.clipboard.writeText(textIn.value);
    textIn.style.border = "2px solid black";
    setTimeout(() => {
        textIn.style.border = "1px solid black";
    }, 2500);
};

// Clears everything
function clear() {
    copyButton.value = "Copy text";
    copyButton.style.cursor = "pointer";
    document.getElementById("mistakes").textContent = "";
    document.getElementById("text_out").disabled = true;
    suggestionsPopup.style.display = "none";
    suggestionsPopup.textContent = "";
};

// Add spaces ("\:" command)
function spaceCommand(text) {
    text = text.replace(/\u2710/g, " ");
    return text;
};

// Removes spaces and add some depending on surrounding symbols
function adjustSpacesCommon(input, symbolSpaced, conditionalSpaces) {
    input = input.slice(0, input.length - 1)
    if ((spacesButton.checked == true) && (input.length > 2)) {
        const noSpaceSymbols = Object.values(Superscript).concat(Object.values(Subscript), Object.values(Above), Object.values(Below)).filter(x => {return x !== "\u2710";});
        let output = "";
        input = input.replace(/ /g, "");
        let delayedSpace = false;
        let spaceStored = [];
        for (let i in input) {
            delayedSpace = noSpaceSymbols.includes(input[parseInt(i)+1]);
            if (symbolSpaced.includes(input[i])) {
                if ((output[output.length - 1] !== " ") && (output[output.length - 1] !== undefined)) {
                    if (delayedSpace) {
                        output += " " + input[i];
                        spaceStored.push(" ");
                    } else {
                        output += " " + input[i] + " ";
                    }
                } else {
                    if (delayedSpace) {
                        output += input[i];
                        spaceStored.push(" ");
                    } else {
                        output += input[i] + " ";
                    };
                };
            } else if (conditionalSpaces.includes(input[i])) {
                if ((output[output.length - 1] !== " ") && (output[output.length - 1] !== undefined)) {
                    if (delayedSpace) {
                        output += " " + input[i];
                    } else {
                        output += " " + input[i] + " ";
                    };
                } else {
                    output += input[i];
                };
            } else {
                if (spaceStored.length >= 1) {
                    output += input[i] + " ";
                    spaceStored = [];
                }
                else {
                    output += input[i];
                }
            };
        };
        return spaceCommand(output);
    } else {
        return spaceCommand(input);
    };
};

// Calls adjustSpacesCommon with specific symbols where spaces around them should be omitted
function adjustSpaces(input) {
    const symbolSpaced = ["=", "\u003D", "\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
                "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
                "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
                "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
                "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
                "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2261", "\u2A67", "\u2263",
                "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
                "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
                "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2225",
                "\u2226", "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974"];
    const conditionalSpaces = ["+", "-", "\u002B", "\u2212", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};

// Calls adjustSpacesCommon with specific symbols where spaces around them should be omitted
function adjustSpaceChem(input) {
    const symbolSpaced = ["\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
            "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
            "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
            "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
            "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
            "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2A67",
            "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
            "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
            "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2225",
            "\u2226", "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974"];
    const conditionalSpaces = ["+", "\u002B", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};

// Main function, loops on letters and convert the input into characters
function replaceText(fullText, plainTextConverter) {
    // TODO: Clean the function, it is quite a mess
    let newText = "";
    let temporaryBox = [];
    let temporaryArg = [];
    let commandInArg = [];
    let trigger = false;
    let arg = false;
    let triggerInArg = false;
    let numberCurly = 0;
    const parentheses = ["(", ")"];
    const brackets = ["[", "]"];
    const commandStoppers = [" ", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!"];  // parentheses and brackets also stops commands (most of the time)

    for (let char=0; char<fullText.length; char++) {
        if (trigger) {
            if (arg) {
                if (triggerInArg) {
                    if (commandStoppers.includes(fullText[char])) {
                        temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                        temporaryArg.push(plainTextConverter[fullText[char]]);
                        commandInArg = [];
                        triggerInArg = false;
                    } else if (fullText[char] === "}") {
                        if (fullText[char - 1] === "\\") {
                            temporaryArg.push(fullText[char]);
                            triggerInArg = false;
                            commandInArg = [];
                        } else {
                            if (temporaryBox.join("").slice(0, 5) === "\\sqrt") {
                                temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                                newText += addSymbol(mathDictionary["\\sqrt"](temporaryArg, temporaryBox.join("")));
                                mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", mathDictionary["\\sqrt"], temporaryBox.join(""));
                                temporaryBox = [];
                                temporaryArg = [];
                                commandInArg = [];
                                triggerInArg = false;
                                arg = false;
                                trigger = false;
                                    numberCurly += 1;
                            } else if ((temporaryBox.join("") === "\\frac") || (temporaryBox.join("") === "\\frac*")) {
                                if (temporaryArg.indexOf("}") === -1) {
                                    temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                                    temporaryArg.push(fullText[char]);
                                    commandInArg = [];
                                    triggerInArg = false;
                                } else {
                                    if ((temporaryArg.join("") === "\\frac") || (temporaryArg.join("") === "\\frac*")) {
                                        temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                                        newText += addSymbol(mathDictionary[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                        mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", undefined, "Embedded \\frac are currently not accepted");
                                        temporaryBox = [];
                                        temporaryArg = [];
                                        commandInArg = [];
                                        triggerInArg = false;
                                        arg = false;
                                        trigger = false;
                                        numberCurly += 1;
                                    } else {
                                        temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                                        newText += addSymbol(mathDictionary[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                        mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", mathDictionary[temporaryBox.join("")], temporaryBox.join(""));
                                        temporaryBox = [];
                                        temporaryArg = [];
                                        commandInArg = [];
                                        triggerInArg = false;
                                        arg = false;
                                        trigger = false;
                                        numberCurly += 1;
                                    };
                                }
                            } else {
                                temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                                newText += addSymbol(mathDictionary[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", mathDictionary[temporaryBox.join("")], temporaryBox.join(""));
                                temporaryBox = [];
                                temporaryArg = [];
                                commandInArg = [];
                                triggerInArg = false;
                                arg = false;
                                trigger = false;
                                numberCurly += 1;
                            };
                        };
                    } else if (parentheses.includes(fullText[char])) {
                        if (fullText[char - 1] === "\\") {
                            temporaryArg.push(fullText[char]);
                            triggerInArg = false;
                            commandInArg = [];
                        } else {
                            temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                            temporaryArg.push(fullText[char]);
                            commandInArg = [];
                            triggerInArg = false;
                        };
                    } else if (brackets.includes(fullText[char])) {
                        if (fullText[char - 1] === "\\") {
                            temporaryArg.push(fullText[char]);
                            triggerInArg = false;
                            commandInArg = [];
                        } else {
                            if (commandInArg.join("").slice(0, 5) === "\\sqrt") {
                                commandInArg.push(fullText[char]);
                            } else {
                                temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                                temporaryArg.push(fullText[char]);
                                commandInArg = [];
                                triggerInArg = false;
                            };
                        };
                    } else if (fullText[char] === "{") {
                        if (fullText[char - 1] === "\\") {
                            temporaryArg.push(fullText[char]);
                            triggerInArg = false;
                            commandInArg = [];
                        } else {
                            if ((commandInArg.join("") === "\\frac") || commandInArg.join("") === "\\frac*") {
                                mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", undefined, "Embedded \\frac are currently not accepted. Try: ^{(y/z)}/_{x} ⇒ ⁽ʸᐟᶻ⁾/ₓ"); 
                            } else {
                                let embCommand = embeddedCommand(commandInArg.join(""), fullText.substring(char), plainTextConverter);
                                for (let i in embCommand[0]) {
                                    temporaryArg.push(embCommand[0][i]);
                                };
                                char += embCommand[1] + 1;
                                triggerInArg = false;
                                commandInArg = [];
                            };
                        };
                    } else if ((fullText[char] === "\\") || (fullText[char] === "^") || (fullText[char] === "_")) {
                        temporaryArg.push(prohibitedType(mathDictionary[commandInArg.join("")]));
                        commandInArg = [fullText[char]];
                    } else {
                        commandInArg.push(fullText[char]);
                    };
                } else {
                    if (fullText[char] === "}") {
                        if (temporaryBox.join("").slice(0, 5) === "\\sqrt") {
                            mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", mathDictionary["\\sqrt"], temporaryBox.join(""));
                            newText += addSymbol(mathDictionary["\\sqrt"](temporaryArg, temporaryBox.join("")));
                            temporaryBox = [];
                            temporaryArg = [];
                            arg = false;
                            trigger = false;
                            numberCurly += 1;
                        } else if ((temporaryBox.join("") === "\\frac") || (temporaryBox.join("") === "\\frac*")) {
                            if (temporaryArg.indexOf("}") === -1) {
                                temporaryArg.push(fullText[char]);
                            } else {
                                mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", mathDictionary[temporaryBox.join("")], temporaryBox.join(""));
                                newText += addSymbol(mathDictionary[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                                temporaryBox = [];
                                temporaryArg = [];
                                arg = false;
                                trigger = false;
                                numberCurly += 1;
                            };
                        } else {
                            mistakes(temporaryBox.join("") + "{" + temporaryArg.join("") + "}", mathDictionary[temporaryBox.join("")], temporaryBox.join(""));
                            newText += addSymbol(mathDictionary[temporaryBox.join("")](temporaryArg, temporaryBox.join("")));
                            temporaryBox = [];
                            temporaryArg = [];
                            arg = false;
                            trigger = false;
                            numberCurly += 1;
                        };
                    } else if ((fullText[char] === "\\") || (fullText[char] === "^") || (fullText[char] === "_")) {
                        triggerInArg = true;
                        commandInArg.push(fullText[char]);
                    } else {
                        temporaryArg.push(plainTextConverter[fullText[char]]);
                    };
                };
            } else {
                if (fullText[char] == "{") {
                    if (fullText[char - 1] === "\\") {
                        newText += addSymbol(plainTextConverter[fullText[char]]);
                        trigger = false;
                        temporaryBox = [];
                    } else {
                        if ((typeof mathDictionary[temporaryBox.join("")] == "function") || (temporaryBox.join("").slice(0, 5) === "\\sqrt")) {
                            arg = true;
                            numberCurly += 1;
                        } else {
                            if ((typeof mathDictionary[temporaryBox.join("")] == "function") || (temporaryBox.join("").slice(0, 5) === "\\sqrt")) {
                                arg = true;
                                numberCurly += 1;
                            } else {
                                newText += addSymbol(mathDictionary[temporaryBox.join("")]);
                                mistakes(temporaryBox.join(""), mathDictionary[temporaryBox.join("")]);
                                newText += "{";
                                temporaryBox = [];
                                trigger = false;
                            };
                        };
                    };
                } else if (fullText[char] == "}") {
                    if (fullText[char - 1] === "\\") {
                        newText += addSymbol(plainTextConverter[fullText[char]]);
                        trigger = false;
                        temporaryBox = [];
                    } else {
                        newText += addSymbol(mathDictionary[temporaryBox.join("")]);
                        newText += addSymbol(undefined);
                        mistakes(temporaryBox.join("") + "}", undefined, " '" + temporaryBox.join("") + "\\}' and " + "'" + temporaryBox.join("") + " }' ⇒ '" + temporaryBox.join("") + "}' ");
                        temporaryBox = [];
                        trigger = false;
                    }
                } else if (commandStoppers.includes(fullText[char])) {
                    if (temporaryBox.join("").replace(/\[.*\]/g, "") === "\\sqrt*") {
                        newText += addSymbol(mathDictionary["\\sqrt*"](undefined, temporaryBox.join("")));
                        mistakes(temporaryBox.join(""), mathDictionary["\\sqrt*"]);
                        newText += addSymbol(plainTextConverter[fullText[char]]);
                        temporaryBox = [];
                        trigger = false;
                    } else {
                        newText += !(typeof mathDictionary[temporaryBox.join("")] == "function") ? 
                        addSymbol(mathDictionary[temporaryBox.join("")]) + plainTextConverter[fullText[char]] : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                        mistakes(temporaryBox.join(""), mathDictionary[temporaryBox.join("")]);
                        temporaryBox = [];
                        trigger = false;
                    };
                } else if ((fullText[char] === "\\") || (fullText[char] === "^") || fullText[char] === "_") {
                    if (fullText[char - 1] === "\\") {
                        temporaryBox.push(fullText[char]);
                        newText += addSymbol(mathDictionary[temporaryBox.join("")]);
                        trigger = false;
                        temporaryBox = [];
                    } else {
                        if (temporaryBox.join("").replace(/\[.*\]/g, "") === "\\sqrt*") {
                            newText += addSymbol(mathDictionary["\\sqrt*"](undefined, temporaryBox.join("")));
                            mistakes(temporaryBox.join(""), mathDictionary["\\sqrt*"]);
                            temporaryBox = [fullText[char]];
                        } else {
                            newText += !(typeof mathDictionary[temporaryBox.join("")] == "function") ? 
                            addSymbol(mathDictionary[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                            mistakes(temporaryBox.join(""), mathDictionary[temporaryBox.join("")]);
                            temporaryBox = [fullText[char]];
                        };
                    };
                } else if (parentheses.includes(fullText[char])) {
                    if (temporaryBox.join("").replace(/\[.*\]/g, "") === "\\sqrt*") {
                        newText += addSymbol(mathDictionary["\\sqrt*"](undefined, temporaryBox.join("")));
                        mistakes(temporaryBox.join(""), mathDictionary["\\sqrt*"]);
                        newText += addSymbol(plainTextConverter[fullText[char]]);
                        temporaryBox = [];
                        trigger = false;
                    } else {
                        newText += !(typeof mathDictionary[temporaryBox.join("")] == "function") ? 
                        addSymbol(mathDictionary[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                        mistakes(temporaryBox.join(""), mathDictionary[temporaryBox.join("")]);
                        newText += addSymbol(plainTextConverter[fullText[char]]);
                        temporaryBox = [];
                        trigger = false;
                    };
                } else if (brackets.includes(fullText[char])) {
                    if (temporaryBox.join("").slice(0,5) === "\\sqrt") {
                        temporaryBox.push(fullText[char]);
                    } else {
                        newText += !(typeof mathDictionary[temporaryBox.join("")] == "function") ? 
                        addSymbol(mathDictionary[temporaryBox.join("")]) : mistakes(temporaryBox.join("") + "{} needs an argument.", undefined);
                        mistakes(temporaryBox.join(""), mathDictionary[temporaryBox.join("")]);
                        newText += addSymbol(plainTextConverter[fullText[char]]);
                        temporaryBox = [];
                        trigger = false;
                    };
                } else {
                    temporaryBox.push(fullText[char]);
                };
            };
        } else {
            if ((fullText[char] === "\\") || (fullText[char] === "^") || (fullText[char] === "_")) {
                temporaryBox.push(fullText[char]);
                trigger = true;
            } else {
                newText += addSymbol(plainTextConverter[fullText[char]]);
                mistakes(fullText[char], plainTextConverter[fullText[char]]);
            }
        };
    };
    if (numberCurly % 2 !== 0) {
        mistakes("Missing curly brackets { }", undefined);
    };
    return newText;
};

// Is called if there is a command as an argument of a command
function embeddedCommand(command, endOfText, plainTextConverter) {
    let args = [];
    endOfText = endOfText.substring(1);
    for (let c in endOfText) {
        if (endOfText[c] === "}") {
            if (endOfText[c - 1] === "\\") {
                args.splice(-1, 1);
                args.push(endOfText[c]);
            } else {
                if (command.slice(0, 5) === "\\sqrt") {
                    mistakes("Embedded \\sqrt are not best practice, use '\\sqrt[n]* (\\sqrt[k]* x)' instead of '\\sqrt[n]{\\sqrt[k]{x}}'", undefined, "ⁿ√(ᵏ√𝑥)");
                    return [addSymbol(mathDictionary["\\sqrt"](args, command), true), parseInt(c)];
                } else {
                    return [addSymbol(mathDictionary[command](args, command), true), parseInt(c)];
                };
            };
        } else {
            args.push(plainTextConverter[endOfText[c]]);
        };
    };
};

// Matrix package, converts arrays into a matrix
function matrix(text) {
    text = text.replace(/ /g, "");
    let matrixText = "";
    let i, x;
    let cpt = 0;
    let rceil = 0;
    let lceil = 0;
    let lfloor = 0;
    let rfloor = 0;

    for (x in text) {
        if (text[x] == "[" || text[x] == "]") {
            cpt += 1;
        };
    };
    if (cpt == 2) {
        // vector (ie single line matrix)
        matrixText = text.replace(/ /g, "");
        matrixText = matrixText.replace(/\[/g, "[ ");
        matrixText = matrixText.replace(/\]/g, " ]");
        matrixText = matrixText.replace(/,/g, "\u2710");
        return matrixText;
    } else {
        for (i in text) {
            if (text[i] == "[" && rceil == 0) {
                matrixText += "\u23A1 ";
                rceil += 1;
            } else if (text[i] == "]" && lceil == 0) {
                matrixText += " \u23A4\u000A";
                lceil += 1;
            } else if (text[i] == "]") {
                matrixText += " \u23A5\u000A";
            } else if (text[i] == "[") {
                matrixText += "\u23A2 ";
            } else {
                matrixText += text[i];
            }
        };
        for (let n = matrixText.length; n > 0; n--) {
            if (matrixText[n] == "\u23A5" && n > rfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A6";
                matrixText[n+1] = "";  // removes "\u000A" since it's the last line
                matrixText = matrixText.join("");
                rfloor = n;
            } else if (matrixText[n] == "\u23A2" && n > lfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A3";
                matrixText = matrixText.join("");
                lfloor = n;
            };
        };
    };
    matrixText = matrixCols(matrixText);  // Adjusts columns width
    matrixText = matrixText.replace(/,/g, " ");  // Add spaces between characters
    if ((cpt % 2 != 0) || (cpt == 0)) {
        matrixText = "";
        mistakes('Wrong arguments given" \r\n \r\nExample: "$matrix [a,b,c] [d,e,f] [1,2,3]', undefined);
    };
    return matrixText;
};

// Adjusts columns length for $matrix package
function matrixCols(matrix) {
    let positionLength = 0;
    let posLengths = [];
    let matrixPositions = [];
    let matrixPos = 0;
    let realPositions = [];
    for (let i in matrix) {
        if (matrix[i] == ",") {
            matrixPositions.push(matrixPos);
            matrixPos += 1;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-1);
        } else if ((matrix[i] == "\u23A4") || (matrix[i] == "\u23A5") || (matrix[i] == "\u23A6")) {  // right bracket
            matrixPositions.push(matrixPos);
            matrixPos = 0;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-2);
        } else if ((matrix[i] == "\u23A1") || (matrix[i] == "\u23A2") || (matrix[i] == "\u23A3") || (matrix[i] == " ") || (matrix[i] == "\u000A")) {  // left bracket and spaces
            continue;
        } else {
            positionLength += 1;
        };
    };
    // Add spaces to adjust columns length
    let spacesAdded = 1;
    for (let i in posLengths) {
        for (let n in matrixPositions) {
            if (matrixPositions[i] == matrixPositions[n]) {
                matrix = matrix.split("");
                while (posLengths[i] < posLengths[n]) {
                    matrix.splice(realPositions[i] + spacesAdded, 0, " ");
                    posLengths[i] += 1;
                    spacesAdded += 1;
                };
                matrix = matrix.join("");
            };
        };
    };
    return matrix;
};

// Return the command if it's defined, if not it returns a bold "err" with two "x" under it
function addSymbol(command, keepArray=false) {
    if ((typeof command == "object") && !(keepArray)) {
        command = command.join("");
    };
    return (command !== undefined) ? command : "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";
};

// Return the commands in an array if it's defined, if not it returns a bold "err" with two "x" under it
function addSymbolArray(args, command, checkMistakes=true) {
    let output = "";
    for (let i in args) {
        output += (args[i] !== undefined) ? args[i] : "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";
        if (checkMistakes) {
            mistakes(command, args[i], "A symbol does not exist or can't be shown");
        };
    };
    return output;
};

// Make sure the command is of the right type. Most of the time "function" is the one to watch
function prohibitedType(command, type="function") {
    return (typeof command != type) ? command : "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";
};

// Writes every errors in a box, so it's easier to find them
function mistakes(textInput, textOutput, letter="") {
    const popup = document.getElementById("mistakes");
    popup.setAttribute("style", "white-space: pre;");
    const text = "\u{1D404}\u{1D42B}\u{1D42B}\u{1D428}\u{1D42B}\u{1D42C}: \r\n";  // "Errors" in bold
    if (textOutput === undefined) {
        if (letter != "") {
            if (letter !== "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}") {
                // Only add to errorsList once
                errorsList += textInput + " \u2192 " + '"' + letter + '" \r\n';
            };
        } else {
            if ((textInput[0] === "^") || (textInput[0] === "_")) {
                if (textInput.indexOf(" needs an argument.") !== -1) {
                    const example = (textInput[0] === "^") ? "¹" : "₁";
                    errorsList += "For '" + textInput[0] + "' alone: \\" + textInput[0] + " \u2192 " + textInput[0] + 
                    "  |  To use '" + textInput[0] + "' as a command: " + textInput[0] + "{1} \u2192 " + example + "\r\n";
                } else {
                    errorsList += '"' + textInput + '" \u2192 ' + "try: " + textInput[0] + "{" + textInput.slice(1) + "}" + '\r\n';
                };
            } else {
                errorsList += '"' + textInput + '" \r\n';
            };
        };
    };
    if (errorsList.length > 0) {
        popup.textContent = text + errorsList;
        
        popup.style.fontFamily = "Times New Roman";
        popup.style.fontSize = "15px";
    };
    return "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}"; // bold "err" with two "x" under it
};

// Takes text and convert word by word in the dictionary or in function replaceLetters
function convert(fullText) {
    const firstWord = fullText.split(" ")[0];
    if (firstWord === "$chem") {
        fullText = fullText.replace("$chem", "");
        fullText = replaceText(fullText, lettersChem);
        fullText = adjustSpaceChem(fullText);
    } else if (firstWord === "$matrix") {
        fullText = fullText.replace("$matrix", "");
        fullText = matrix(fullText);
    } else {
        fullText = replaceText(fullText, lettersSymbols);
        fullText = adjustSpaces(fullText);
    };
    return fullText;
};

// Takes the original text and spits out the new one
function main() {
    document.getElementById("mistakes").textContent = "";  // Starts with an empty box for errors
    errorsList = "";  // Makes sure it starts empty

    let fullText = document.text_input.text_in.value;
    fullText = fullText.replace(/\u000A/g, " "); // Cancels the line skipped by pressing "enter", use "\\" instead

    fullText = convert(fullText + " ");
    document.text_input.text_out.value = fullText;
    document.getElementById("text_out").disabled = false;
};
